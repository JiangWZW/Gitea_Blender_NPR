From 216725151c9a50fa6d2c2eb756e143a4b9fadfd2 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 3 Dec 2022 16:46:19 +0800
Subject: [PATCH 01/13] strokegen engine basic framework try#1
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

implemented based on BasicEngine, EEVEE Next, and the code snippet given by Clément Foucault.

Including
1) the integration into blender ui,
2) instance(empty yet)
3) shader module
---
 source/blender/draw/CMakeLists.txt            |   8 +
 .../shaders/infos/strokegen_depth_info.hh     |  65 +++
 .../shaders/strokegen_depth_curves_vert.glsl  |  27 ++
 .../shaders/strokegen_depth_frag.glsl         |   5 +
 .../strokegen_depth_pointcloud_vert.glsl      |  15 +
 .../shaders/strokegen_depth_vert.glsl         |  14 +
 .../strokgen_conservative_depth_geom.glsl     |  51 +++
 .../engines/strokegen/strokegen_engine.cc     | 413 ++++++++++++++++++
 .../draw/engines/strokegen/strokegen_engine.h |  31 ++
 .../engines/strokegen/strokegen_instance.cc   |  29 ++
 .../engines/strokegen/strokegen_instance.hh   |  75 ++++
 .../engines/strokegen/strokegen_shader.cc     | 119 +++++
 .../engines/strokegen/strokegen_shader.hh     |  62 +++
 source/blender/draw/intern/draw_manager.c     |   4 +
 14 files changed, 918 insertions(+)
 create mode 100644 source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_engine.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_engine.h
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_instance.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_instance.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader.hh

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 2093c8a2331..76bdd97ae20 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -208,6 +208,11 @@ set(SRC
   engines/overlay/overlay_viewer_attribute.cc
   engines/overlay/overlay_volume.cc
   engines/overlay/overlay_wireframe.cc
+  engines/strokegen/strokegen_engine.cc
+  engines/strokegen/strokegen_shader.cc
+  engines/strokegen/strokegen_instance.cc
+
+
 
   DRW_engine.h
   DRW_pbvh.h
@@ -297,6 +302,9 @@ set(SRC
   engines/select/select_private.h
   engines/overlay/overlay_engine.h
   engines/overlay/overlay_private.hh
+  engines/strokegen/strokegen_engine.h
+  engines/strokegen/strokegen_shader.hh
+  engines/strokegen/strokegen_instance.hh
 )
 
 set(LIB
diff --git a/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
new file mode 100644
index 00000000000..e275d208c7a
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include "gpu_shader_create_info.hh"
+
+/* -------------------------------------------------------------------- */
+/** \name Conservative Rasterization
+ *
+ * Allow selection of sub-pixel objects.
+ * \{ */
+
+GPU_SHADER_CREATE_INFO(basic_conservative)
+    .geometry_layout(PrimitiveIn::TRIANGLES, PrimitiveOut::TRIANGLE_STRIP, 3)
+    .geometry_source("basic_conservative_depth_geom.glsl");
+
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Object types
+ * \{ */
+
+GPU_SHADER_CREATE_INFO(basic_mesh)
+    .vertex_in(0, Type::VEC3, "pos")
+    .vertex_source("basic_depth_vert.glsl")
+    .additional_info("draw_mesh");
+
+GPU_SHADER_CREATE_INFO(basic_pointcloud)
+    .vertex_source("basic_depth_pointcloud_vert.glsl")
+    .additional_info("draw_pointcloud");
+
+GPU_SHADER_CREATE_INFO(basic_curves)
+    .vertex_source("basic_depth_curves_vert.glsl")
+    .additional_info("draw_hair");
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Variations Declaration
+ * \{ */
+
+#define BASIC_FINAL_VARIATION(name, ...) \
+  GPU_SHADER_CREATE_INFO(name).additional_info(__VA_ARGS__).do_static_compilation(true);
+
+#define BASIC_CLIPPING_VARIATIONS(prefix, ...) \
+  BASIC_FINAL_VARIATION(prefix##_clipped, "drw_clipped", __VA_ARGS__) \
+  BASIC_FINAL_VARIATION(prefix, __VA_ARGS__)
+
+#define BASIC_CONSERVATIVE_VARIATIONS(prefix, ...) \
+  BASIC_CLIPPING_VARIATIONS(prefix##_conservative, "basic_conservative", __VA_ARGS__) \
+  BASIC_CLIPPING_VARIATIONS(prefix, __VA_ARGS__)
+
+#define BASIC_OBTYPE_VARIATIONS(prefix, ...) \
+  BASIC_CONSERVATIVE_VARIATIONS(prefix##_mesh, "basic_mesh", __VA_ARGS__) \
+  BASIC_CONSERVATIVE_VARIATIONS(prefix##_pointcloud, "basic_pointcloud", __VA_ARGS__) \
+  BASIC_CLIPPING_VARIATIONS(prefix##_curves, "basic_curves", __VA_ARGS__)
+
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Depth shader types.
+ * \{ */
+
+GPU_SHADER_CREATE_INFO(basic_depth).fragment_source("basic_depth_frag.glsl");
+
+BASIC_OBTYPE_VARIATIONS(basic_depth, "basic_depth", "draw_globals");
+
+/** \} */
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
new file mode 100644
index 00000000000..b0da9754fc6
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
@@ -0,0 +1,27 @@
+
+#pragma BLENDER_REQUIRE(common_hair_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+
+void main()
+{
+  GPU_INTEL_VERTEX_SHADER_WORKAROUND
+
+  bool is_persp = (ProjectionMatrix[3][3] == 0.0);
+  float time, thick_time, thickness;
+  vec3 world_pos, tan, binor;
+  hair_get_pos_tan_binor_time(is_persp,
+                              ModelMatrixInverse,
+                              ViewMatrixInverse[3].xyz,
+                              ViewMatrixInverse[2].xyz,
+                              world_pos,
+                              tan,
+                              binor,
+                              time,
+                              thickness,
+                              thick_time);
+
+  gl_Position = point_world_to_ndc(world_pos);
+
+  view_clipping_distances(world_pos);
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
new file mode 100644
index 00000000000..ff4a015c335
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
@@ -0,0 +1,5 @@
+
+void main()
+{
+  /* Passthrough shader. */
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
new file mode 100644
index 00000000000..b82edc61cee
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
@@ -0,0 +1,15 @@
+
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+#pragma BLENDER_REQUIRE(common_pointcloud_lib.glsl)
+
+void main()
+{
+  GPU_INTEL_VERTEX_SHADER_WORKAROUND
+
+  vec3 world_pos = pointcloud_get_pos();
+
+  gl_Position = point_world_to_ndc(world_pos);
+
+  view_clipping_distances(world_pos);
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
new file mode 100644
index 00000000000..7046979cf97
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
@@ -0,0 +1,14 @@
+
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+
+void main()
+{
+  GPU_INTEL_VERTEX_SHADER_WORKAROUND
+
+  vec3 world_pos = point_object_to_world(pos);
+
+  gl_Position = point_world_to_ndc(world_pos);
+
+  view_clipping_distances(world_pos);
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl b/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
new file mode 100644
index 00000000000..73b171e5cb6
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
@@ -0,0 +1,51 @@
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+
+/* Adaptation of Conservative Rasterization
+ * from GPU Gems 2
+ * Using method 2.
+ *
+ * Actual final implementation does not do conservative rasterization and only
+ * avoids triangles producing no fragments.
+ */
+
+void main()
+{
+  /* Compute plane normal in NDC space. */
+  vec3 pos0 = gl_in[0].gl_Position.xyz / gl_in[0].gl_Position.w;
+  vec3 pos1 = gl_in[1].gl_Position.xyz / gl_in[1].gl_Position.w;
+  vec3 pos2 = gl_in[2].gl_Position.xyz / gl_in[2].gl_Position.w;
+  vec3 plane = normalize(cross(pos1 - pos0, pos2 - pos0));
+  /* Compute NDC bound box. */
+  vec4 bbox = vec4(min(min(pos0.xy, pos1.xy), pos2.xy), max(max(pos0.xy, pos1.xy), pos2.xy));
+  /* Convert to pixel space. */
+  bbox = (bbox * 0.5 + 0.5) * sizeViewport.xyxy;
+  /* Detect failure cases where triangles would produce no fragments. */
+  bvec2 is_subpixel = lessThan(bbox.zw - bbox.xy, vec2(1.0));
+  /* View aligned triangle. */
+  const float threshold = 0.00001;
+  bool is_coplanar = abs(plane.z) < threshold;
+
+  for (int i = 0; i < 3; i++) {
+    gl_Position = gl_in[i].gl_Position;
+    if (all(is_subpixel)) {
+      vec2 ofs = (i == 0) ? vec2(-1.0) : ((i == 1) ? vec2(2.0, -1.0) : vec2(-1.0, 2.0));
+      /* HACK: Fix cases where the triangle is too small make it cover at least one pixel. */
+      gl_Position.xy += sizeViewportInv * gl_Position.w * ofs;
+    }
+    /* Test if the triangle is almost parallel with the view to avoid precision issues. */
+    else if (any(is_subpixel) || is_coplanar) {
+      /* HACK: Fix cases where the triangle is Parallel to the view by deforming it slightly. */
+      vec2 ofs = (i == 0) ? vec2(-1.0) : ((i == 1) ? vec2(1.0, -1.0) : vec2(1.0));
+      gl_Position.xy += sizeViewportInv * gl_Position.w * ofs;
+    }
+    else {
+      /* Triangle expansion should happen here, but we decide to not implement it for
+       * depth precision & performance reasons. */
+    }
+
+    view_clipping_distances_set(gl_in[i]);
+    EmitVertex();
+  }
+  EndPrimitive();
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/strokegen/strokegen_engine.cc
new file mode 100644
index 00000000000..b4267ce42f5
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_engine.cc
@@ -0,0 +1,413 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2016 Blender Foundation. */
+
+/** \file
+ * \ingroup draw_engine
+ *
+ * Simple engine for drawing color and/or depth.
+ * When we only need simple flat shaders.
+ */
+
+#include "DRW_render.h"
+
+#include "BKE_object.h"
+#include "BKE_paint.h"
+
+#include "BLI_alloca.h"
+
+#include "GPU_shader.h"
+
+#include "strokegen_engine.h"
+
+#include "strokegen_instance.hh"
+#include "strokegen_shader.hh"
+
+
+using namespace blender;
+
+
+
+#define STROKEGEN_ENGINE "BLENDER_STROKEGEN"
+
+/* *********** LISTS *********** */
+
+/* GPUViewport.storage
+ * Is freed every time the viewport engine changes. */
+typedef struct STROKEGEN_StorageList {
+  struct STROKEGEN_PrivateData *g_data;
+} STROKEGEN_StorageList;
+
+typedef struct STROKEGEN_PassList {
+  struct DRWPass *depth_pass[2];
+  struct DRWPass *depth_pass_pointcloud[2];
+  struct DRWPass *depth_pass_cull[2];
+} STROKEGEN_PassList;
+
+// Per-engine data
+// Sent by draw manager to the draw-engine.
+typedef struct STROKEGEN_Data {
+  void *engine_type;
+  DRWViewportEmptyList *fbl;
+  DRWViewportEmptyList *txl;
+  STROKEGEN_PassList *psl;
+  STROKEGEN_StorageList *stl;
+
+  strokegen::Instance *instance;
+  char info[GPU_INFO_SIZE];
+
+} STROKEGEN_Data;
+
+/* *********** STATIC *********** */
+
+typedef struct STROKEGEN_PrivateData {
+  DRWShadingGroup *depth_shgrp[2];
+  DRWShadingGroup *depth_shgrp_cull[2];
+  DRWShadingGroup *depth_hair_shgrp[2];
+  DRWShadingGroup *depth_curves_shgrp[2];
+  DRWShadingGroup *depth_pointcloud_shgrp[2];
+  bool use_material_slot_selection;
+} STROKEGEN_PrivateData; /* Transient data */
+
+
+
+static bool check_strokegen_support()
+{
+  return GPU_shader_storage_buffer_objects_support();
+}
+
+
+static void strokegen_engine_init(void *vedata)
+{
+  if (!check_strokegen_support()) { return; }
+
+  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  if (ved->instance == nullptr) {
+    ved->instance = new strokegen::Instance();
+  }
+
+  const DRWContextState *ctx_state = DRW_context_state_get();
+  ved->instance->init(ctx_state->depsgraph, ctx_state->v3d);
+}
+
+
+
+static void strokegen_draw_scene_legacy(void *vedata)
+{
+  STROKEGEN_PassList *psl = ((STROKEGEN_Data *)vedata)->psl;
+
+  DRW_draw_pass(psl->depth_pass[0]);
+  DRW_draw_pass(psl->depth_pass_pointcloud[0]);
+  DRW_draw_pass(psl->depth_pass_cull[0]);
+  DRW_draw_pass(psl->depth_pass[1]);
+  DRW_draw_pass(psl->depth_pass_pointcloud[1]);
+  DRW_draw_pass(psl->depth_pass_cull[1]);
+}
+
+static void strokegen_draw_scene(void *vedata)
+{
+  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  if (!check_strokegen_support()) {
+    STRNCPY(ved->info, "Error: No shader storage buffer support, required by StrokeGen.");
+    return;
+  }
+
+
+  // TODO: not sure which is better, frame-buffer or texture list?
+  // DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
+  DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
+
+  const DRWView *default_view = DRW_view_default_get();
+  draw::Manager *manager = DRW_manager_get();
+  draw::View view("DefaultView", default_view);
+  ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
+
+
+  strokegen_draw_scene_legacy(vedata);
+
+
+  /* Reset view for other following engines. */
+  DRW_view_set_active(nullptr);
+}
+
+
+
+
+static void strokegen_cache_init_legacy(void *vedata)
+{
+  STROKEGEN_PassList *psl = static_cast<STROKEGEN_Data*>(vedata)->psl;
+  STROKEGEN_StorageList *stl = static_cast<STROKEGEN_Data*>(vedata)->stl;
+  DRWShadingGroup *grp;
+
+  const DRWContextState *draw_ctx = DRW_context_state_get();
+
+  if (!stl->g_data) {
+    /* Alloc transient pointers */
+    stl->g_data = (STROKEGEN_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
+  }
+
+  stl->g_data->use_material_slot_selection = DRW_state_is_material_select();
+
+  /* Twice for normal and in front objects. */
+  for (int i = 0; i < 2; i++) {
+    DRWState clip_state = static_cast<DRWState>(
+      (draw_ctx->sh_cfg == GPU_SHADER_CFG_CLIPPED) ? DRW_STATE_CLIP_PLANES : 0
+    );
+    DRWState infront_state = static_cast<DRWState>(
+      (DRW_state_is_select() && (i == 1)) ? DRW_STATE_IN_FRONT_SELECT : 0
+    );
+    DRWState state = DRW_STATE_WRITE_DEPTH | DRW_STATE_DEPTH_LESS_EQUAL;
+
+    blender::strokegen::ShaderModule* shaderModule =
+      blender::strokegen::ShaderModule::module_get();
+
+    GPUShader *sh = DRW_state_is_select() ?
+                        shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
+                        shaderModule->static_shader_get(blender::strokegen::DEPTH);
+
+    DRW_PASS_CREATE(psl->depth_pass[i], state | clip_state | infront_state);
+    stl->g_data->depth_shgrp[i] = grp = DRW_shgroup_create(sh, psl->depth_pass[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    sh = DRW_state_is_select() ?
+        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH_CONSERVATIVE) :
+        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH);
+    DRW_PASS_CREATE(psl->depth_pass_pointcloud[i], state | clip_state | infront_state);
+    stl->g_data->depth_pointcloud_shgrp[i] = grp = DRW_shgroup_create(
+        sh, psl->depth_pass_pointcloud[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    stl->g_data->depth_hair_shgrp[i] = grp = DRW_shgroup_create(
+        shaderModule->static_shader_get(blender::strokegen::DEPTH), psl->depth_pass[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    stl->g_data->depth_curves_shgrp[i] = grp = DRW_shgroup_create(
+        shaderModule->static_shader_get(blender::strokegen::CURVES_DEPTH), psl->depth_pass[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
+                                 shaderModule->static_shader_get(blender::strokegen::DEPTH);
+    state |= DRW_STATE_CULL_BACK;
+    DRW_PASS_CREATE(psl->depth_pass_cull[i], state | clip_state | infront_state);
+    stl->g_data->depth_shgrp_cull[i] = grp = DRW_shgroup_create(sh, psl->depth_pass_cull[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+  }
+}
+static void strokegen_cache_init(void *vedata)
+{
+  if (!check_strokegen_support()) return;
+
+  draw::Manager* drwmgr = DRW_manager_get();
+  reinterpret_cast<STROKEGEN_Data *>(vedata)->instance->begin_sync(*drwmgr);
+
+
+  strokegen_cache_init_legacy(vedata);
+}
+
+
+
+
+
+
+
+
+
+/* TODO(fclem): DRW_cache_object_surface_material_get needs a refactor to allow passing NULL
+ * instead of gpumat_array. Avoiding all this boilerplate code. */
+static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
+{
+  const int materials_len = DRW_cache_object_material_count_get(ob);
+  struct GPUMaterial **gpumat_array =
+    static_cast<GPUMaterial**>(BLI_array_alloca(gpumat_array, materials_len));
+  memset(gpumat_array, 0, sizeof(*gpumat_array) * materials_len);
+
+  return DRW_cache_object_surface_material_get(ob, gpumat_array, materials_len);
+}
+
+static void strokegen_cache_populate_particles(void *vedata, Object *ob)
+{
+  // do nothing here.
+}
+
+static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+{
+  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+
+  /* TODO(fclem): fix selection of smoke domains. */
+
+  if (!DRW_object_is_renderable(ob) || (ob->dt < OB_SOLID)) {
+    return;
+  }
+
+  const DRWContextState *draw_ctx = DRW_context_state_get();
+  if (ob != draw_ctx->object_edit) {
+    strokegen_cache_populate_particles(vedata, ob);
+  }
+
+  const bool do_in_front = (ob->dtx & OB_DRAW_IN_FRONT) != 0;
+  if (ob->type == OB_CURVES) {
+    DRW_shgroup_curves_create_sub(ob, stl->g_data->depth_curves_shgrp[do_in_front], NULL);
+  }
+
+  /* Make flat object selectable in ortho view if wireframe is enabled. */
+  if ((draw_ctx->v3d->overlay.flag & V3D_OVERLAY_WIREFRAMES) ||
+      (draw_ctx->v3d->shading.type == OB_WIRE) || (ob->dtx & OB_DRAWWIRE) || (ob->dt == OB_WIRE)) {
+    int flat_axis = 0;
+    bool is_flat_object_viewed_from_side = ((draw_ctx->rv3d->persp == RV3D_ORTHO) &&
+                                            DRW_object_is_flat(ob, &flat_axis) &&
+                                            DRW_object_axis_orthogonal_to_view(ob, flat_axis));
+
+    if (is_flat_object_viewed_from_side) {
+      /* Avoid losing flat objects when in ortho views (see T56549) */
+      struct GPUBatch *geom = DRW_cache_object_all_edges_get(ob);
+      if (geom) {
+        DRW_shgroup_call(stl->g_data->depth_shgrp[do_in_front], geom, ob);
+      }
+      return;
+    }
+  }
+
+  const bool use_sculpt_pbvh = BKE_sculptsession_use_pbvh_draw(ob, draw_ctx->rv3d) &&
+                               !DRW_state_is_image_render();
+  const bool do_cull = (draw_ctx->v3d &&
+                        (draw_ctx->v3d->shading.flag & V3D_SHADING_BACKFACE_CULLING));
+
+  DRWShadingGroup *shgrp = NULL;
+
+  if (ob->type == OB_POINTCLOUD) {
+    shgrp = stl->g_data->depth_pointcloud_shgrp[do_in_front];
+  }
+  else {
+    shgrp = (do_cull) ? stl->g_data->depth_shgrp_cull[do_in_front] :
+                        stl->g_data->depth_shgrp[do_in_front];
+  }
+
+  if (use_sculpt_pbvh) {
+    DRW_shgroup_call_sculpt(shgrp, ob, false, false, false, false, false);
+  }
+  else {
+    if (stl->g_data->use_material_slot_selection && BKE_object_supports_material_slots(ob)) {
+      struct GPUBatch **geoms = strokegen_object_surface_material_get(ob);
+      if (geoms) {
+        const int materials_len = DRW_cache_object_material_count_get(ob);
+        for (int i = 0; i < materials_len; i++) {
+          if (geoms[i] == NULL) {
+            continue;
+          }
+          const short material_slot_select_id = i + 1;
+          DRW_select_load_id(ob->runtime.select_id | (material_slot_select_id << 16));
+          DRW_shgroup_call(shgrp, geoms[i], ob);
+        }
+      }
+    }
+    else {
+      struct GPUBatch *geom = DRW_cache_object_surface_get(ob);
+      if (geom) {
+        DRW_shgroup_call(shgrp, geom, ob);
+      }
+    }
+  }
+}
+static void strokegen_cache_populate(void *vedata, Object *object)
+{
+  if (!check_strokegen_support()) return;
+
+  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+
+  draw::Manager* drw_mgr = DRW_manager_get();
+  draw::ObjectRef ref {
+    object,
+    DRW_object_get_dupli(object),
+    DRW_object_get_dupli_parent(object)
+  };
+
+  ved->instance->object_sync(*drw_mgr, ref);
+
+
+
+  strokegen_cache_populate_legacy(vedata, object);
+}
+
+
+static void strokegen_cache_finish_legacy(void *vedata)
+{
+  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+
+  UNUSED_VARS(stl);
+}
+static void strokegen_cache_finish(void *vedata)
+{
+  if (!check_strokegen_support()) return;
+
+  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data*>(vedata);
+  draw::Manager* drw_mgr = DRW_manager_get();
+
+  ved->instance->end_sync(*drw_mgr);
+
+
+
+  strokegen_cache_finish_legacy(vedata);
+}
+
+static void strokegen_instance_free(void *instance) {
+  if (!GPU_shader_storage_buffer_objects_support()) {
+    return;
+  }
+  delete reinterpret_cast<strokegen::Instance *>(instance);
+}
+
+static void strokegen_engine_free(void)
+{
+  strokegen::ShaderModule::module_free();
+}
+
+static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
+                                    struct RenderLayer *layer,
+                                    const struct rcti *UNUSED(rect)) {
+  UNUSED_VARS(vedata, engine, layer);
+}
+
+
+
+
+
+
+static const DrawEngineDataSize strokegen_data_size = DRW_VIEWPORT_DATA_SIZE(STROKEGEN_Data);
+
+DrawEngineType draw_engine_strokegen_type = {
+    NULL,
+    NULL,
+    N_("StrokeGen"),
+    &strokegen_data_size,
+    strokegen_engine_init,
+    &strokegen_engine_free,
+    &strokegen_instance_free,
+    &strokegen_cache_init,
+    &strokegen_cache_populate,
+    &strokegen_cache_finish,
+    &strokegen_draw_scene,
+    NULL,
+    NULL,
+    strokegen_render_to_image,
+    NULL,
+};
+
+RenderEngineType DRW_engine_viewport_strokegen_type = {
+  nullptr,
+  nullptr,
+  "STROKEGEN_VIEW",
+  N_("strokegen"),
+  RE_INTERNAL | RE_USE_PREVIEW | RE_USE_STEREO_VIEWPORT | RE_USE_GPU_CONTEXT,
+  nullptr,
+  &DRW_render_to_image,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr, // TODO: impl this
+  &draw_engine_strokegen_type,
+  {nullptr, nullptr, nullptr},
+};
+
+#undef STROKEGEN_ENGINE
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.h b/source/blender/draw/engines/strokegen/strokegen_engine.h
new file mode 100644
index 00000000000..0df3623e738
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_engine.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2016 Blender Foundation. */
+
+/** \file
+ * \ingroup draw_engine
+ */
+
+#pragma once
+
+#include "DRW_render.h"
+#include "RE_engine.h"
+
+#ifdef __cplusplus
+extern "C" { // to satisfy .cc files
+#endif
+
+extern DrawEngineType draw_engine_strokegen_type;
+extern RenderEngineType DRW_engine_viewport_strokegen_type;
+
+// Also I spent some time reading the mesh extraction code,
+// feel like I could add one or more new mesh buffers & extractors?
+// In that way,
+// 1) Never need to touch the DNA data;
+// 2) DrawManager updates these buffers when populates caches for the DrawEngine;
+// 3) DrawEngine uses a eevee-next-style sync module, in its function "sync_mesh":
+// -- 3.1) duplicate a ref from the cache, and
+// -- 3.2) issue ordered compute dispatches & indirect procedural draws;
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/strokegen/strokegen_instance.cc
new file mode 100644
index 00000000000..377dd9a11ef
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.cc
@@ -0,0 +1,29 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup strokegen
+ *
+ * An instance contains all structures needed to do a complete render.
+ */
+
+#include <sstream>
+
+#include "BKE_global.h"
+#include "BKE_object.h"
+#include "BLI_rect.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_ID.h"
+#include "DNA_lightprobe_types.h"
+#include "DNA_modifier_types.h"
+#include "RE_pipeline.h"
+
+#include "strokegen_instance.hh"
+
+namespace blender::strokegen
+{
+
+  
+
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
new file mode 100644
index 00000000000..6944f5baa7e
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
@@ -0,0 +1,75 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup strokegen
+ *
+ * An renderer instance that contains all data to render a full frame.
+*/
+
+#pragma once
+
+#include "BKE_image.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_shader_fx_types.h"
+#include "DRW_engine.h"
+#include "DRW_render.h"
+#include "ED_view3d.h"
+#include "GPU_capabilities.h"
+#include "IMB_imbuf_types.h"
+
+#include "draw_manager.hh"
+#include "draw_pass.hh"
+#include "strokegen_shader.hh"
+
+
+namespace blender::strokegen
+{
+  using namespace draw;
+
+  class Instance
+  {
+  private:
+
+
+  public:
+    Instance() : shaders(*ShaderModule::module_get())
+    {
+    };
+
+    void init(Depsgraph* depsgraph, View3D* v3d)
+    {
+      /* Init things static per render frame. (Not render graph related) */
+    }
+
+    void begin_sync(Manager& /* manager */)
+    {
+      /* Init draw passes and manager related stuff. (Begin render graph) */
+    }
+
+    void object_sync(Manager& manager, ObjectRef& object_ref)
+    {
+      /* Add object draw calls to passes. (Populate render graph) */
+    }
+
+    void end_sync(Manager& /* manager */)
+    {
+      /* Post processing after all object. (End render graph) */
+    }
+
+    void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+                       GPUTexture* color_tx)
+    {
+      /* Submit passes here. (Execute render graph) */
+    }
+
+
+
+    ShaderModule shaders; // singleton class for handling GPUShader(s)
+
+
+  };
+}
+
+
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.cc b/source/blender/draw/engines/strokegen/strokegen_shader.cc
new file mode 100644
index 00000000000..efe37087ef0
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_shader.cc
@@ -0,0 +1,119 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Shader module that manage shader libraries, deferred compilation,
+ * and static shader usage.
+ */
+
+#include "GPU_capabilities.h"
+
+#include "gpu_shader_create_info.hh"
+
+#include "strokegen_shader.hh"
+
+namespace blender::strokegen {
+
+/* -------------------------------------------------------------------- */
+/** \name Module
+ *
+ * \{ */
+
+ShaderModule *ShaderModule::g_shader_module = nullptr;
+
+ShaderModule *ShaderModule::module_get()
+{
+  if (g_shader_module == nullptr) {
+    /* TODO(@fclem) thread-safety. */
+    g_shader_module = new ShaderModule();
+  }
+  return g_shader_module;
+}
+
+void ShaderModule::module_free()
+{
+  if (g_shader_module != nullptr) {
+    /* TODO(@fclem) thread-safety. */
+    delete g_shader_module;
+    g_shader_module = nullptr;
+  }
+}
+
+ShaderModule::ShaderModule()
+{
+  for (GPUShader *&shader : shaders_) {
+    shader = nullptr;
+  }
+
+#ifdef DEBUG
+  /* Ensure all shader are described. */
+  for (auto i : IndexRange(MAX_SHADER_TYPE)) {
+    const char *name = static_shader_create_info_name_get(eShaderType(i));
+    if (name == nullptr) {
+      std::cerr << "STROKEGEN: Missing case for eShaderType(" << i
+                << ") in static_shader_create_info_name_get().";
+      BLI_assert(0);
+    }
+    const GPUShaderCreateInfo *create_info = GPU_shader_create_info_get(name);
+    BLI_assert_msg(create_info != nullptr, "STROKEGEN: Missing create info for static shader.");
+  }
+#endif
+}
+
+ShaderModule::~ShaderModule()
+{
+  for (GPUShader *&shader : shaders_) {
+    DRW_SHADER_FREE_SAFE(shader);
+  }
+}
+
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Static shaders
+ *
+ * \{ */
+
+const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_type)
+{
+  switch (shader_type) {
+    case DEPTH:
+      return "basic_depth_mesh";
+    case POINTCLOUD_DEPTH:
+      return "basic_depth_pointcloud";
+    case CURVES_DEPTH:
+      return "basic_depth_curves";
+    case DEPTH_CONSERVATIVE:
+      return "basic_depth_mesh_conservative";
+    case POINTCLOUD_DEPTH_CONSERVATIVE:
+      return "basic_depth_pointcloud_conservative";
+
+    /* To avoid compiler warning about missing case. */
+    case MAX_SHADER_TYPE:
+      return "";
+  }
+  return "";
+}
+
+GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
+{
+  if (shaders_[shader_type] == nullptr) {
+    const char *shader_name = static_shader_create_info_name_get(shader_type);
+
+    shaders_[shader_type] = GPU_shader_create_from_info_name(shader_name);
+
+    if (shaders_[shader_type] == nullptr) {
+      fprintf(stderr, "STROKEGEN: error: Could not compile static shader \"%s\"\n", shader_name);
+    }
+    BLI_assert(shaders_[shader_type] != nullptr);
+  }
+  return shaders_[shader_type];
+}
+
+
+/** \} */
+
+}  // namespace blender::strokegen
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.hh b/source/blender/draw/engines/strokegen/strokegen_shader.hh
new file mode 100644
index 00000000000..92f8e90a4fe
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_shader.hh
@@ -0,0 +1,62 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup strokegen
+ *
+ * Shader module that manage shader libraries, deferred compilation,
+ * and static shader usage.
+ */
+
+#pragma once
+
+#include <array>
+#include <string>
+
+#include "BLI_string_ref.hh"
+#include "DRW_render.h"
+#include "GPU_material.h"
+#include "GPU_shader.h"
+
+
+namespace blender::strokegen {
+
+/* Keep alphabetical order and clean prefix. */
+enum eShaderType {
+  DEPTH = 0,
+  POINTCLOUD_DEPTH,
+  CURVES_DEPTH,
+  DEPTH_CONSERVATIVE,
+  POINTCLOUD_DEPTH_CONSERVATIVE,
+
+  MAX_SHADER_TYPE,
+};
+
+/**
+ * Shader module. shared between instances.
+ */
+class ShaderModule {
+ private:
+  std::array<GPUShader *, MAX_SHADER_TYPE> shaders_;
+
+  /** Shared shader module across all engine instances. */
+  static ShaderModule *g_shader_module;
+
+ public:
+  ShaderModule();
+  ~ShaderModule();
+
+  GPUShader *static_shader_get(eShaderType shader_type);
+  // TODO: GPUMaterial ? (see impl in eevee)
+
+
+  /** Only to be used by Instance constructor. */
+  static ShaderModule *module_get();
+  static void module_free();
+
+ private:
+  const char *static_shader_create_info_name_get(eShaderType shader_type);
+};
+
+}  // namespace blender::strokegen
diff --git a/source/blender/draw/intern/draw_manager.c b/source/blender/draw/intern/draw_manager.c
index 9e939fb490f..d10488abc22 100644
--- a/source/blender/draw/intern/draw_manager.c
+++ b/source/blender/draw/intern/draw_manager.c
@@ -96,6 +96,7 @@
 #include "engines/overlay/overlay_engine.h"
 #include "engines/select/select_engine.h"
 #include "engines/workbench/workbench_engine.h"
+#include "engines/strokegen/strokegen_engine.h"
 
 #include "GPU_context.h"
 
@@ -3000,6 +3001,7 @@ void DRW_engines_register(void)
 {
   RE_engines_register(&DRW_engine_viewport_eevee_type);
   RE_engines_register(&DRW_engine_viewport_workbench_type);
+  RE_engines_register(&DRW_engine_viewport_strokegen_type);
 
   DRW_engine_register(&draw_engine_gpencil_type);
 
@@ -3014,6 +3016,8 @@ void DRW_engines_register(void)
   DRW_engine_register(&draw_engine_image_type);
   DRW_engine_register(DRW_engine_viewport_external_type.draw_engine);
 
+  DRW_engine_register(&draw_engine_strokegen_type);
+
   /* setup callbacks */
   {
     BKE_curve_batch_cache_dirty_tag_cb = DRW_curve_batch_cache_dirty_tag;
-- 
2.38.1.windows.1


From 7b90c17f692386326aefcb707583c09e773532c9 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 3 Dec 2022 18:11:57 +0800
Subject: [PATCH 02/13] Basic data members

Decl & Init for basic data members of strokegen::Instance.
---
 .../engines/strokegen/strokegen_engine.cc     | 24 ++++-
 .../engines/strokegen/strokegen_instance.cc   | 89 ++++++++++++++++++-
 .../engines/strokegen/strokegen_instance.hh   | 57 +++++++-----
 3 files changed, 146 insertions(+), 24 deletions(-)

diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/strokegen/strokegen_engine.cc
index b4267ce42f5..56b3b170660 100644
--- a/source/blender/draw/engines/strokegen/strokegen_engine.cc
+++ b/source/blender/draw/engines/strokegen/strokegen_engine.cc
@@ -85,8 +85,26 @@ static void strokegen_engine_init(void *vedata)
     ved->instance = new strokegen::Instance();
   }
 
+  draw::Manager *drw_mgr = DRW_manager_get();
+
   const DRWContextState *ctx_state = DRW_context_state_get();
-  ved->instance->init(ctx_state->depsgraph, ctx_state->v3d);
+  View3D *v3d = ctx_state->v3d;
+  RegionView3D *rv3d = ctx_state->rv3d;
+
+  Object *camera = nullptr;
+  if (v3d && rv3d && rv3d->persp == RV3D_CAMOB)
+    camera = v3d->camera;
+
+  const DRWView* default_drw_view = DRW_view_default_get();
+
+
+  ved->instance->init(
+    ctx_state->depsgraph,
+    drw_mgr,
+    ctx_state->v3d, rv3d,
+    default_drw_view,
+    camera
+  );
 }
 
 
@@ -119,7 +137,11 @@ static void strokegen_draw_scene(void *vedata)
   const DRWView *default_view = DRW_view_default_get();
   draw::Manager *manager = DRW_manager_get();
   draw::View view("DefaultView", default_view);
+  // draw passes
   ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
+  // display error msg at the top of the render viewport
+  STRNCPY(ved->info, ved->instance->info.c_str());
+
 
 
   strokegen_draw_scene_legacy(vedata);
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/strokegen/strokegen_instance.cc
index 377dd9a11ef..74037bf3b76 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.cc
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.cc
@@ -23,7 +23,94 @@
 
 namespace blender::strokegen
 {
+  /* -------------------------------------------------------------------- */
+  /** \name Initialization
+   *
+   * Initialization functions need to be called once at the start of a frame.
+   * Active camera, render extent and enabled render passes are immutable until next init.
+   * This takes care of resizing output buffers and view in case a parameter changed.
+   * IMPORTANT: xxx.init() functions are NOT meant to acquire and allocate DRW resources.
+   * Any attempt to do so will likely produce use after free situations.
+   * \{ */
+  void Instance::init(
+    Depsgraph* depsgraph_,
+    Manager* manager_,
+    const View3D* v3d_,
+    const RegionView3D* rv3d_,
+    const DRWView* drw_view_,
+    Object* camera_object_)
+  {
+    /* Init things static per render frame. (Not render graph related) */
+    depsgraph = depsgraph_;
+    manager = manager_;
+
+    drw_view = drw_view_;
+    v3d = v3d_;
+    rv3d = rv3d_;
+
+    camera_orig_object = camera_object_;
+
+    info = "";
+  }
+
+  void Instance::update_eval_members()
+  {
+    scene = DEG_get_evaluated_scene(depsgraph);
+    camera_eval_object = (camera_orig_object) ?
+                         DEG_get_evaluated_object(depsgraph, camera_orig_object) :
+                         nullptr;
+  }
+
+  /** \} */
+
+
+
+
+
+
+  /* -------------------------------------------------------------------- */
+  /** \name Sync
+   *
+   * Sync will gather data from the scene that can change over a time step (i.e: motion steps).
+   * IMPORTANT: xxx.sync() functions area responsible for creating DRW resources (i.e: DRWView) as
+   * well as querying temp texture pool. All DRWPasses should be ready by the end end_sync().
+   * \{ */
+  void Instance::begin_sync(Manager& manager)
+  {
+    /* Init draw passes and manager related stuff. (Begin render graph) */
+  }
+
+  void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
+  {
+    /* Add object draw calls to passes. (Populate render graph) */
+  }
+
+  void Instance::end_sync(Manager&)
+  {
+    /* Post processing after all object. (End render graph) */
+  }
+
+  /** \} */
+
+
+
+
+
+
+  /* -------------------------------------------------------------------- */
+  /** \name Rendering
+   * \{ */
+
+  void Instance::draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+    GPUTexture* color_tx)
+  {
+    /* Submit passes here. (Execute render graph) */
+  }
+
+  /** \} */
+
+
+
 
-  
 
 }
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
index 6944f5baa7e..ac1332c5838 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
@@ -32,42 +32,55 @@ namespace blender::strokegen
   {
   private:
 
+  public:
+    /** Shading Modules */
+    ShaderModule shaders; // singleton class for handling GPUShader(s)
+
+
+    /** Input data. */
+    Depsgraph *depsgraph;
+    Manager *manager;
+
+    /** Evaluated IDs. */
+    Scene *scene;
+    Object *camera_eval_object;
+    Object *camera_orig_object;
+    /** Only available when rendering for viewport. */
+    const DRWView *drw_view;
+    const View3D *v3d;
+    const RegionView3D *rv3d;
+
+
+
+
+
+    /** Info string displayed at the top of the render / viewport. */
+    std::string info = "";
+    /** Debug mode from debug value. */
+    // eDebugMode debug_mode = eDebugMode::DEBUG_NONE;
+
+
 
   public:
     Instance() : shaders(*ShaderModule::module_get())
     {
     };
 
-    void init(Depsgraph* depsgraph, View3D* v3d)
-    {
-      /* Init things static per render frame. (Not render graph related) */
-    }
+    void init(Depsgraph* depsgraph_, draw::Manager* manager_, const View3D* v3d_, const RegionView3D* rv3d_, const
+              DRWView* drw_view_, Object* camera_object_);
+    void update_eval_members();
 
-    void begin_sync(Manager& /* manager */)
-    {
-      /* Init draw passes and manager related stuff. (Begin render graph) */
-    }
+    void begin_sync(Manager& manager);
 
-    void object_sync(Manager& manager, ObjectRef& object_ref)
-    {
-      /* Add object draw calls to passes. (Populate render graph) */
-    }
+    void object_sync(Manager& manager, ObjectRef& object_ref);
 
-    void end_sync(Manager& /* manager */)
-    {
-      /* Post processing after all object. (End render graph) */
-    }
+    void end_sync(Manager& /* manager */);
 
     void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
-                       GPUTexture* color_tx)
-    {
-      /* Submit passes here. (Execute render graph) */
-    }
+                       GPUTexture* color_tx);
 
 
 
-    ShaderModule shaders; // singleton class for handling GPUShader(s)
-
 
   };
 }
-- 
2.38.1.windows.1


From 15803b42819ff5659c6a9b79ce6e05c7c0d4f386 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 3 Dec 2022 19:08:34 +0800
Subject: [PATCH 03/13] Basic setup for strokegen_sync

Basic calls for sync module, all empty func for now.
Also structs for reference object/resources in scene, copied from eevee_sync.hh
---
 source/blender/draw/CMakeLists.txt            |   5 +
 .../engines/strokegen/strokegen_defines.hh    |  10 +
 .../engines/strokegen/strokegen_instance.hh   |   7 +-
 .../strokegen/strokegen_shader_shared.hh      |   7 +
 .../draw/engines/strokegen/strokegen_sync.cc  |  29 +++
 .../draw/engines/strokegen/strokegen_sync.hh  |  49 +++++
 .../strokegen/strokegen_sync_handles.hh       | 171 ++++++++++++++++++
 7 files changed, 276 insertions(+), 2 deletions(-)
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_defines.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync_handles.hh

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 76bdd97ae20..33243161d91 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -211,6 +211,9 @@ set(SRC
   engines/strokegen/strokegen_engine.cc
   engines/strokegen/strokegen_shader.cc
   engines/strokegen/strokegen_instance.cc
+  engines/strokegen/strokegen_sync.cc
+
+
 
 
 
@@ -305,6 +308,8 @@ set(SRC
   engines/strokegen/strokegen_engine.h
   engines/strokegen/strokegen_shader.hh
   engines/strokegen/strokegen_instance.hh
+  engines/strokegen/strokegen_sync_handles.hh
+  engines/strokegen/strokegen_sync.hh
 )
 
 set(LIB
diff --git a/source/blender/draw/engines/strokegen/strokegen_defines.hh b/source/blender/draw/engines/strokegen/strokegen_defines.hh
new file mode 100644
index 00000000000..a1900395cc8
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_defines.hh
@@ -0,0 +1,10 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * List of defines that are shared with the GPUShaderCreateInfos. We do this to avoid
+ * dragging larger headers into the createInfo pipeline which would cause problems.
+ */
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
index ac1332c5838..6567f88cfaa 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
@@ -22,6 +22,7 @@
 #include "draw_manager.hh"
 #include "draw_pass.hh"
 #include "strokegen_shader.hh"
+#include "strokegen_sync.hh"
 
 
 namespace blender::strokegen
@@ -35,7 +36,7 @@ namespace blender::strokegen
   public:
     /** Shading Modules */
     ShaderModule shaders; // singleton class for handling GPUShader(s)
-
+    SyncModule sync;
 
     /** Input data. */
     Depsgraph *depsgraph;
@@ -62,7 +63,9 @@ namespace blender::strokegen
 
 
   public:
-    Instance() : shaders(*ShaderModule::module_get())
+    Instance() :
+    shaders(*ShaderModule::module_get()),
+    sync(*this)
     {
     };
 
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh b/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
new file mode 100644
index 00000000000..ca4e6ad46d7
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
@@ -0,0 +1,7 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/**
+ * Shared structures, enums & defines between C++ and GLSL.
+ * Can also include some math functions but they need to be simple enough to be valid in both
+ * language.
+ */
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.cc b/source/blender/draw/engines/strokegen/strokegen_sync.cc
new file mode 100644
index 00000000000..2eda953508b
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_sync.cc
@@ -0,0 +1,29 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Converts the different renderable object types to drawcalls.
+ */
+
+#include "strokegen_engine.h"
+
+#include "BKE_gpencil.h"
+#include "BKE_object.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_curves_types.h"
+#include "DNA_gpencil_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_particle_types.h"
+
+#include "strokegen_instance.hh"
+#include "strokegen_sync.hh"
+
+namespace blender::strokegen
+{
+
+
+
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.hh b/source/blender/draw/engines/strokegen/strokegen_sync.hh
new file mode 100644
index 00000000000..ff979e63d6e
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_sync.hh
@@ -0,0 +1,49 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Module for synchronization between draw engine and outside
+ */
+
+#pragma once
+
+#include "BKE_duplilist.h"
+#include "BLI_ghash.h"
+#include "BLI_map.hh"
+#include "DNA_object_types.h"
+#include "DRW_render.h"
+#include "GPU_material.h"
+
+#include "strokegen_shader_shared.hh"
+#include "strokegen_sync_handles.hh"
+
+namespace blender::strokegen
+{
+
+  class Instance;
+
+  class SyncModule
+  {
+  private:
+    Instance &inst_;
+
+  public:
+    SyncModule(Instance &inst) : inst_(inst) {};
+    ~SyncModule(){};
+
+    ObjectHandle &sync_object(Object *ob) {};
+    WorldHandle &sync_world(::World *world) {};
+    SceneHandle &sync_scene(::Scene *scene) {};
+
+    void sync_mesh(Object *ob,
+                   ObjectHandle &ob_handle,
+                   draw::ResourceHandle res_handle,
+                   const draw::ObjectRef &ob_ref) {};
+  };
+
+}
+
+
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh b/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
new file mode 100644
index 00000000000..2e0354a856d
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
@@ -0,0 +1,171 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Structures to identify unique data blocks.
+ * The keys are unique so we are able to match ids across frame updates.
+ */
+
+#pragma once
+
+
+// Copied from eevee_sync.hh
+
+namespace blender::strokegen
+{
+  /* -------------------------------------------------------------------- */
+  /** \name ObjectKey
+   *
+   * Unique key to identify each object in the hash-map.
+   * Note that we get a unique key for each object component.
+   * \{ */
+
+  struct ObjectKey
+  {
+    /** Hash value of the key. */
+    uint64_t hash_value;
+    /** Original Object or source object for duplis. */
+    Object* ob;
+    /** Original Parent object for duplis. */
+    Object* parent;
+    /** Dupli objects recursive unique identifier */
+    int id[MAX_DUPLI_RECUR];
+    /** If object uses particle system hair. */
+    bool use_particle_hair;
+#ifdef DEBUG
+    char name[64];
+#endif
+    ObjectKey() : ob(nullptr), parent(nullptr)
+    {
+    };
+
+    ObjectKey(Object* ob_, Object* parent_, int id_[MAX_DUPLI_RECUR], bool use_particle_hair_)
+      : ob(ob_), parent(parent_), use_particle_hair(use_particle_hair_)
+    {
+      if (id_)
+      {
+        memcpy(id, id_, sizeof(id));
+      }
+      else
+      {
+        memset(id, 0, sizeof(id));
+      }
+      /* Compute hash on creation so we avoid the cost of it for every sync. */
+      hash_value = BLI_ghashutil_ptrhash(ob);
+      hash_value = BLI_ghashutil_combine_hash(hash_value, BLI_ghashutil_ptrhash(parent));
+      for (int i = 0; i < MAX_DUPLI_RECUR; i++)
+      {
+        if (id[i] != 0)
+        {
+          hash_value = BLI_ghashutil_combine_hash(hash_value, BLI_ghashutil_inthash(id[i]));
+        }
+        else
+        {
+          break;
+        }
+      }
+#ifdef DEBUG
+      STRNCPY(name, ob->id.name);
+#endif
+    }
+
+    ObjectKey(Object* ob, DupliObject* dupli, Object* parent)
+      : ObjectKey(ob, parent, dupli ? dupli->persistent_id : nullptr, false)
+    {
+    };
+
+    ObjectKey(Object* ob)
+      : ObjectKey(ob, DRW_object_get_dupli(ob), DRW_object_get_dupli_parent(ob))
+    {
+    };
+
+    uint64_t hash() const
+    {
+      return hash_value;
+    }
+
+    bool operator<(const ObjectKey& k) const
+    {
+      if (ob != k.ob)
+      {
+        return (ob < k.ob);
+      }
+      if (parent != k.parent)
+      {
+        return (parent < k.parent);
+      }
+      if (use_particle_hair != k.use_particle_hair)
+      {
+        return (use_particle_hair < k.use_particle_hair);
+      }
+      return memcmp(id, k.id, sizeof(id)) < 0;
+    }
+
+    bool operator==(const ObjectKey& k) const
+    {
+      if (ob != k.ob)
+      {
+        return false;
+      }
+      if (parent != k.parent)
+      {
+        return false;
+      }
+      if (use_particle_hair != k.use_particle_hair)
+      {
+        return false;
+      }
+      return memcmp(id, k.id, sizeof(id)) == 0;
+    }
+  };
+
+  /** \} */
+
+  /* -------------------------------------------------------------------- */
+  /** \name Sync Module
+   *
+   * \{ */
+
+  struct ObjectHandle : public DrawData
+  {
+    ObjectKey object_key;
+
+    void reset_recalc_flag()
+    {
+      if (recalc != 0)
+      {
+        recalc = 0;
+      }
+    }
+  };
+
+  struct WorldHandle : public DrawData
+  {
+    void reset_recalc_flag()
+    {
+      if (recalc != 0)
+      {
+        recalc = 0;
+      }
+    }
+  };
+
+  struct SceneHandle : public DrawData
+  {
+    void reset_recalc_flag()
+    {
+      if (recalc != 0)
+      {
+        recalc = 0;
+      }
+    }
+  };
+
+
+
+}
+
+/** \} */
-- 
2.38.1.windows.1


From b9653cd9fc75bc4d5eac95fdb1a4f9b142616c14 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 4 Dec 2022 21:08:13 +0800
Subject: [PATCH 04/13] Change engine name from strokegen to bnpr

---
 source/blender/draw/CMakeLists.txt            |  25 ++-
 .../bnpr_engine.cc}                           | 168 +++++++++---------
 .../strokegen_engine.h => bnpr/bnpr_engine.h} |   4 +-
 .../bnpr_instance.cc}                         |   6 +-
 .../bnpr_instance.hh}                         |   8 +-
 .../bnpr_shader.cc}                           |  12 +-
 .../bnpr_shader.hh}                           |   6 +-
 source/blender/draw/engines/bnpr/bnpr_sync.cc |  45 +++++
 .../strokegen_sync.hh => bnpr/bnpr_sync.hh}   |   6 +-
 .../bnpr_sync_handles.hh}                     |   2 +-
 .../shaders/infos/strokegen_depth_info.hh     |   0
 .../shaders/strokegen_depth_curves_vert.glsl  |   0
 .../shaders/strokegen_depth_frag.glsl         |   0
 .../strokegen_depth_pointcloud_vert.glsl      |   0
 .../shaders/strokegen_depth_vert.glsl         |   0
 .../strokgen_conservative_depth_geom.glsl     |   0
 .../{strokegen => bnpr}/strokegen_defines.hh  |   0
 .../strokegen_shader_shared.hh                |   0
 .../draw/engines/strokegen/strokegen_sync.cc  |  29 ---
 source/blender/draw/intern/draw_manager.c     |   6 +-
 20 files changed, 170 insertions(+), 147 deletions(-)
 rename source/blender/draw/engines/{strokegen/strokegen_engine.cc => bnpr/bnpr_engine.cc} (68%)
 rename source/blender/draw/engines/{strokegen/strokegen_engine.h => bnpr/bnpr_engine.h} (87%)
 rename source/blender/draw/engines/{strokegen/strokegen_instance.cc => bnpr/bnpr_instance.cc} (97%)
 rename source/blender/draw/engines/{strokegen/strokegen_instance.hh => bnpr/bnpr_instance.hh} (94%)
 rename source/blender/draw/engines/{strokegen/strokegen_shader.cc => bnpr/bnpr_shader.cc} (87%)
 rename source/blender/draw/engines/{strokegen/strokegen_shader.hh => bnpr/bnpr_shader.hh} (92%)
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_sync.cc
 rename source/blender/draw/engines/{strokegen/strokegen_sync.hh => bnpr/bnpr_sync.hh} (89%)
 rename source/blender/draw/engines/{strokegen/strokegen_sync_handles.hh => bnpr/bnpr_sync_handles.hh} (99%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/infos/strokegen_depth_info.hh (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_curves_vert.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_frag.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_pointcloud_vert.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_vert.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokgen_conservative_depth_geom.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/strokegen_defines.hh (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/strokegen_shader_shared.hh (100%)
 delete mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.cc

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 33243161d91..90579052df5 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -208,10 +208,10 @@ set(SRC
   engines/overlay/overlay_viewer_attribute.cc
   engines/overlay/overlay_volume.cc
   engines/overlay/overlay_wireframe.cc
-  engines/strokegen/strokegen_engine.cc
-  engines/strokegen/strokegen_shader.cc
-  engines/strokegen/strokegen_instance.cc
-  engines/strokegen/strokegen_sync.cc
+  engines/bnpr/bnpr_engine.cc
+  engines/bnpr/bnpr_shader.cc
+  engines/bnpr/bnpr_instance.cc
+  engines/bnpr/bnpr_sync.cc
 
 
 
@@ -305,11 +305,11 @@ set(SRC
   engines/select/select_private.h
   engines/overlay/overlay_engine.h
   engines/overlay/overlay_private.hh
-  engines/strokegen/strokegen_engine.h
-  engines/strokegen/strokegen_shader.hh
-  engines/strokegen/strokegen_instance.hh
-  engines/strokegen/strokegen_sync_handles.hh
-  engines/strokegen/strokegen_sync.hh
+  engines/bnpr/bnpr_engine.h
+  engines/bnpr/bnpr_shader.hh
+  engines/bnpr/bnpr_instance.hh
+  engines/bnpr/bnpr_sync_handles.hh
+  engines/bnpr/bnpr_sync.hh
 )
 
 set(LIB
@@ -699,6 +699,13 @@ set(GLSL_SRC
   engines/image/shaders/image_engine_color_vert.glsl
   engines/image/shaders/image_engine_depth_frag.glsl
   engines/image/shaders/image_engine_depth_vert.glsl
+
+
+
+
+
+
+
 )
 
 set(GLSL_C)
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/bnpr/bnpr_engine.cc
similarity index 68%
rename from source/blender/draw/engines/strokegen/strokegen_engine.cc
rename to source/blender/draw/engines/bnpr/bnpr_engine.cc
index 56b3b170660..0e123f6e50c 100644
--- a/source/blender/draw/engines/strokegen/strokegen_engine.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_engine.cc
@@ -17,72 +17,72 @@
 
 #include "GPU_shader.h"
 
-#include "strokegen_engine.h"
+#include "bnpr_engine.h"
 
-#include "strokegen_instance.hh"
-#include "strokegen_shader.hh"
+#include "bnpr_instance.hh"
+#include "bnpr_shader.hh"
 
 
 using namespace blender;
 
 
 
-#define STROKEGEN_ENGINE "BLENDER_STROKEGEN"
+#define bnpr_ENGINE "BLENDER_bnpr"
 
 /* *********** LISTS *********** */
 
 /* GPUViewport.storage
  * Is freed every time the viewport engine changes. */
-typedef struct STROKEGEN_StorageList {
-  struct STROKEGEN_PrivateData *g_data;
-} STROKEGEN_StorageList;
+typedef struct bnpr_StorageList {
+  struct bnpr_PrivateData *g_data;
+} bnpr_StorageList;
 
-typedef struct STROKEGEN_PassList {
+typedef struct bnpr_PassList {
   struct DRWPass *depth_pass[2];
   struct DRWPass *depth_pass_pointcloud[2];
   struct DRWPass *depth_pass_cull[2];
-} STROKEGEN_PassList;
+} bnpr_PassList;
 
 // Per-engine data
 // Sent by draw manager to the draw-engine.
-typedef struct STROKEGEN_Data {
+typedef struct bnpr_Data {
   void *engine_type;
   DRWViewportEmptyList *fbl;
   DRWViewportEmptyList *txl;
-  STROKEGEN_PassList *psl;
-  STROKEGEN_StorageList *stl;
+  bnpr_PassList *psl;
+  bnpr_StorageList *stl;
 
-  strokegen::Instance *instance;
+  bnpr::Instance *instance;
   char info[GPU_INFO_SIZE];
 
-} STROKEGEN_Data;
+} bnpr_Data;
 
 /* *********** STATIC *********** */
 
-typedef struct STROKEGEN_PrivateData {
+typedef struct bnpr_PrivateData {
   DRWShadingGroup *depth_shgrp[2];
   DRWShadingGroup *depth_shgrp_cull[2];
   DRWShadingGroup *depth_hair_shgrp[2];
   DRWShadingGroup *depth_curves_shgrp[2];
   DRWShadingGroup *depth_pointcloud_shgrp[2];
   bool use_material_slot_selection;
-} STROKEGEN_PrivateData; /* Transient data */
+} bnpr_PrivateData; /* Transient data */
 
 
 
-static bool check_strokegen_support()
+static bool check_bnpr_support()
 {
   return GPU_shader_storage_buffer_objects_support();
 }
 
 
-static void strokegen_engine_init(void *vedata)
+static void bnpr_engine_init(void *vedata)
 {
-  if (!check_strokegen_support()) { return; }
+  if (!check_bnpr_support()) { return; }
 
-  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  bnpr_Data *ved = reinterpret_cast<bnpr_Data *>(vedata);
   if (ved->instance == nullptr) {
-    ved->instance = new strokegen::Instance();
+    ved->instance = new bnpr::Instance();
   }
 
   draw::Manager *drw_mgr = DRW_manager_get();
@@ -109,9 +109,9 @@ static void strokegen_engine_init(void *vedata)
 
 
 
-static void strokegen_draw_scene_legacy(void *vedata)
+static void bnpr_draw_scene_legacy(void *vedata)
 {
-  STROKEGEN_PassList *psl = ((STROKEGEN_Data *)vedata)->psl;
+  bnpr_PassList *psl = ((bnpr_Data *)vedata)->psl;
 
   DRW_draw_pass(psl->depth_pass[0]);
   DRW_draw_pass(psl->depth_pass_pointcloud[0]);
@@ -121,11 +121,11 @@ static void strokegen_draw_scene_legacy(void *vedata)
   DRW_draw_pass(psl->depth_pass_cull[1]);
 }
 
-static void strokegen_draw_scene(void *vedata)
+static void bnpr_draw_scene(void *vedata)
 {
-  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
-  if (!check_strokegen_support()) {
-    STRNCPY(ved->info, "Error: No shader storage buffer support, required by StrokeGen.");
+  bnpr_Data *ved = reinterpret_cast<bnpr_Data *>(vedata);
+  if (!check_bnpr_support()) {
+    STRNCPY(ved->info, "Error: No shader storage buffer support, required by bnpr.");
     return;
   }
 
@@ -144,7 +144,7 @@ static void strokegen_draw_scene(void *vedata)
 
 
 
-  strokegen_draw_scene_legacy(vedata);
+  bnpr_draw_scene_legacy(vedata);
 
 
   /* Reset view for other following engines. */
@@ -154,17 +154,17 @@ static void strokegen_draw_scene(void *vedata)
 
 
 
-static void strokegen_cache_init_legacy(void *vedata)
+static void bnpr_cache_init_legacy(void *vedata)
 {
-  STROKEGEN_PassList *psl = static_cast<STROKEGEN_Data*>(vedata)->psl;
-  STROKEGEN_StorageList *stl = static_cast<STROKEGEN_Data*>(vedata)->stl;
+  bnpr_PassList *psl = static_cast<bnpr_Data*>(vedata)->psl;
+  bnpr_StorageList *stl = static_cast<bnpr_Data*>(vedata)->stl;
   DRWShadingGroup *grp;
 
   const DRWContextState *draw_ctx = DRW_context_state_get();
 
   if (!stl->g_data) {
     /* Alloc transient pointers */
-    stl->g_data = (STROKEGEN_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
+    stl->g_data = (bnpr_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
   }
 
   stl->g_data->use_material_slot_selection = DRW_state_is_material_select();
@@ -179,50 +179,50 @@ static void strokegen_cache_init_legacy(void *vedata)
     );
     DRWState state = DRW_STATE_WRITE_DEPTH | DRW_STATE_DEPTH_LESS_EQUAL;
 
-    blender::strokegen::ShaderModule* shaderModule =
-      blender::strokegen::ShaderModule::module_get();
+    blender::bnpr::ShaderModule* shaderModule =
+      blender::bnpr::ShaderModule::module_get();
 
     GPUShader *sh = DRW_state_is_select() ?
-                        shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
-                        shaderModule->static_shader_get(blender::strokegen::DEPTH);
+                        shaderModule->static_shader_get(blender::bnpr::DEPTH_CONSERVATIVE) :
+                        shaderModule->static_shader_get(blender::bnpr::DEPTH);
 
     DRW_PASS_CREATE(psl->depth_pass[i], state | clip_state | infront_state);
     stl->g_data->depth_shgrp[i] = grp = DRW_shgroup_create(sh, psl->depth_pass[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
     sh = DRW_state_is_select() ?
-        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH_CONSERVATIVE) :
-        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH);
+        shaderModule->static_shader_get(blender::bnpr::POINTCLOUD_DEPTH_CONSERVATIVE) :
+        shaderModule->static_shader_get(blender::bnpr::POINTCLOUD_DEPTH);
     DRW_PASS_CREATE(psl->depth_pass_pointcloud[i], state | clip_state | infront_state);
     stl->g_data->depth_pointcloud_shgrp[i] = grp = DRW_shgroup_create(
         sh, psl->depth_pass_pointcloud[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
     stl->g_data->depth_hair_shgrp[i] = grp = DRW_shgroup_create(
-        shaderModule->static_shader_get(blender::strokegen::DEPTH), psl->depth_pass[i]);
+        shaderModule->static_shader_get(blender::bnpr::DEPTH), psl->depth_pass[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
     stl->g_data->depth_curves_shgrp[i] = grp = DRW_shgroup_create(
-        shaderModule->static_shader_get(blender::strokegen::CURVES_DEPTH), psl->depth_pass[i]);
+        shaderModule->static_shader_get(blender::bnpr::CURVES_DEPTH), psl->depth_pass[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
-    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
-                                 shaderModule->static_shader_get(blender::strokegen::DEPTH);
+    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::bnpr::DEPTH_CONSERVATIVE) :
+                                 shaderModule->static_shader_get(blender::bnpr::DEPTH);
     state |= DRW_STATE_CULL_BACK;
     DRW_PASS_CREATE(psl->depth_pass_cull[i], state | clip_state | infront_state);
     stl->g_data->depth_shgrp_cull[i] = grp = DRW_shgroup_create(sh, psl->depth_pass_cull[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
   }
 }
-static void strokegen_cache_init(void *vedata)
+static void bnpr_cache_init(void *vedata)
 {
-  if (!check_strokegen_support()) return;
+  if (!check_bnpr_support()) return;
 
   draw::Manager* drwmgr = DRW_manager_get();
-  reinterpret_cast<STROKEGEN_Data *>(vedata)->instance->begin_sync(*drwmgr);
+  reinterpret_cast<bnpr_Data *>(vedata)->instance->begin_sync(*drwmgr);
 
 
-  strokegen_cache_init_legacy(vedata);
+  bnpr_cache_init_legacy(vedata);
 }
 
 
@@ -235,7 +235,7 @@ static void strokegen_cache_init(void *vedata)
 
 /* TODO(fclem): DRW_cache_object_surface_material_get needs a refactor to allow passing NULL
  * instead of gpumat_array. Avoiding all this boilerplate code. */
-static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
+static struct GPUBatch **bnpr_object_surface_material_get(Object *ob)
 {
   const int materials_len = DRW_cache_object_material_count_get(ob);
   struct GPUMaterial **gpumat_array =
@@ -245,14 +245,14 @@ static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
   return DRW_cache_object_surface_material_get(ob, gpumat_array, materials_len);
 }
 
-static void strokegen_cache_populate_particles(void *vedata, Object *ob)
+static void bnpr_cache_populate_particles(void *vedata, Object *ob)
 {
   // do nothing here.
 }
 
-static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+static void bnpr_cache_populate_legacy(void *vedata, Object *ob)
 {
-  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+  bnpr_StorageList *stl = ((bnpr_Data *)vedata)->stl;
 
   /* TODO(fclem): fix selection of smoke domains. */
 
@@ -262,7 +262,7 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
 
   const DRWContextState *draw_ctx = DRW_context_state_get();
   if (ob != draw_ctx->object_edit) {
-    strokegen_cache_populate_particles(vedata, ob);
+    bnpr_cache_populate_particles(vedata, ob);
   }
 
   const bool do_in_front = (ob->dtx & OB_DRAW_IN_FRONT) != 0;
@@ -308,7 +308,7 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
   }
   else {
     if (stl->g_data->use_material_slot_selection && BKE_object_supports_material_slots(ob)) {
-      struct GPUBatch **geoms = strokegen_object_surface_material_get(ob);
+      struct GPUBatch **geoms = bnpr_object_surface_material_get(ob);
       if (geoms) {
         const int materials_len = DRW_cache_object_material_count_get(ob);
         for (int i = 0; i < materials_len; i++) {
@@ -329,11 +329,11 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
     }
   }
 }
-static void strokegen_cache_populate(void *vedata, Object *object)
+static void bnpr_cache_populate(void *vedata, Object *object)
 {
-  if (!check_strokegen_support()) return;
+  if (!check_bnpr_support()) return;
 
-  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  bnpr_Data* ved = reinterpret_cast<bnpr_Data *>(vedata);
 
   draw::Manager* drw_mgr = DRW_manager_get();
   draw::ObjectRef ref {
@@ -346,43 +346,43 @@ static void strokegen_cache_populate(void *vedata, Object *object)
 
 
 
-  strokegen_cache_populate_legacy(vedata, object);
+  bnpr_cache_populate_legacy(vedata, object);
 }
 
 
-static void strokegen_cache_finish_legacy(void *vedata)
+static void bnpr_cache_finish_legacy(void *vedata)
 {
-  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+  bnpr_StorageList *stl = ((bnpr_Data *)vedata)->stl;
 
   UNUSED_VARS(stl);
 }
-static void strokegen_cache_finish(void *vedata)
+static void bnpr_cache_finish(void *vedata)
 {
-  if (!check_strokegen_support()) return;
+  if (!check_bnpr_support()) return;
 
-  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data*>(vedata);
+  bnpr_Data* ved = reinterpret_cast<bnpr_Data*>(vedata);
   draw::Manager* drw_mgr = DRW_manager_get();
 
   ved->instance->end_sync(*drw_mgr);
 
 
 
-  strokegen_cache_finish_legacy(vedata);
+  bnpr_cache_finish_legacy(vedata);
 }
 
-static void strokegen_instance_free(void *instance) {
+static void bnpr_instance_free(void *instance) {
   if (!GPU_shader_storage_buffer_objects_support()) {
     return;
   }
-  delete reinterpret_cast<strokegen::Instance *>(instance);
+  delete reinterpret_cast<bnpr::Instance *>(instance);
 }
 
-static void strokegen_engine_free(void)
+static void bnpr_engine_free(void)
 {
-  strokegen::ShaderModule::module_free();
+  bnpr::ShaderModule::module_free();
 }
 
-static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
+static void bnpr_render_to_image(void *vedata, struct RenderEngine *engine,
                                     struct RenderLayer *layer,
                                     const struct rcti *UNUSED(rect)) {
   UNUSED_VARS(vedata, engine, layer);
@@ -393,31 +393,31 @@ static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
 
 
 
-static const DrawEngineDataSize strokegen_data_size = DRW_VIEWPORT_DATA_SIZE(STROKEGEN_Data);
+static const DrawEngineDataSize bnpr_data_size = DRW_VIEWPORT_DATA_SIZE(bnpr_Data);
 
-DrawEngineType draw_engine_strokegen_type = {
+DrawEngineType draw_engine_bnpr_type = {
     NULL,
     NULL,
-    N_("StrokeGen"),
-    &strokegen_data_size,
-    strokegen_engine_init,
-    &strokegen_engine_free,
-    &strokegen_instance_free,
-    &strokegen_cache_init,
-    &strokegen_cache_populate,
-    &strokegen_cache_finish,
-    &strokegen_draw_scene,
+    N_("bnpr"),
+    &bnpr_data_size,
+    bnpr_engine_init,
+    &bnpr_engine_free,
+    &bnpr_instance_free,
+    &bnpr_cache_init,
+    &bnpr_cache_populate,
+    &bnpr_cache_finish,
+    &bnpr_draw_scene,
     NULL,
     NULL,
-    strokegen_render_to_image,
+    bnpr_render_to_image,
     NULL,
 };
 
-RenderEngineType DRW_engine_viewport_strokegen_type = {
+RenderEngineType DRW_engine_viewport_bnpr_type = {
   nullptr,
   nullptr,
-  "STROKEGEN_VIEW",
-  N_("strokegen"),
+  "bnpr_VIEW",
+  N_("bnpr"),
   RE_INTERNAL | RE_USE_PREVIEW | RE_USE_STEREO_VIEWPORT | RE_USE_GPU_CONTEXT,
   nullptr,
   &DRW_render_to_image,
@@ -428,8 +428,8 @@ RenderEngineType DRW_engine_viewport_strokegen_type = {
   nullptr,
   nullptr,
   nullptr, // TODO: impl this
-  &draw_engine_strokegen_type,
+  &draw_engine_bnpr_type,
   {nullptr, nullptr, nullptr},
 };
 
-#undef STROKEGEN_ENGINE
+#undef bnpr_ENGINE
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.h b/source/blender/draw/engines/bnpr/bnpr_engine.h
similarity index 87%
rename from source/blender/draw/engines/strokegen/strokegen_engine.h
rename to source/blender/draw/engines/bnpr/bnpr_engine.h
index 0df3623e738..842c7d664a5 100644
--- a/source/blender/draw/engines/strokegen/strokegen_engine.h
+++ b/source/blender/draw/engines/bnpr/bnpr_engine.h
@@ -14,8 +14,8 @@
 extern "C" { // to satisfy .cc files
 #endif
 
-extern DrawEngineType draw_engine_strokegen_type;
-extern RenderEngineType DRW_engine_viewport_strokegen_type;
+extern DrawEngineType draw_engine_bnpr_type;
+extern RenderEngineType DRW_engine_viewport_bnpr_type;
 
 // Also I spent some time reading the mesh extraction code,
 // feel like I could add one or more new mesh buffers & extractors?
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
similarity index 97%
rename from source/blender/draw/engines/strokegen/strokegen_instance.cc
rename to source/blender/draw/engines/bnpr/bnpr_instance.cc
index 74037bf3b76..5139b0c5f49 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -3,7 +3,7 @@
  */
 
 /** \file
- * \ingroup strokegen
+ * \ingroup bnpr
  *
  * An instance contains all structures needed to do a complete render.
  */
@@ -19,9 +19,9 @@
 #include "DNA_modifier_types.h"
 #include "RE_pipeline.h"
 
-#include "strokegen_instance.hh"
+#include "bnpr_instance.hh"
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
   /* -------------------------------------------------------------------- */
   /** \name Initialization
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
similarity index 94%
rename from source/blender/draw/engines/strokegen/strokegen_instance.hh
rename to source/blender/draw/engines/bnpr/bnpr_instance.hh
index 6567f88cfaa..5f6a7374b89 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -3,7 +3,7 @@
  */
 
 /** \file
- * \ingroup strokegen
+ * \ingroup bnpr
  *
  * An renderer instance that contains all data to render a full frame.
 */
@@ -21,11 +21,11 @@
 
 #include "draw_manager.hh"
 #include "draw_pass.hh"
-#include "strokegen_shader.hh"
-#include "strokegen_sync.hh"
+#include "bnpr_shader.hh"
+#include "bnpr_sync.hh"
 
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
   using namespace draw;
 
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
similarity index 87%
rename from source/blender/draw/engines/strokegen/strokegen_shader.cc
rename to source/blender/draw/engines/bnpr/bnpr_shader.cc
index efe37087ef0..7bf72caf057 100644
--- a/source/blender/draw/engines/strokegen/strokegen_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -13,9 +13,9 @@
 
 #include "gpu_shader_create_info.hh"
 
-#include "strokegen_shader.hh"
+#include "bnpr_shader.hh"
 
-namespace blender::strokegen {
+namespace blender::bnpr {
 
 /* -------------------------------------------------------------------- */
 /** \name Module
@@ -53,12 +53,12 @@ ShaderModule::ShaderModule()
   for (auto i : IndexRange(MAX_SHADER_TYPE)) {
     const char *name = static_shader_create_info_name_get(eShaderType(i));
     if (name == nullptr) {
-      std::cerr << "STROKEGEN: Missing case for eShaderType(" << i
+      std::cerr << "bnpr: Missing case for eShaderType(" << i
                 << ") in static_shader_create_info_name_get().";
       BLI_assert(0);
     }
     const GPUShaderCreateInfo *create_info = GPU_shader_create_info_get(name);
-    BLI_assert_msg(create_info != nullptr, "STROKEGEN: Missing create info for static shader.");
+    BLI_assert_msg(create_info != nullptr, "bnpr: Missing create info for static shader.");
   }
 #endif
 }
@@ -106,7 +106,7 @@ GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
     shaders_[shader_type] = GPU_shader_create_from_info_name(shader_name);
 
     if (shaders_[shader_type] == nullptr) {
-      fprintf(stderr, "STROKEGEN: error: Could not compile static shader \"%s\"\n", shader_name);
+      fprintf(stderr, "bnpr: error: Could not compile static shader \"%s\"\n", shader_name);
     }
     BLI_assert(shaders_[shader_type] != nullptr);
   }
@@ -116,4 +116,4 @@ GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
 
 /** \} */
 
-}  // namespace blender::strokegen
+}  // namespace blender::bnpr
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
similarity index 92%
rename from source/blender/draw/engines/strokegen/strokegen_shader.hh
rename to source/blender/draw/engines/bnpr/bnpr_shader.hh
index 92f8e90a4fe..9b756e213a4 100644
--- a/source/blender/draw/engines/strokegen/strokegen_shader.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
@@ -3,7 +3,7 @@
  */
 
 /** \file
- * \ingroup strokegen
+ * \ingroup bnpr
  *
  * Shader module that manage shader libraries, deferred compilation,
  * and static shader usage.
@@ -20,7 +20,7 @@
 #include "GPU_shader.h"
 
 
-namespace blender::strokegen {
+namespace blender::bnpr {
 
 /* Keep alphabetical order and clean prefix. */
 enum eShaderType {
@@ -59,4 +59,4 @@ class ShaderModule {
   const char *static_shader_create_info_name_get(eShaderType shader_type);
 };
 
-}  // namespace blender::strokegen
+}  // namespace blender::bnpr
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
new file mode 100644
index 00000000000..5bff2b58f9e
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -0,0 +1,45 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Converts the different renderable object types to drawcalls.
+ */
+
+#include "bnpr_engine.h"
+
+#include "BKE_gpencil.h"
+#include "BKE_object.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_curves_types.h"
+#include "DNA_gpencil_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_particle_types.h"
+
+#include "bnpr_instance.hh"
+#include "bnpr_sync.hh"
+
+namespace blender::bnpr
+{
+
+  /* -------------------------------------------------------------------- */
+  /** \name Draw Data
+   *
+   * \{ */
+
+  static void draw_data_init_cb(struct DrawData *dd)
+  {
+    /* Object has just been created or was never evaluated by the engine. */
+    dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
+  }
+
+  // ObjectHandle& SyncModule::sync_object(Object* ob)
+  // {
+  //   DrawEngineType *owner = (DrawEngineType *)&DRW_engine_viewport_bnpr_type;
+  //   return ObjectHandle();
+  // }
+
+
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
similarity index 89%
rename from source/blender/draw/engines/strokegen/strokegen_sync.hh
rename to source/blender/draw/engines/bnpr/bnpr_sync.hh
index ff979e63d6e..fb7f649780b 100644
--- a/source/blender/draw/engines/strokegen/strokegen_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -17,10 +17,10 @@
 #include "DRW_render.h"
 #include "GPU_material.h"
 
-#include "strokegen_shader_shared.hh"
-#include "strokegen_sync_handles.hh"
+// #include "bnpr_shader_shared.hh"
+#include "bnpr_sync_handles.hh"
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
 
   class Instance;
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
similarity index 99%
rename from source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
rename to source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
index 2e0354a856d..8fd0fc90070 100644
--- a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
@@ -14,7 +14,7 @@
 
 // Copied from eevee_sync.hh
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
   /* -------------------------------------------------------------------- */
   /** \name ObjectKey
diff --git a/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
rename to source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_curves_vert.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_curves_vert.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_frag.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_frag.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_pointcloud_vert.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_pointcloud_vert.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_vert.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_vert.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl b/source/blender/draw/engines/bnpr/shaders/strokgen_conservative_depth_geom.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokgen_conservative_depth_geom.glsl
diff --git a/source/blender/draw/engines/strokegen/strokegen_defines.hh b/source/blender/draw/engines/bnpr/strokegen_defines.hh
similarity index 100%
rename from source/blender/draw/engines/strokegen/strokegen_defines.hh
rename to source/blender/draw/engines/bnpr/strokegen_defines.hh
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh b/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
similarity index 100%
rename from source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
rename to source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.cc b/source/blender/draw/engines/strokegen/strokegen_sync.cc
deleted file mode 100644
index 2eda953508b..00000000000
--- a/source/blender/draw/engines/strokegen/strokegen_sync.cc
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿/* SPDX-License-Identifier: GPL-2.0-or-later
-* Copyright 2021 Blender Foundation.
- */
-
-/** \file
- * \ingroup eevee
- *
- * Converts the different renderable object types to drawcalls.
- */
-
-#include "strokegen_engine.h"
-
-#include "BKE_gpencil.h"
-#include "BKE_object.h"
-#include "DEG_depsgraph_query.h"
-#include "DNA_curves_types.h"
-#include "DNA_gpencil_types.h"
-#include "DNA_modifier_types.h"
-#include "DNA_particle_types.h"
-
-#include "strokegen_instance.hh"
-#include "strokegen_sync.hh"
-
-namespace blender::strokegen
-{
-
-
-
-}
diff --git a/source/blender/draw/intern/draw_manager.c b/source/blender/draw/intern/draw_manager.c
index d10488abc22..00a08b38a55 100644
--- a/source/blender/draw/intern/draw_manager.c
+++ b/source/blender/draw/intern/draw_manager.c
@@ -96,7 +96,7 @@
 #include "engines/overlay/overlay_engine.h"
 #include "engines/select/select_engine.h"
 #include "engines/workbench/workbench_engine.h"
-#include "engines/strokegen/strokegen_engine.h"
+#include "engines/bnpr/bnpr_engine.h"
 
 #include "GPU_context.h"
 
@@ -3001,7 +3001,7 @@ void DRW_engines_register(void)
 {
   RE_engines_register(&DRW_engine_viewport_eevee_type);
   RE_engines_register(&DRW_engine_viewport_workbench_type);
-  RE_engines_register(&DRW_engine_viewport_strokegen_type);
+  RE_engines_register(&DRW_engine_viewport_bnpr_type);
 
   DRW_engine_register(&draw_engine_gpencil_type);
 
@@ -3016,7 +3016,7 @@ void DRW_engines_register(void)
   DRW_engine_register(&draw_engine_image_type);
   DRW_engine_register(DRW_engine_viewport_external_type.draw_engine);
 
-  DRW_engine_register(&draw_engine_strokegen_type);
+  DRW_engine_register(&draw_engine_bnpr_type);
 
   /* setup callbacks */
   {
-- 
2.38.1.windows.1


From 4210ae9778c63e64bc47ea195c2aed0731ef500a Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 4 Dec 2022 21:20:09 +0800
Subject: [PATCH 05/13] Added shared shader header files to project

---
 source/blender/draw/CMakeLists.txt                           | 3 +++
 .../engines/bnpr/{strokegen_defines.hh => bnpr_defines.hh}   | 5 ++++-
 .../{strokegen_shader_shared.hh => bnpr_shader_shared.hh}    | 2 ++
 source/blender/draw/engines/bnpr/bnpr_sync.hh                | 2 +-
 4 files changed, 10 insertions(+), 2 deletions(-)
 rename source/blender/draw/engines/bnpr/{strokegen_defines.hh => bnpr_defines.hh} (89%)
 rename source/blender/draw/engines/bnpr/{strokegen_shader_shared.hh => bnpr_shader_shared.hh} (94%)

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 90579052df5..3402caa5f23 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -705,6 +705,9 @@ set(GLSL_SRC
 
 
 
+  engines/bnpr/bnpr_defines.hh
+  engines/bnpr/bnpr_shader_shared.hh
+
 
 )
 
diff --git a/source/blender/draw/engines/bnpr/strokegen_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
similarity index 89%
rename from source/blender/draw/engines/bnpr/strokegen_defines.hh
rename to source/blender/draw/engines/bnpr/bnpr_defines.hh
index a1900395cc8..dfd63e92d97 100644
--- a/source/blender/draw/engines/bnpr/strokegen_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -3,8 +3,11 @@
  */
 
 /** \file
- * \ingroup eevee
+ * \ingroup bnpr
  *
  * List of defines that are shared with the GPUShaderCreateInfos. We do this to avoid
  * dragging larger headers into the createInfo pipeline which would cause problems.
  */
+
+
+#pragma once
diff --git a/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
similarity index 94%
rename from source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
rename to source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index ca4e6ad46d7..9cbb254e58c 100644
--- a/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -5,3 +5,5 @@
  * Can also include some math functions but they need to be simple enough to be valid in both
  * language.
  */
+
+#pragma once
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index fb7f649780b..b16e3dda61f 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -17,7 +17,7 @@
 #include "DRW_render.h"
 #include "GPU_material.h"
 
-// #include "bnpr_shader_shared.hh"
+#include "bnpr_shader_shared.hh"
 #include "bnpr_sync_handles.hh"
 
 namespace blender::bnpr
-- 
2.38.1.windows.1


From 66d94f9de7500eb324655a82abea6bf5804c27f2 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Tue, 6 Dec 2022 23:22:44 +0800
Subject: [PATCH 06/13] Finished empty compute shader compilation process

shader create info:
1) add directory to the cmakelist
2) add create info .hh to the cmakelist
3) I wrote some explanation in "bnpr_test_info.hh"
---
 source/blender/draw/CMakeLists.txt            | 15 ++--
 .../blender/draw/engines/bnpr/bnpr_defines.hh |  4 +-
 .../draw/engines/bnpr/bnpr_instance.hh        | 12 ++-
 .../blender/draw/engines/bnpr/bnpr_shader.cc  |  2 +
 .../blender/draw/engines/bnpr/bnpr_shader.hh  |  3 +-
 .../draw/engines/bnpr/bnpr_shader_shared.hh   | 90 ++++++++++++++++++-
 .../bnpr/bnpr_strokegen_buffer_pool.cc        | 25 ++++++
 .../bnpr/bnpr_strokegen_buffer_pool.hh        | 37 ++++++++
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  | 34 +++++++
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 56 ++++++++++++
 .../bnpr/bnpr_strokegen_texture_pool.cc       | 15 ++++
 .../bnpr/bnpr_strokegen_texture_pool.hh       | 35 ++++++++
 source/blender/draw/engines/bnpr/bnpr_sync.cc |  6 --
 source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +
 .../shaders/bnpr_strokegen_test_comp.glsl     | 57 ++++++++++++
 .../bnpr/shaders/infos/bnpr_test_info.hh      | 68 ++++++++++++++
 .../shaders/infos/strokegen_depth_info.hh     | 65 --------------
 source/blender/gpu/CMakeLists.txt             |  3 +
 18 files changed, 445 insertions(+), 84 deletions(-)
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
 delete mode 100644 source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 3402caa5f23..e6885e1958d 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -212,8 +212,9 @@ set(SRC
   engines/bnpr/bnpr_shader.cc
   engines/bnpr/bnpr_instance.cc
   engines/bnpr/bnpr_sync.cc
-
-
+  engines/bnpr/bnpr_strokegen_buffer_pool.cc
+  engines/bnpr/bnpr_strokegen_texture_pool.cc
+  engines/bnpr/bnpr_strokegen_pass.cc
 
 
 
@@ -310,6 +311,9 @@ set(SRC
   engines/bnpr/bnpr_instance.hh
   engines/bnpr/bnpr_sync_handles.hh
   engines/bnpr/bnpr_sync.hh
+  engines/bnpr/bnpr_strokegen_buffer_pool.hh
+  engines/bnpr/bnpr_strokegen_texture_pool.hh
+  engines/bnpr/bnpr_strokegen_pass.hh
 )
 
 set(LIB
@@ -700,15 +704,10 @@ set(GLSL_SRC
   engines/image/shaders/image_engine_depth_frag.glsl
   engines/image/shaders/image_engine_depth_vert.glsl
 
-
-
-
-
+  engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
 
   engines/bnpr/bnpr_defines.hh
   engines/bnpr/bnpr_shader_shared.hh
-
-
 )
 
 set(GLSL_C)
diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
index dfd63e92d97..1ffca605ca9 100644
--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -9,5 +9,7 @@
  * dragging larger headers into the createInfo pipeline which would cause problems.
  */
 
-
 #pragma once
+
+
+#define GROUP_SIZE_STROKEGEN_TEST 512
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
index 5f6a7374b89..54517634682 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -23,7 +23,9 @@
 #include "draw_pass.hh"
 #include "bnpr_shader.hh"
 #include "bnpr_sync.hh"
-
+#include "bnpr_strokegen_buffer_pool.hh"
+#include "bnpr_strokegen_texture_pool.hh"
+#include "bnpr_strokegen_pass.hh"
 
 namespace blender::bnpr
 {
@@ -37,6 +39,9 @@ namespace blender::bnpr
     /** Shading Modules */
     ShaderModule shaders; // singleton class for handling GPUShader(s)
     SyncModule sync;
+    GPUBufferPoolModule   strokegen_buffers;
+    GPUTexturePoolModule  strokegen_textures;
+    StrokeGenPassModule   strokegen_passes;
 
     /** Input data. */
     Depsgraph *depsgraph;
@@ -65,7 +70,10 @@ namespace blender::bnpr
   public:
     Instance() :
     shaders(*ShaderModule::module_get()),
-    sync(*this)
+    sync(*this),
+    strokegen_buffers(*this),
+    strokegen_textures(*this),
+    strokegen_passes(shaders, strokegen_buffers, strokegen_textures)
     {
     };
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
index 7bf72caf057..75cc42e3c09 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -90,6 +90,8 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
       return "basic_depth_mesh_conservative";
     case POINTCLOUD_DEPTH_CONSERVATIVE:
       return "basic_depth_pointcloud_conservative";
+    case COMPUTE_TEST:
+      return "bnpr_strokegen_test";
 
     /* To avoid compiler warning about missing case. */
     case MAX_SHADER_TYPE:
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
index 9b756e213a4..ff758760c22 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
@@ -24,7 +24,8 @@ namespace blender::bnpr {
 
 /* Keep alphabetical order and clean prefix. */
 enum eShaderType {
-  DEPTH = 0,
+  COMPUTE_TEST = 0,
+  DEPTH,
   POINTCLOUD_DEPTH,
   CURVES_DEPTH,
   DEPTH_CONSERVATIVE,
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index 9cbb254e58c..4a33610836a 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -6,4 +6,92 @@
  * language.
  */
 
-#pragma once
+#ifndef USE_GPU_SHADER_CREATE_INFO
+#  pragma once
+
+#  include "BLI_memory_utils.hh"
+#  include "DRW_gpu_wrapper.hh"
+
+#  include "draw_manager.hh"
+#  include "draw_pass.hh"
+
+#  include "bnpr_defines.hh"
+
+#  include "GPU_shader_shared.h"
+
+namespace blender::bnpr {
+
+using namespace draw;
+
+constexpr eGPUSamplerState no_filter = GPU_SAMPLER_DEFAULT;
+constexpr eGPUSamplerState with_filter = GPU_SAMPLER_FILTER;
+
+#endif
+
+
+
+#define UBO_MIN_MAX_SUPPORTED_SIZE 1 << 14
+
+/* -------------------------------------------------------------------- */
+/** \name Debug Mode
+ * \{ */
+
+/** These are just to make more sense of G.debug_value's values. Reserved range is 1-30. */
+enum eDebugMode : uint32_t {
+  DEBUG_NONE = 0u,
+  /**
+   * Gradient showing light evaluation hot-spots.
+   */
+  DEBUG_LIGHT_CULLING = 1u,
+  /**
+   * Show incorrectly downsample tiles in red.
+   */
+  DEBUG_HIZ_VALIDATION = 2u,
+  /**
+   * Tile-maps to screen. Is also present in other modes.
+   * - Black pixels, no pages allocated.
+   * - Green pixels, pages cached.
+   * - Red pixels, pages allocated.
+   */
+  DEBUG_SHADOW_TILEMAPS = 10u,
+  /**
+   * Random color per pages. Validates page density allocation and sampling.
+   */
+  DEBUG_SHADOW_PAGES = 11u,
+  /**
+   * Outputs random color per tile-map (or tile-map level). Validates tile-maps coverage.
+   * Black means not covered by any tile-maps LOD of the shadow.
+   */
+  DEBUG_SHADOW_LOD = 12u,
+  /**
+   * Outputs white pixels for pages allocated and black pixels for unused pages.
+   * This needs DEBUG_SHADOW_PAGE_ALLOCATION_ENABLED defined in order to work.
+   */
+  DEBUG_SHADOW_PAGE_ALLOCATION = 13u,
+  /**
+   * Outputs the tile-map atlas. Default tile-map is too big for the usual screen resolution.
+   * Try lowering SHADOW_TILEMAP_PER_ROW and SHADOW_MAX_TILEMAP before using this option.
+   */
+  DEBUG_SHADOW_TILE_ALLOCATION = 14u,
+  /**
+   * Visualize linear depth stored in the atlas regions of the active light.
+   * This way, one can check if the rendering, the copying and the shadow sampling functions works.
+   */
+  DEBUG_SHADOW_SHADOW_DEPTH = 15u
+};
+/** \} */
+
+
+
+
+#ifdef __cplusplus
+
+// Template to set buffer size in compile time
+using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
+
+
+}
+
+
+// namespace blender::bnpr
+#endif
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
new file mode 100644
index 00000000000..39d96265894
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
@@ -0,0 +1,25 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#include "bnpr_strokegen_buffer_pool.hh"
+#include "bnpr_instance.hh"
+
+namespace blender::bnpr
+{
+  void GPUBufferPoolModule::sync(Object* object)
+  {
+  }
+
+  void GPUBufferPoolModule::end_sync()
+  {
+    // arr_buf_test_.resize(4096); // maybe needed for a few special buffers
+  }
+
+
+
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
new file mode 100644
index 00000000000..7c2e58abe49
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -0,0 +1,37 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#pragma once
+
+#include "bnpr_shader_shared.hh"
+
+namespace blender::bnpr
+{
+  class Instance;
+
+  class GPUBufferPoolModule
+  {
+    friend class StrokeGenPassModule;
+
+  private:
+    /** Compute Resources */
+    StrokeGenTestBuf arr_buf_test_;
+
+    /** Instance */
+    Instance &instance;
+
+
+  public:
+    GPUBufferPoolModule(Instance &inst) : instance(inst) {};
+    ~GPUBufferPoolModule() {};
+
+    void sync(Object* object);
+    void end_sync();
+
+  };
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
new file mode 100644
index 00000000000..44a2c7bc6db
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -0,0 +1,34 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ *
+ */
+
+#include "bnpr_strokegen_pass.hh"
+
+namespace blender::bnpr
+{
+  using namespace blender;
+
+
+  void StrokeGenPassModule::sync_(
+    GPUBufferPoolModule& strokegen_buffers,
+    GPUTexturePoolModule& strokegen_texture_pool)
+  {
+    pass_comp_test.init();
+    {
+      auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
+      sub.bind_ssbo("buf_test", strokegen_buffers.arr_buf_test_);
+      sub.dispatch(int3(32, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+  }
+
+  void StrokeGenPassModule::end_sync_()
+  {
+  }
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
new file mode 100644
index 00000000000..c6335e57dd9
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -0,0 +1,56 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#pragma once
+
+#include "draw_pass.hh"
+#include "draw_manager.hh"
+
+#include "bnpr_shader.hh"
+#include "bnpr_shader_shared.hh"
+#include "bnpr_strokegen_buffer_pool.hh"
+#include "bnpr_strokegen_texture_pool.hh"
+#include "bnpr_strokegen_pass.hh"
+
+namespace blender::bnpr
+{
+  class Instance;
+
+  class StrokeGenPassModule // similar to "LineDrawingRenderPass"
+  {
+  private:
+    /** Compute Passes */
+    draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
+
+    /** Instance */
+    ShaderModule &shaders_;
+    GPUBufferPoolModule& buffers_;
+    GPUTexturePoolModule& textures_;
+
+    void sync_(GPUBufferPoolModule& strokegen_buffers, GPUTexturePoolModule& strokegen_texture_pool);
+    void end_sync_();
+
+
+  public:
+    StrokeGenPassModule(
+      ShaderModule          &strokegen_shaders,
+      GPUBufferPoolModule   &instance_buffers,
+      GPUTexturePoolModule  &strokegen_textures
+    ) :
+      shaders_(strokegen_shaders),
+      buffers_(instance_buffers),
+      textures_(strokegen_textures)
+    {};
+
+    ~StrokeGenPassModule() {};
+
+    void sync() { sync_(buffers_, textures_); }
+    void end_sync() { end_sync_(); }
+  };
+}
+
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
new file mode 100644
index 00000000000..002a9d2b4b0
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
@@ -0,0 +1,15 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#include "bnpr_strokegen_texture_pool.hh"
+#include "bnpr_instance.hh"
+
+namespace blender::bnpr
+{
+
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
new file mode 100644
index 00000000000..9250260ce83
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
@@ -0,0 +1,35 @@
+﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#pragma once
+
+#include "bnpr_shader_shared.hh"
+
+namespace blender::bnpr
+{
+  class Instance;
+
+  class GPUTexturePoolModule
+  {
+  private:
+    /** Compute Resources */
+    StrokeGenTestBuf arr_buf_test_;
+
+    /** Instance */
+    Instance &instance;
+
+
+  public:
+    GPUTexturePoolModule(Instance &inst) : instance(inst) {};
+    ~GPUTexturePoolModule() {};
+
+    void sync(Object* object) {};
+    void end_sync() {};
+
+  };
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index 5bff2b58f9e..0bf3e988214 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -35,11 +35,5 @@ namespace blender::bnpr
     dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
   }
 
-  // ObjectHandle& SyncModule::sync_object(Object* ob)
-  // {
-  //   DrawEngineType *owner = (DrawEngineType *)&DRW_engine_viewport_bnpr_type;
-  //   return ObjectHandle();
-  // }
-
 
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index b16e3dda61f..696559fcc48 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -44,6 +44,8 @@ namespace blender::bnpr
                    const draw::ObjectRef &ob_ref) {};
   };
 
+
+
 }
 
 
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
new file mode 100644
index 00000000000..4bec9ae766b
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -0,0 +1,57 @@
+
+/**
+ * Sort the lights by their Z distance to the camera.
+ * Outputs ordered light buffer.
+ * One thread processes one Light entity.
+ */
+
+// #pragma BLENDER_REQUIRE(common_math_lib.glsl)
+
+uint buf_test[/*gl_WorkGroupSize.x*/4096];
+
+void main()
+{
+  // uint src_index = gl_GlobalInvocationID.x;
+  // bool valid_thread = true;
+//
+  // if (src_index >= light_cull_buf.visible_count) {
+  //   /* Do not return because we use barriers later on (which need uniform control flow).
+  //    * Just process the same last item but avoid insertion. */
+  //   src_index = light_cull_buf.visible_count - 1;
+  //   valid_thread = false;
+  // }
+//
+  // float local_zdist = in_zdist_buf[src_index];
+//
+  // int prefix_sum = 0;
+  // /* Iterate over the whole key buffer. */
+  // uint iter = divide_ceil(light_cull_buf.visible_count, gl_WorkGroupSize.x);
+  // for (uint i = 0u; i < iter; i++) {
+  //   uint index = gl_WorkGroupSize.x * i + gl_LocalInvocationID.x;
+  //   /* NOTE: This will load duplicated values, but they will be discarded. */
+  //   index = min(index, light_cull_buf.visible_count - 1);
+  //   zdists_cache[gl_LocalInvocationID.x] = in_zdist_buf[index];
+//
+  //   barrier();
+//
+  //   /* Iterate over the cache line. */
+  //   uint line_end = min(gl_WorkGroupSize.x, light_cull_buf.visible_count - gl_WorkGroupSize.x * i);
+  //   for (uint j = 0u; j < line_end; j++) {
+  //     if (zdists_cache[j] < local_zdist) {
+  //       prefix_sum++;
+  //     }
+  //     else if (zdists_cache[j] == local_zdist) {
+  //       /* Same depth, use index to order and avoid same prefix for 2 different lights. */
+  //       if ((gl_WorkGroupSize.x * i + j) < src_index) {
+  //         prefix_sum++;
+  //       }
+  //     }
+  //   }
+  // }
+//
+  // if (valid_thread) {
+  //   /* Copy sorted light to render light buffer. */
+  //   uint input_index = in_key_buf[src_index];
+  //   out_light_buf[prefix_sum] = in_light_buf[input_index];
+  // }
+}
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
new file mode 100644
index 00000000000..0d1f735983d
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include "bnpr_defines.hh"
+#include "gpu_shader_create_info.hh"
+
+/* -------------------------------------------------------------------- */
+/** \name Tutorial
+ * \{ */
+
+/* For details, see "gpu_shader_create_info.hh" */
+// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_comp)
+  // .do_static_compilation(true)
+
+  /* -------------------------------------------------------------------- */
+  /* Name of other infos to recursively merge with this one.
+   * No data slot must overlap otherwise we throw an error. */
+  // .additional_info("eevee_shared", "draw_view", "draw_view_culling")
+  // .define("DOF_BOKEH_TEXTURE", "false")
+
+  /* -------------------------------------------------------------------- */
+  /** Resources bindings points
+  // .uniform_buf(6, "DepthOfFieldData", "dof_buf")
+  // .storage_buf(0, Qualifier::READ_WRITE, "LightCullingData", "light_cull_buf")
+  // .storage_buf(1, Qualifier::READ, "LightData", "in_light_buf[]")
+  // .storage_buf(2, Qualifier::WRITE, "LightData", "out_light_buf[]")
+  // .sampler(0, ImageType::FLOAT_2D, "downsample_tx")
+  // .image(0, GPU_RGBA16F, Qualifier::READ_WRITE, ImageType::FLOAT_2D, "inout_color_lod0_img")
+  /*          eGPUTextureFormat                     ImageType  */
+
+  /* -------------------------------------------------------------------- */
+  /** Comptue shader
+  // .local_group_size(CULLING_SELECT_GROUP_SIZE) /* <== from "bnpr_defines.hh" */
+  // .compute_source("eevee_light_culling_select_comp.glsl");
+
+  /* -------------------------------------------------------------------- */
+  // Vertex & Fragment shader
+  // .vertex_in(0, Type::VEC3, "pos")
+  // .vertex_in(1, Type::VEC3, "nor")
+  // .vertex_source("eevee_geom_mesh_vert.glsl")
+  //
+  // .fragment_out(0, Type::VEC4, "out_radiance", DualBlend::SRC_0)
+  // .fragment_out(1, Type::VEC4, "out_transmittance", DualBlend::SRC_1)
+  // .fragment_source("eevee_surf_forward_frag.glsl")
+  //
+  /* In order to use .vertex_out for vs output,
+   * we firstly need to define an interface:
+// GPU_SHADER_INTERFACE_INFO(interface_info_name, "interp")
+  // .smooth(Type::VEC3, "a") /* smooth: conventional interpolation for fragments */
+  // .flat(Type::VEC3, "b"); /* flat: no interpolation, instead, use attribute from a "provoking vertex" */
+  // .noperspective(Type::VEC3, "c") /* interpolation, without perspective correction */
+  /* Then use the interface to declare a .vertex_out: */
+  // .vertex_out(interface_info_name)
+
+/** \} */
+
+
+
+
+/* -------------------------------------------------------------------- */
+/** \test
+ * \{ */
+GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
+  .do_static_compilation(true)
+  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
+  .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_strokegen_test_comp.glsl");
+
+/** \} */
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
deleted file mode 100644
index e275d208c7a..00000000000
--- a/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
+++ /dev/null
@@ -1,65 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-
-#include "gpu_shader_create_info.hh"
-
-/* -------------------------------------------------------------------- */
-/** \name Conservative Rasterization
- *
- * Allow selection of sub-pixel objects.
- * \{ */
-
-GPU_SHADER_CREATE_INFO(basic_conservative)
-    .geometry_layout(PrimitiveIn::TRIANGLES, PrimitiveOut::TRIANGLE_STRIP, 3)
-    .geometry_source("basic_conservative_depth_geom.glsl");
-
-/** \} */
-
-/* -------------------------------------------------------------------- */
-/** \name Object types
- * \{ */
-
-GPU_SHADER_CREATE_INFO(basic_mesh)
-    .vertex_in(0, Type::VEC3, "pos")
-    .vertex_source("basic_depth_vert.glsl")
-    .additional_info("draw_mesh");
-
-GPU_SHADER_CREATE_INFO(basic_pointcloud)
-    .vertex_source("basic_depth_pointcloud_vert.glsl")
-    .additional_info("draw_pointcloud");
-
-GPU_SHADER_CREATE_INFO(basic_curves)
-    .vertex_source("basic_depth_curves_vert.glsl")
-    .additional_info("draw_hair");
-/** \} */
-
-/* -------------------------------------------------------------------- */
-/** \name Variations Declaration
- * \{ */
-
-#define BASIC_FINAL_VARIATION(name, ...) \
-  GPU_SHADER_CREATE_INFO(name).additional_info(__VA_ARGS__).do_static_compilation(true);
-
-#define BASIC_CLIPPING_VARIATIONS(prefix, ...) \
-  BASIC_FINAL_VARIATION(prefix##_clipped, "drw_clipped", __VA_ARGS__) \
-  BASIC_FINAL_VARIATION(prefix, __VA_ARGS__)
-
-#define BASIC_CONSERVATIVE_VARIATIONS(prefix, ...) \
-  BASIC_CLIPPING_VARIATIONS(prefix##_conservative, "basic_conservative", __VA_ARGS__) \
-  BASIC_CLIPPING_VARIATIONS(prefix, __VA_ARGS__)
-
-#define BASIC_OBTYPE_VARIATIONS(prefix, ...) \
-  BASIC_CONSERVATIVE_VARIATIONS(prefix##_mesh, "basic_mesh", __VA_ARGS__) \
-  BASIC_CONSERVATIVE_VARIATIONS(prefix##_pointcloud, "basic_pointcloud", __VA_ARGS__) \
-  BASIC_CLIPPING_VARIATIONS(prefix##_curves, "basic_curves", __VA_ARGS__)
-
-/** \} */
-
-/* -------------------------------------------------------------------- */
-/** \name Depth shader types.
- * \{ */
-
-GPU_SHADER_CREATE_INFO(basic_depth).fragment_source("basic_depth_frag.glsl");
-
-BASIC_OBTYPE_VARIATIONS(basic_depth, "basic_depth", "draw_globals");
-
-/** \} */
diff --git a/source/blender/gpu/CMakeLists.txt b/source/blender/gpu/CMakeLists.txt
index 02793fa74be..326ff061138 100644
--- a/source/blender/gpu/CMakeLists.txt
+++ b/source/blender/gpu/CMakeLists.txt
@@ -29,6 +29,7 @@ set(INC
   # For *_info.hh includes.
   ../compositor/realtime_compositor
   ../draw/engines/eevee_next
+  ../draw/engines/bnpr
   ../draw/intern
 
   # For node muting stuff.
@@ -590,6 +591,8 @@ set(SRC_SHADER_CREATE_INFOS
   ../draw/engines/eevee/shaders/infos/eevee_legacy_volume_info.hh
 
   ../draw/engines/image/shaders/infos/engine_image_info.hh
+
+  ../draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
   ../draw/intern/shaders/draw_debug_info.hh
   ../draw/intern/shaders/draw_fullscreen_info.hh
   ../draw/intern/shaders/draw_hair_refine_info.hh
-- 
2.38.1.windows.1


From 1a95c1f492f07cb50eb6a6ca1458e0966012c3c0 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 11 Dec 2022 19:39:06 +0800
Subject: [PATCH 07/13] Add sync_object

to sync a mesh, I need a material module
---
 .../bnpr/bnpr_strokegen_buffer_pool.hh        |  6 ++---
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  |  4 ++--
 .../bnpr/bnpr_strokegen_texture_pool.hh       | 12 +++++-----
 source/blender/draw/engines/bnpr/bnpr_sync.cc | 22 +++++++++++++++++--
 source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +-
 .../draw/engines/bnpr/bnpr_sync_handles.hh    |  3 +--
 6 files changed, 34 insertions(+), 15 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
index 7c2e58abe49..c821086ae5d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -19,12 +19,12 @@ namespace blender::bnpr
     friend class StrokeGenPassModule;
 
   private:
-    /** Compute Resources */
-    StrokeGenTestBuf arr_buf_test_;
-
     /** Instance */
     Instance &instance;
 
+    /** Compute Resources */
+    StrokeGenTestBuf arr_buf_test_;
+
 
   public:
     GPUBufferPoolModule(Instance &inst) : instance(inst) {};
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index c6335e57dd9..3848a035fc9 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -39,11 +39,11 @@ namespace blender::bnpr
   public:
     StrokeGenPassModule(
       ShaderModule          &strokegen_shaders,
-      GPUBufferPoolModule   &instance_buffers,
+      GPUBufferPoolModule   &strokegen_buffers,
       GPUTexturePoolModule  &strokegen_textures
     ) :
       shaders_(strokegen_shaders),
-      buffers_(instance_buffers),
+      buffers_(strokegen_buffers),
       textures_(strokegen_textures)
     {};
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
index 9250260ce83..25a1b6612f3 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
@@ -17,15 +17,17 @@ namespace blender::bnpr
   class GPUTexturePoolModule
   {
   private:
-    /** Compute Resources */
-    StrokeGenTestBuf arr_buf_test_;
-
     /** Instance */
-    Instance &instance;
+    Instance &instance_;
+
+    /** Compute Resources */
+    TextureFromPool strokegen_tex_test_;
 
 
   public:
-    GPUTexturePoolModule(Instance &inst) : instance(inst) {};
+    GPUTexturePoolModule(Instance &inst) :
+      instance_(inst),
+      strokegen_tex_test_("StrokegenTexture_Test"){};
     ~GPUTexturePoolModule() {};
 
     void sync(Object* object) {};
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index 0bf3e988214..e8201ebad65 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -23,17 +23,35 @@
 
 namespace blender::bnpr
 {
-
   /* -------------------------------------------------------------------- */
   /** \name Draw Data
    *
    * \{ */
 
-  static void draw_data_init_cb(struct DrawData *dd)
+  static void draw_data_init_cb(struct DrawData* dd)
   {
     /* Object has just been created or was never evaluated by the engine. */
     dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
   }
 
 
+  ObjectHandle& SyncModule::sync_object(Object* ob)
+  {
+    DrawEngineType* owner = (DrawEngineType*)&DRW_engine_viewport_bnpr_type;
+    struct DrawData* dd = DRW_drawdata_ensure(
+      (ID*)ob, owner, sizeof(ObjectHandle), draw_data_init_cb, nullptr);
+
+    ObjectHandle &dd_bnpr = *reinterpret_cast<ObjectHandle*>(dd); // draw-engine specific draw data.
+
+    if (dd_bnpr.object_key.ob == nullptr)
+    {
+      dd_bnpr.object_key = ObjectKey(ob);
+    }
+
+
+    return dd_bnpr;
+  }
+
+
+
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index 696559fcc48..4b8ca2a1656 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -34,7 +34,7 @@ namespace blender::bnpr
     SyncModule(Instance &inst) : inst_(inst) {};
     ~SyncModule(){};
 
-    ObjectHandle &sync_object(Object *ob) {};
+    ObjectHandle &sync_object(Object *ob);
     WorldHandle &sync_world(::World *world) {};
     SceneHandle &sync_scene(::Scene *scene) {};
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
index 8fd0fc90070..3560f7a3926 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
@@ -125,8 +125,7 @@ namespace blender::bnpr
   /** \} */
 
   /* -------------------------------------------------------------------- */
-  /** \name Sync Module
-   *
+  /** \name Engine-Specific Draw-Data
    * \{ */
 
   struct ObjectHandle : public DrawData
-- 
2.38.1.windows.1


From aeb4fd04eeceaa63b77566011e1d876318760edb Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Mon, 12 Dec 2022 00:06:55 +0800
Subject: [PATCH 08/13] Experiment with mesh_sync and actual shader dispatch.

1) Compute dispatch does not run since we haven't implemented
instance->draw_viewport yet.
2) mesh_sync calls dispatch, but requires the draw manager to submit the passes including the compute shaders, and submission should happen in instance->draw_viewport
---
 .../draw/engines/bnpr/bnpr_instance.cc        | 34 +++++++++++++++++--
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  | 12 +++----
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 10 +++---
 source/blender/draw/engines/bnpr/bnpr_sync.cc | 24 +++++++++++++
 source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +-
 .../shaders/bnpr_strokegen_test_comp.glsl     |  4 +--
 6 files changed, 67 insertions(+), 19 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index 5139b0c5f49..2bb9985950d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -81,8 +81,38 @@ namespace blender::bnpr
   }
 
   void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
-  {
-    /* Add object draw calls to passes. (Populate render graph) */
+  { /* Add object draw calls to passes. (Populate render graph) */
+    Object *ob = object_ref.object;
+
+    const bool is_renderable_type = ELEM(ob->type, OB_CURVES, OB_GPENCIL, OB_MESH, OB_LAMP);
+    const int ob_visibility = DRW_object_visibility_in_active_context(ob);
+    const bool partsys_is_visible = (ob_visibility & OB_VISIBLE_PARTICLES) != 0 &&
+                                    (ob->type == OB_MESH);
+    const bool object_is_visible = DRW_object_is_renderable(ob) &&
+                                   (ob_visibility & OB_VISIBLE_SELF) != 0;
+
+    if (!is_renderable_type || (!partsys_is_visible && !object_is_visible)) {
+      return;
+    }
+
+    /* fclem: TODO cleanup. */
+    ObjectRef ob_ref = DRW_object_ref_get(ob);
+    ResourceHandle res_handle = manager.resource_handle(ob_ref);
+
+    ObjectHandle &ob_handle = sync.sync_object(ob);
+
+
+    if (object_is_visible) {
+      switch (ob->type) {
+      case OB_MESH:
+        sync.sync_mesh(ob, ob_handle, res_handle, ob_ref);
+        break;
+      default:
+        break;
+      }
+    }
+
+    ob_handle.reset_recalc_flag();
   }
 
   void Instance::end_sync(Manager&)
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index 44a2c7bc6db..ec1d4f33f10 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -13,22 +13,18 @@ namespace blender::bnpr
 {
   using namespace blender;
 
-
-  void StrokeGenPassModule::sync_(
-    GPUBufferPoolModule& strokegen_buffers,
-    GPUTexturePoolModule& strokegen_texture_pool)
+  void StrokeGenPassModule::dispatch_extract_mesh_contour(Object* ob)
   {
     pass_comp_test.init();
     {
       auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
       sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
-      sub.bind_ssbo("buf_test", strokegen_buffers.arr_buf_test_);
+      sub.bind_ssbo("buf_test", buffers_.arr_buf_test_);
       sub.dispatch(int3(32, 1, 1));
       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
     }
   }
 
-  void StrokeGenPassModule::end_sync_()
-  {
-  }
+
+
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index 3848a035fc9..edd4d92edfb 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -32,9 +32,6 @@ namespace blender::bnpr
     GPUBufferPoolModule& buffers_;
     GPUTexturePoolModule& textures_;
 
-    void sync_(GPUBufferPoolModule& strokegen_buffers, GPUTexturePoolModule& strokegen_texture_pool);
-    void end_sync_();
-
 
   public:
     StrokeGenPassModule(
@@ -49,8 +46,11 @@ namespace blender::bnpr
 
     ~StrokeGenPassModule() {};
 
-    void sync() { sync_(buffers_, textures_); }
-    void end_sync() { end_sync_(); }
+    /** Passes Batched by Usages */
+    void dispatch_extract_mesh_contour(Object* ob);
+
+
+
   };
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index e8201ebad65..8c94eed402b 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -21,6 +21,9 @@
 #include "bnpr_instance.hh"
 #include "bnpr_sync.hh"
 
+#include "draw_cache_extract.hh"
+#include "draw_cache_impl.h"
+
 namespace blender::bnpr
 {
   /* -------------------------------------------------------------------- */
@@ -52,6 +55,27 @@ namespace blender::bnpr
     return dd_bnpr;
   }
 
+  void SyncModule::sync_mesh(
+    Object* ob, ObjectHandle& ob_handle,
+    draw::ResourceHandle res_handle, const draw::ObjectRef& ob_ref
+  )
+  {
+    bool mesh_is_manifold;
+    GPUBatch *geobatch = DRW_cache_object_edge_detection_get(ob, &mesh_is_manifold);
+
+    if (geobatch == nullptr) return;
 
+    // Old way to do this:
+    // See "draw_subdiv_build_tris_buffer"
+    // const char *defines = "#define XXX\n";
+    // GPUShader *shader = get_strokegen_shader(...)
+    //
+    // eevvee_next way to do this:
+    //  strokegen_passes.dispatch_extract_mesh_contour(ob);
+    //  strokegen_passes.dispatch_XXX(...);
+    //  ... ... ...
+    inst_.strokegen_passes.dispatch_extract_mesh_contour(ob);
 
+
+  }
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index 4b8ca2a1656..974b162092d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -41,7 +41,7 @@ namespace blender::bnpr
     void sync_mesh(Object *ob,
                    ObjectHandle &ob_handle,
                    draw::ResourceHandle res_handle,
-                   const draw::ObjectRef &ob_ref) {};
+                   const draw::ObjectRef &ob_ref);
   };
 
 
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
index 4bec9ae766b..5d0304865db 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -5,9 +5,7 @@
  * One thread processes one Light entity.
  */
 
-// #pragma BLENDER_REQUIRE(common_math_lib.glsl)
-
-uint buf_test[/*gl_WorkGroupSize.x*/4096];
+#pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
 
 void main()
 {
-- 
2.38.1.windows.1


From a5e0a0429066c6d0fd22dda96dba68f97c80ea39 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Wed, 21 Dec 2022 22:21:56 +0800
Subject: [PATCH 09/13] submit test compute pass

---
 .../draw/engines/bnpr/bnpr_instance.cc        | 10 ++--
 .../draw/engines/bnpr/bnpr_instance.hh        |  2 +-
 .../blender/draw/engines/bnpr/bnpr_shader.cc  |  2 +-
 .../draw/engines/bnpr/bnpr_shader_shared.hh   | 58 -------------------
 .../bnpr/bnpr_strokegen_buffer_pool.hh        |  2 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |  4 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 14 ++++-
 source/blender/draw/engines/bnpr/bnpr_sync.cc |  2 +-
 .../shaders/bnpr_strokegen_test_comp.glsl     | 48 +--------------
 .../bnpr/shaders/infos/bnpr_test_info.hh      |  8 ++-
 10 files changed, 32 insertions(+), 118 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index 2bb9985950d..46be7fd8d31 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -80,6 +80,11 @@ namespace blender::bnpr
     /* Init draw passes and manager related stuff. (Begin render graph) */
   }
 
+  void Instance::end_sync(Manager&)
+  {
+    /* Post processing after all object. (End render graph) */
+  }
+
   void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
   { /* Add object draw calls to passes. (Populate render graph) */
     Object *ob = object_ref.object;
@@ -115,10 +120,6 @@ namespace blender::bnpr
     ob_handle.reset_recalc_flag();
   }
 
-  void Instance::end_sync(Manager&)
-  {
-    /* Post processing after all object. (End render graph) */
-  }
 
   /** \} */
 
@@ -135,6 +136,7 @@ namespace blender::bnpr
     GPUTexture* color_tx)
   {
     /* Submit passes here. (Execute render graph) */
+    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::EXTRACT_MESH_CONTOUR), view);
   }
 
   /** \} */
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
index 54517634682..6d7532c8ea3 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -82,10 +82,10 @@ namespace blender::bnpr
     void update_eval_members();
 
     void begin_sync(Manager& manager);
+    void end_sync(Manager& manager);
 
     void object_sync(Manager& manager, ObjectRef& object_ref);
 
-    void end_sync(Manager& /* manager */);
 
     void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
                        GPUTexture* color_tx);
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
index 75cc42e3c09..c77bc4675fa 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -91,7 +91,7 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
     case POINTCLOUD_DEPTH_CONSERVATIVE:
       return "basic_depth_pointcloud_conservative";
     case COMPUTE_TEST:
-      return "bnpr_strokegen_test";
+      return "bnpr_strokegen_test_xxx";
 
     /* To avoid compiler warning about missing case. */
     case MAX_SHADER_TYPE:
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index 4a33610836a..7b98d823540 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -23,67 +23,10 @@ namespace blender::bnpr {
 
 using namespace draw;
 
-constexpr eGPUSamplerState no_filter = GPU_SAMPLER_DEFAULT;
-constexpr eGPUSamplerState with_filter = GPU_SAMPLER_FILTER;
-
 #endif
 
 
 
-#define UBO_MIN_MAX_SUPPORTED_SIZE 1 << 14
-
-/* -------------------------------------------------------------------- */
-/** \name Debug Mode
- * \{ */
-
-/** These are just to make more sense of G.debug_value's values. Reserved range is 1-30. */
-enum eDebugMode : uint32_t {
-  DEBUG_NONE = 0u,
-  /**
-   * Gradient showing light evaluation hot-spots.
-   */
-  DEBUG_LIGHT_CULLING = 1u,
-  /**
-   * Show incorrectly downsample tiles in red.
-   */
-  DEBUG_HIZ_VALIDATION = 2u,
-  /**
-   * Tile-maps to screen. Is also present in other modes.
-   * - Black pixels, no pages allocated.
-   * - Green pixels, pages cached.
-   * - Red pixels, pages allocated.
-   */
-  DEBUG_SHADOW_TILEMAPS = 10u,
-  /**
-   * Random color per pages. Validates page density allocation and sampling.
-   */
-  DEBUG_SHADOW_PAGES = 11u,
-  /**
-   * Outputs random color per tile-map (or tile-map level). Validates tile-maps coverage.
-   * Black means not covered by any tile-maps LOD of the shadow.
-   */
-  DEBUG_SHADOW_LOD = 12u,
-  /**
-   * Outputs white pixels for pages allocated and black pixels for unused pages.
-   * This needs DEBUG_SHADOW_PAGE_ALLOCATION_ENABLED defined in order to work.
-   */
-  DEBUG_SHADOW_PAGE_ALLOCATION = 13u,
-  /**
-   * Outputs the tile-map atlas. Default tile-map is too big for the usual screen resolution.
-   * Try lowering SHADOW_TILEMAP_PER_ROW and SHADOW_MAX_TILEMAP before using this option.
-   */
-  DEBUG_SHADOW_TILE_ALLOCATION = 14u,
-  /**
-   * Visualize linear depth stored in the atlas regions of the active light.
-   * This way, one can check if the rendering, the copying and the shadow sampling functions works.
-   */
-  DEBUG_SHADOW_SHADOW_DEPTH = 15u
-};
-/** \} */
-
-
-
-
 #ifdef __cplusplus
 
 // Template to set buffer size in compile time
@@ -92,6 +35,5 @@ using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
 
 }
 
-
 // namespace blender::bnpr
 #endif
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
index c821086ae5d..cf017d0823f 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -23,7 +23,7 @@ namespace blender::bnpr
     Instance &instance;
 
     /** Compute Resources */
-    StrokeGenTestBuf arr_buf_test_;
+    StrokeGenTestBuf strokegen_test_buf_;
 
 
   public:
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index ec1d4f33f10..058198dac13 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -13,13 +13,13 @@ namespace blender::bnpr
 {
   using namespace blender;
 
-  void StrokeGenPassModule::dispatch_extract_mesh_contour(Object* ob)
+  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob)
   {
     pass_comp_test.init();
     {
       auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
       sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
-      sub.bind_ssbo("buf_test", buffers_.arr_buf_test_);
+      sub.bind_ssbo("buf_test", buffers_.strokegen_test_buf_);
       sub.dispatch(int3(32, 1, 1));
       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
     }
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index edd4d92edfb..6663f38eec7 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -47,9 +47,21 @@ namespace blender::bnpr
     ~StrokeGenPassModule() {};
 
     /** Passes Batched by Usages */
-    void dispatch_extract_mesh_contour(Object* ob);
+    enum eType
+    {
+      EXTRACT_MESH_CONTOUR = 0
+    };
 
+    PassSimple& get_compute_pass(eType passType)
+    {
+      switch (passType) {
+        case EXTRACT_MESH_CONTOUR:
+          return pass_comp_test;
+      }
+      return pass_comp_test;
+    }
 
+    void rebuild_pass_extract_mesh_contour(Object* ob);
 
   };
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index 8c94eed402b..f350911e958 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -74,7 +74,7 @@ namespace blender::bnpr
     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
     //  strokegen_passes.dispatch_XXX(...);
     //  ... ... ...
-    inst_.strokegen_passes.dispatch_extract_mesh_contour(ob);
+    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob);
 
 
   }
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
index 5d0304865db..964ee4114e3 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -1,55 +1,11 @@
 
 /**
- * Sort the lights by their Z distance to the camera.
- * Outputs ordered light buffer.
- * One thread processes one Light entity.
+* Testing compute shader for bnpr engine.
  */
 
 #pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
 
 void main()
 {
-  // uint src_index = gl_GlobalInvocationID.x;
-  // bool valid_thread = true;
-//
-  // if (src_index >= light_cull_buf.visible_count) {
-  //   /* Do not return because we use barriers later on (which need uniform control flow).
-  //    * Just process the same last item but avoid insertion. */
-  //   src_index = light_cull_buf.visible_count - 1;
-  //   valid_thread = false;
-  // }
-//
-  // float local_zdist = in_zdist_buf[src_index];
-//
-  // int prefix_sum = 0;
-  // /* Iterate over the whole key buffer. */
-  // uint iter = divide_ceil(light_cull_buf.visible_count, gl_WorkGroupSize.x);
-  // for (uint i = 0u; i < iter; i++) {
-  //   uint index = gl_WorkGroupSize.x * i + gl_LocalInvocationID.x;
-  //   /* NOTE: This will load duplicated values, but they will be discarded. */
-  //   index = min(index, light_cull_buf.visible_count - 1);
-  //   zdists_cache[gl_LocalInvocationID.x] = in_zdist_buf[index];
-//
-  //   barrier();
-//
-  //   /* Iterate over the cache line. */
-  //   uint line_end = min(gl_WorkGroupSize.x, light_cull_buf.visible_count - gl_WorkGroupSize.x * i);
-  //   for (uint j = 0u; j < line_end; j++) {
-  //     if (zdists_cache[j] < local_zdist) {
-  //       prefix_sum++;
-  //     }
-  //     else if (zdists_cache[j] == local_zdist) {
-  //       /* Same depth, use index to order and avoid same prefix for 2 different lights. */
-  //       if ((gl_WorkGroupSize.x * i + j) < src_index) {
-  //         prefix_sum++;
-  //       }
-  //     }
-  //   }
-  // }
-//
-  // if (valid_thread) {
-  //   /* Copy sorted light to render light buffer. */
-  //   uint input_index = in_key_buf[src_index];
-  //   out_light_buf[prefix_sum] = in_light_buf[input_index];
-  // }
+
 }
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
index 0d1f735983d..bea2190c8d3 100644
--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -8,13 +8,16 @@
  * \{ */
 
 /* For details, see "gpu_shader_create_info.hh" */
-// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_comp)
+// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
   // .do_static_compilation(true)
 
   /* -------------------------------------------------------------------- */
   /* Name of other infos to recursively merge with this one.
    * No data slot must overlap otherwise we throw an error. */
   // .additional_info("eevee_shared", "draw_view", "draw_view_culling")
+
+  /* -------------------------------------------------------------------- */
+  /* Macros */
   // .define("DOF_BOKEH_TEXTURE", "false")
 
   /* -------------------------------------------------------------------- */
@@ -55,11 +58,10 @@
 
 
 
-
 /* -------------------------------------------------------------------- */
 /** \test
  * \{ */
-GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
+GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
   .do_static_compilation(true)
   .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
   .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
-- 
2.38.1.windows.1


From 43d5a077e025f45380709d56e6802c5de72ad384 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 8 Jan 2023 15:26:45 +0800
Subject: [PATCH 10/13] Testing scan & segscan

scan should be alright, however need to load with stride of vec4 when read scanned buffer with vec3 elements.

segscan not tested yet, there are some issue with shader_builder, which fucks up with the incremental build. I'll commit for now and rebase to master.
---
 source/blender/draw/CMakeLists.txt            |   4 +
 .../blender/draw/engines/bnpr/bnpr_defines.hh |  21 +-
 .../blender/draw/engines/bnpr/bnpr_engine.cc  |  15 +-
 .../draw/engines/bnpr/bnpr_instance.cc        |  19 +-
 .../draw/engines/bnpr/bnpr_instance.hh        |   5 +-
 .../blender/draw/engines/bnpr/bnpr_shader.cc  |  12 +
 .../blender/draw/engines/bnpr/bnpr_shader.hh  |   8 +
 .../draw/engines/bnpr/bnpr_shader_shared.hh   | 114 +++-
 .../bnpr/bnpr_strokegen_buffer_pool.cc        |  25 +-
 .../bnpr/bnpr_strokegen_buffer_pool.hh        |  14 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |  90 ++-
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 121 +++-
 source/blender/draw/engines/bnpr/bnpr_sync.cc |   4 +-
 .../bnpr/shaders/bnpr_hlsl_support_lib.glsl   |   8 +
 .../bnpr_scan_no_subgroup_codegen_lib.glsl    |  69 +++
 .../shaders/bnpr_scan_no_subgroup_lib.glsl    | 576 ++++++++++++++++++
 .../bnpr/shaders/bnpr_scan_test_comp.glsl     | 279 +++++++++
 .../shaders/bnpr_strokegen_test_comp.glsl     |   2 +-
 .../bnpr/shaders/infos/bnpr_test_info.hh      | 127 +++-
 19 files changed, 1476 insertions(+), 37 deletions(-)
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index e6885e1958d..a9d28e25192 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -704,7 +704,11 @@ set(GLSL_SRC
   engines/image/shaders/image_engine_depth_frag.glsl
   engines/image/shaders/image_engine_depth_vert.glsl
 
+  engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
+  engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
+  engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
   engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+  engines/bnpr/shaders/bnpr_scan_test_comp.glsl
 
   engines/bnpr/bnpr_defines.hh
   engines/bnpr/bnpr_shader_shared.hh
diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
index 1ffca605ca9..4cc48d0ddd0 100644
--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -11,5 +11,24 @@
 
 #pragma once
 
+#define GROUP_SIZE_STROKEGEN_TEST 512u
+#define GROUP_SIZE_BNPR_SCAN_TEST_SWEEP 1024u
+#define GROUP_SIZE_BNPR_SCAN_TEST_AGGRG 1024u
+
+#define NUM_ITEMS_BNPR_SCAN_TEST 1973581u
+
+
+#ifndef GPU_SHADER
+# define BNPR_SCAN_TEST_DATA_TYPE uint4
+# define BNPR_SCAN_TEST_DATA_TYPE_STR "uvec3"
+
+// remember to update SSBOData_SegScanTest if this changes
+# define BNPR_SEG_SCAN_TEST_STRUCT_TYPE SSBOData_SegScanTest
+# define BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR "SSBOData_SegScanTest"
+#endif
+
+
+
+
+
 
-#define GROUP_SIZE_STROKEGEN_TEST 512
diff --git a/source/blender/draw/engines/bnpr/bnpr_engine.cc b/source/blender/draw/engines/bnpr/bnpr_engine.cc
index 0e123f6e50c..aa4c039f772 100644
--- a/source/blender/draw/engines/bnpr/bnpr_engine.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_engine.cc
@@ -21,6 +21,7 @@
 
 #include "bnpr_instance.hh"
 #include "bnpr_shader.hh"
+#include "intern/mallocn_intern.h"
 
 
 using namespace blender;
@@ -131,22 +132,20 @@ static void bnpr_draw_scene(void *vedata)
 
 
   // TODO: not sure which is better, frame-buffer or texture list?
-  // DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
-  DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
+  DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
+  // DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
 
   const DRWView *default_view = DRW_view_default_get();
+  const DRWView *active_view = DRW_view_get_active();
   draw::Manager *manager = DRW_manager_get();
   draw::View view("DefaultView", default_view);
+
   // draw passes
-  ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
+  ved->instance->draw_viewport(*manager, view);
   // display error msg at the top of the render viewport
   STRNCPY(ved->info, ved->instance->info.c_str());
 
 
-
-  bnpr_draw_scene_legacy(vedata);
-
-
   /* Reset view for other following engines. */
   DRW_view_set_active(nullptr);
 }
@@ -384,7 +383,7 @@ static void bnpr_engine_free(void)
 
 static void bnpr_render_to_image(void *vedata, struct RenderEngine *engine,
                                     struct RenderLayer *layer,
-                                    const struct rcti *UNUSED(rect)) {
+                                    const struct rcti *rect) {
   UNUSED_VARS(vedata, engine, layer);
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index 46be7fd8d31..ecc7d8b9cf5 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -20,6 +20,7 @@
 #include "RE_pipeline.h"
 
 #include "bnpr_instance.hh"
+#include "bnpr_defines.hh"
 
 namespace blender::bnpr
 {
@@ -51,6 +52,7 @@ namespace blender::bnpr
     camera_orig_object = camera_object_;
 
     info = "";
+    frame_counter = 0;
   }
 
   void Instance::update_eval_members()
@@ -78,6 +80,8 @@ namespace blender::bnpr
   void Instance::begin_sync(Manager& manager)
   {
     /* Init draw passes and manager related stuff. (Begin render graph) */
+    strokegen_buffers.sync();
+    strokegen_passes.sync();
   }
 
   void Instance::end_sync(Manager&)
@@ -132,11 +136,20 @@ namespace blender::bnpr
   /** \name Rendering
    * \{ */
 
-  void Instance::draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
-    GPUTexture* color_tx)
+  void Instance::draw_viewport(Manager& manager, View& view)
   {
     /* Submit passes here. (Execute render graph) */
-    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::EXTRACT_MESH_CONTOUR), view);
+    // manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::SCAN_TEST), view);
+    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::SEGSCAN_TEST), view);
+
+    if (frame_counter % 32 == 0)
+    {
+      // strokegen_passes.validate_pass_scan_test<BNPR_SCAN_TEST_DATA_TYPE>(
+      //   [](const BNPR_SCAN_TEST_DATA_TYPE& a, const BNPR_SCAN_TEST_DATA_TYPE& b) {return a == b;}
+      // );
+    }
+    frame_counter = (frame_counter + 1) % 100000000;
+
   }
 
   /** \} */
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
index 6d7532c8ea3..af5be3f88a8 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -60,10 +60,12 @@ namespace blender::bnpr
 
 
 
+
     /** Info string displayed at the top of the render / viewport. */
     std::string info = "";
     /** Debug mode from debug value. */
     // eDebugMode debug_mode = eDebugMode::DEBUG_NONE;
+    uint frame_counter; // for debugging
 
 
 
@@ -87,8 +89,7 @@ namespace blender::bnpr
     void object_sync(Manager& manager, ObjectRef& object_ref);
 
 
-    void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
-                       GPUTexture* color_tx);
+    void draw_viewport(Manager& manager, View& view);
 
 
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
index c77bc4675fa..ff636462f65 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -92,6 +92,18 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
       return "basic_depth_pointcloud_conservative";
     case COMPUTE_TEST:
       return "bnpr_strokegen_test_xxx";
+    case SCAN_TEST_UPSWEEP:
+      return "bnpr_scan_test_upsweep";
+    case SCAN_TEST_AGGREGATE:
+      return "bnpr_scan_test_aggregate";
+    case SCAN_TEST_DWSWEEP:
+      return "bnpr_scan_test_dwsweep";
+    case SEGSCAN_TEST_UPSWEEP:
+      return "bnpr_segscan_test_upsweep";
+    case SEGSCAN_TEST_AGGREGATE:
+      return "bnpr_segscan_test_aggregate";
+    case SEGSCAN_TEST_DWSWEEP:
+      return "bnpr_segscan_test_dwsweep";
 
     /* To avoid compiler warning about missing case. */
     case MAX_SHADER_TYPE:
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
index ff758760c22..00e3e09625d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
@@ -31,6 +31,14 @@ enum eShaderType {
   DEPTH_CONSERVATIVE,
   POINTCLOUD_DEPTH_CONSERVATIVE,
 
+  SCAN_TEST_UPSWEEP,
+  SCAN_TEST_AGGREGATE,
+  SCAN_TEST_DWSWEEP,
+
+  SEGSCAN_TEST_UPSWEEP,
+  SEGSCAN_TEST_AGGREGATE,
+  SEGSCAN_TEST_DWSWEEP,
+
   MAX_SHADER_TYPE,
 };
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index 7b98d823540..b7e0c17e628 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -26,12 +26,122 @@ using namespace draw;
 #endif
 
 
+  static inline uint wang_hash(uint seed)
+  {
+    seed = (seed ^ 61) ^ (seed >> 16);
+    seed *= 9;
+    seed = seed ^ (seed >> 4);
+    seed *= 0x27d4eb2d;
+    seed = seed ^ (seed >> 15);
+    return seed;
+  }
+
+
+  static inline uint compute_num_threads(
+    uint numWorkItems,
+    uint numItemsPerThread = 1u, uint numThreadsPerItem = 1u
+  )
+  {
+    uint numThreads = numWorkItems;
+
+    if (numItemsPerThread != 1u)
+      numThreads = ((numWorkItems + numItemsPerThread - 1u) / numItemsPerThread);
+    else if (numThreadsPerItem != 1u)
+      numThreads = numThreadsPerItem * numWorkItems;
+
+    return numThreads;
+  }
+
+  static inline uint compute_num_groups(
+    uint numWorkItems, uint groupSize,
+    uint numItemsPerThread = 1u, uint numThreadsPerItem = 1u
+  )
+  {
+    const uint numThreads = compute_num_threads(
+      numWorkItems, numItemsPerThread,
+      numThreadsPerItem
+    );
+
+#if !defined(GPU_SHADER)
+    return math::max(1u, ((numThreads + groupSize - 1) / groupSize));
+#else
+      return max(1u, ((numThreads + groupSize - 1) / groupSize));
+#endif
+  }
+
+  static inline uint tree_seg_scan_encode_upsweep_hfs(uint hf_partialSum, uint hf_orig)
+  {
+    return ((hf_orig << 1) | hf_partialSum);
+  }
+
+  static inline void tree_seg_scan_decode_upsweep_hfs(
+#if !defined(GPU_SHADER)
+    uint hfs_encoded, uint& out_hf_orig, uint& out_hf_partialSum
+#else
+    uint hfs_encoded, out uint out_hf_orig, out uint out_hf_partialSum
+#endif
+  )
+  {
+    out_hf_partialSum = (hfs_encoded & 1);
+    hfs_encoded >>= 1;
+    out_hf_orig = (hfs_encoded & 1);
+  }
+
+  static inline uint tree_seg_scan_decode_upsweep_hfs_get_origHF(
+#if !defined(GPU_SHADER)
+    uint hfs_encoded
+#else
+    uint hfs_encoded
+#endif
+  )
+  {
+    hfs_encoded >>= 1;
+    return (hfs_encoded & 1);
+  }
+
+  static inline uint tree_seg_scan_decode_upsweep_hfs_get_sumHF(
+#if !defined(GPU_SHADER)
+    uint hfs_encoded
+#else
+    uint hfs_encoded
+#endif
+  )
+  {
+    return (hfs_encoded & 1);
+  }
+
+
+
+
+  struct UBData_TreeScan
+  {
+    uint num_scan_items;
+    uint num_valid_scan_threads;
+    uint num_thread_groups;
+    uint dummy;
+  };
+  BLI_STATIC_ASSERT_ALIGN(UBData_TreeScan, 16)
+
+  struct SSBOData_SegScanTest
+  {
+    uint hf;
+#ifndef GPU_SHADER
+    uint3 val;
+#else
+    uvec3 val;
+#endif
+  };
+  // BLI_STATIC_ASSERT_ALIGN(SSBOData_SegScanTest, 16)
+
+
 
 #ifdef __cplusplus
 
 // Template to set buffer size in compile time
-using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
-
+using SSBO_StrokeGenTest = draw::StorageArrayBuffer<uint, 4096 * 4, true>;
+using SSBO_BnprScanData = draw::StorageArrayBuffer<uint, 2048 * 2048 * 2, true>;
+using SSBO_BnprScanAggregates = draw::StorageArrayBuffer<uint, 512 * 16, true>;
+using UBO_BnprTreeScan = draw::UniformBuffer<UBData_TreeScan>;
 
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
index 39d96265894..76736b9be11 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
@@ -8,11 +8,34 @@
 
 #include "bnpr_strokegen_buffer_pool.hh"
 #include "bnpr_instance.hh"
+#include "bnpr_defines.hh"
 
 namespace blender::bnpr
 {
-  void GPUBufferPoolModule::sync(Object* object)
+  void GPUBufferPoolModule::sync()
   {
+    UBO_BnprTreeScan& ubo_tree_scan = ubo_bnpr_tree_scan_infos_;
+    {
+      ubo_tree_scan.num_scan_items = NUM_ITEMS_BNPR_SCAN_TEST;
+      ubo_tree_scan.num_valid_scan_threads = compute_num_threads(
+        NUM_ITEMS_BNPR_SCAN_TEST,
+        2u
+      );
+      ubo_tree_scan.num_thread_groups = compute_num_groups(
+        NUM_ITEMS_BNPR_SCAN_TEST,
+        GROUP_SIZE_BNPR_SCAN_TEST_SWEEP,
+        2u
+      );
+      ubo_tree_scan.dummy = 0u;
+    }
+    ubo_bnpr_tree_scan_infos_.push_update();
+
+
+  }
+
+  void GPUBufferPoolModule::sync_object(Object* ob)
+  {
+
   }
 
   void GPUBufferPoolModule::end_sync()
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
index cf017d0823f..c4f145aa3e1 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -23,14 +23,20 @@ namespace blender::bnpr
     Instance &instance;
 
     /** Compute Resources */
-    StrokeGenTestBuf strokegen_test_buf_;
+    SSBO_StrokeGenTest ssbo_bnpr_test_;
 
+    SSBO_BnprScanData ssbo_bnpr_in_scan_data_;
+    SSBO_BnprScanData ssbo_bnpr_out_scan_data_;
+    SSBO_BnprScanAggregates ssbo_bnpr_scan_block_sum_;
+
+    UBO_BnprTreeScan ubo_bnpr_tree_scan_infos_;
 
   public:
-    GPUBufferPoolModule(Instance &inst) : instance(inst) {};
-    ~GPUBufferPoolModule() {};
+    GPUBufferPoolModule(Instance &inst) : instance(inst) {}
+    ~GPUBufferPoolModule() {}
 
-    void sync(Object* object);
+    void sync();
+    void sync_object(Object* ob);
     void end_sync();
 
   };
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index 058198dac13..e302d2672dc 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -13,18 +13,94 @@ namespace blender::bnpr
 {
   using namespace blender;
 
-  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob)
+  void StrokeGenPassModule::sync()
   {
-    pass_comp_test.init();
-    {
-      auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
-      sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
-      sub.bind_ssbo("buf_test", buffers_.strokegen_test_buf_);
-      sub.dispatch(int3(32, 1, 1));
+    rebuild_pass_scan_test();
+    rebuild_pass_segscan_test();
+  }
+
+  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch)
+  {
+
+  }
+
+  void StrokeGenPassModule::rebuild_pass_scan_test()
+  {
+    pass_scan_test.init();
+    { // upsweep for tree-scan
+      auto& sub = pass_scan_test.sub("strokegen_scan_test_upsweep");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_UPSWEEP));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_in_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(2, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // reduction for tree-scan
+      auto& sub = pass_scan_test.sub("strokegen_scan_test_aggregate");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_AGGREGATE));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_scan_block_sum_);
+
+      sub.dispatch(int3(1, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // down sweep for tree-scan
+      auto& sub = pass_scan_test.sub("strokegen_scan_test_dwsweep");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_DWSWEEP));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
     }
   }
 
+  void StrokeGenPassModule::rebuild_pass_segscan_test()
+  {
+    pass_segscan_test.init();
+    { // upsweep for tree-scan
+      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_upsweep");
+      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_UPSWEEP));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_in_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(2, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // reduction for tree-scan
+      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_aggregate");
+      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_AGGREGATE));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_scan_block_sum_);
+
+      sub.dispatch(int3(1, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // down sweep for tree-scan
+      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_dwsweep");
+      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_DWSWEEP));
 
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
 
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+  }
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index 6663f38eec7..b2904d012df 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -26,6 +26,8 @@ namespace blender::bnpr
   private:
     /** Compute Passes */
     draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
+    draw::PassSimple pass_scan_test = {"Bnpr GPU Blelloch Scan Test"};
+    draw::PassSimple pass_segscan_test = {"Bnpr GPU Blelloch SegScan Test"};
 
     /** Instance */
     ShaderModule &shaders_;
@@ -49,20 +51,131 @@ namespace blender::bnpr
     /** Passes Batched by Usages */
     enum eType
     {
-      EXTRACT_MESH_CONTOUR = 0
+      SCAN_TEST = 0,
+      SEGSCAN_TEST
     };
 
     PassSimple& get_compute_pass(eType passType)
     {
       switch (passType) {
-        case EXTRACT_MESH_CONTOUR:
-          return pass_comp_test;
+        case SCAN_TEST:
+          return pass_scan_test;
+        case SEGSCAN_TEST:
+          return pass_segscan_test;
       }
       return pass_comp_test;
     }
 
-    void rebuild_pass_extract_mesh_contour(Object* ob);
+    void sync();
+    void rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch);
+    void rebuild_pass_scan_test();
+    void rebuild_pass_segscan_test();
+
+
+    template<typename T>
+    void validate_pass_scan_test(bool (*equals)(const T&, const T&));
+
+    template<typename T>
+    bool validate_inter_block_exclusive_scan(
+      const T* bufferInputVals, const T* bufferPrefixSum,
+      bool (*equals)(const T&, const T&),
+      uint num_scan_items, uint blk_size, uint numBlocks
+    );
+    template<typename T>
+    bool validate_exclusive_scan(
+      const T* bufferInputVals, const T* bufferPrefixSum,
+      bool (*equals)(const T&, const T&),
+      uint num_scan_items
+    );
+
 
   };
+
+
+
+  template <typename T>
+  void StrokeGenPassModule::validate_pass_scan_test(bool (*equals)(const T&, const T&))
+  {
+    SSBO_BnprScanData& buf_scan_inputs = buffers_.ssbo_bnpr_in_scan_data_;
+    buf_scan_inputs.read();
+    T* data_scan_inputs = reinterpret_cast<T*>(buf_scan_inputs.data());
+
+    SSBO_BnprScanData& buf_scan_output = buffers_.ssbo_bnpr_out_scan_data_;
+    buf_scan_output.read();
+    T* data_scan_output = reinterpret_cast<T*>(buf_scan_output.data());
+
+    bool valid_inter_block_scan = StrokeGenPassModule::validate_inter_block_exclusive_scan<T>(
+      data_scan_inputs, data_scan_output,
+      equals,
+      buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items,
+      GROUP_SIZE_BNPR_SCAN_TEST_SWEEP * 2u,
+      buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups
+    );
+    if (!valid_inter_block_scan)
+      fprintf(stderr, "bnpr: error: INTER-BLOCK scan test failed");
+
+    bool valid_global_scan = StrokeGenPassModule::validate_exclusive_scan<T>(
+      data_scan_inputs, data_scan_output,
+      equals,
+      buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items
+    );
+    if (!valid_global_scan)
+      fprintf(stderr, "bnpr: error: GLOBAL scan test failed");
+  }
+
+
+  template <typename T>
+  bool StrokeGenPassModule::validate_inter_block_exclusive_scan(
+    const T* const bufferInputVals, const T* const bufferPrefixSum,
+    bool (*equals)(const T&, const T&),
+    uint num_scan_items, uint blk_size, uint numBlocks
+  )
+  {
+    Vector<int> failedElems(0);
+
+    for (uint blk_id = 0u; blk_id < numBlocks; blk_id++)
+    {
+      for (uint blk_offset = 0u; blk_offset < blk_size - 1u; blk_offset++)
+      {
+        // index might go out of bound
+        uint index = blk_id * blk_size + blk_offset;
+        if (index >= num_scan_items - 2u)
+          break;
+
+        if (false == equals(
+          bufferPrefixSum[index] + bufferInputVals[index],
+          bufferPrefixSum[index + 1]
+        ))
+        {
+          failedElems.append(index);
+        }
+      }
+    }
+
+    if (!failedElems.is_empty())
+    {
+      return false;
+    }
+
+    return true;
+  }
+
+
+  template <typename T>
+  bool StrokeGenPassModule::validate_exclusive_scan(const T* bufferInputVals,
+                                                    const T* bufferPrefixSum,
+                                                    bool (* equals)(const T&, const T&),
+                                                    uint num_scan_items)
+  {
+    return validate_inter_block_exclusive_scan(
+      bufferInputVals, bufferPrefixSum,
+      equals,
+      num_scan_items,
+      num_scan_items,
+      1
+    );
+  }
+
+
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index f350911e958..cd708ab9fb2 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -64,6 +64,7 @@ namespace blender::bnpr
     GPUBatch *geobatch = DRW_cache_object_edge_detection_get(ob, &mesh_is_manifold);
 
     if (geobatch == nullptr) return;
+    if (geobatch->elem == nullptr) return;
 
     // Old way to do this:
     // See "draw_subdiv_build_tris_buffer"
@@ -74,7 +75,8 @@ namespace blender::bnpr
     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
     //  strokegen_passes.dispatch_XXX(...);
     //  ... ... ...
-    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob);
+    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob, geobatch);
+
 
 
   }
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
new file mode 100644
index 00000000000..6a8328140c5
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
@@ -0,0 +1,8 @@
+#ifndef BNPR_HLSL_SUPPORT_INCLUDED
+#define BNPR_HLSL_SUPPORT_INCLUDED
+
+// translate bit stream(s)
+#define asuint(x) floatBitsToUint(x)
+#define asfloat(x) uintBitsToFloat(x)
+
+#endif
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
new file mode 100644
index 00000000000..d1d65d6364e
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
@@ -0,0 +1,69 @@
+#ifndef BNPR_SCAN_NO_SUBGROUP_CODEGEN_LIB
+#define BNPR_SCAN_NO_SUBGROUP_CODEGEN_LIB
+
+#pragma BLENDER_REQUIRE(bnpr_scan_no_subgroup_lib.glsl)
+
+/* -------------------------------------------------------------------- */
+/** \name Tree Scan LDS Cache
+ * \{ */
+DECLARE_TREE_SCAN_CACHE
+
+#ifdef IS_TREE_SEG_SCAN
+
+	DECLARE_TREE_SCAN_CACHE_HF
+
+#endif
+/** \} */
+
+
+
+/* -------------------------------------------------------------------- */
+/** \name Utility Functions
+ * \{ */
+DECLARE_TREE_SCAN_INDEXING_FUNCTION
+
+DECLARE_TREE_SCAN_FUNC_CLEAN_SCAN_DATA
+
+DECLARE_TREE_SCAN_FUNC_CLEAN_SEG_SCAN_DATA
+
+/** \} */
+
+
+
+
+#ifndef IS_TREE_SEG_SCAN
+/* -------------------------------------------------------------------- */
+/** \name Scan Functions
+ * \{ */
+DECLARE_TREE_SCAN_FUNC_BLOCK
+
+DECLARE_TREE_SCAN_FUNC_AGGREGATE
+
+/** \} */
+#endif
+
+
+
+
+
+#ifdef IS_TREE_SEG_SCAN
+/* -------------------------------------------------------------------- */
+/** \name Segmented Tree Scan Functions
+ * \{ */
+
+DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP_FILL_CACHE
+
+DECLARE_TREE_SEGSCAN_FUNC_AGGREGATE_FILL_CACHE
+
+DECLARE_TREE_SEGSCAN_FUNC_UPSWEEP
+
+DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP
+
+/** \} */
+#endif
+
+
+
+
+
+#endif
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
new file mode 100644
index 00000000000..aaaecd11e34
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
@@ -0,0 +1,576 @@
+#pragma BLENDER_REQUIRE(bnpr_hlsl_support_lib.glsl)
+
+#ifndef BNPR_SCAN_NO_SUBGROUP_INCLUDED
+#define BNPR_SCAN_NO_SUBGROUP_INCLUDED
+
+/* Scan Operators */
+uint u32_add(uint a, uint b)
+{
+	return a + b;
+}
+uvec2 uvec2_add(uvec2 a, uvec2 b)
+{
+	return a + b;
+}
+uvec3 uvec3_add(uvec3 a, uvec3 b)
+{
+	return a + b;
+}
+uvec4 uvec4_add(uvec4 a, uvec4 b)
+{
+	return a + b;
+}
+float f32_add(float a, float b)
+{
+	return a + b;
+}
+
+
+
+
+
+/* Inputs ---------------------                                                       */
+/* Example:                                                                           */
+/* (- basic -)                                                                        */
+/* #define SCAN_DATA_TYPE uvec2			    // Input data type for scan operation        */
+/* #define SCAN_OP(a, b) (a + b)				  // Scan operation                            */
+/* #define SCAN_ZERO_VAL                // Zero value for scan operator               */
+/* #define SCAN_BLOCK_SIZE 256			      // Typically thread_group_size               */
+/* #define SCAN_FUNCTION_TAG ScanTest   // Alias name for this set of scan ops        */
+/* ---------------------------------------                                            */
+
+
+/* Macro expansion, for details, see
+/* ---------------------------------------
+/* https://stackoverflow.com/questions/1489932/how-to-concatenate-twice-with-the-c-preprocessor-and-expand-a-macro-as-in-arg */
+#define CAT(x, y) CAT_(x, y)
+#define CAT_(x, y) x ## y
+
+
+/* Type & Type conversion & Scan OP
+/* --------------------------------------- */
+#define T SCAN_DATA_TYPE
+#define tag SCAN_FUNCTION_TAG
+#define OP SCAN_OP
+
+
+/* thread group size provided in glsl
+/* --------------------------------------- */
+#ifdef SCAN_BLOCK_SIZE
+# undef SCAN_BLOCK_SIZE
+#endif
+#define SCAN_BLOCK_SIZE ((gl_WorkGroupSize.x))
+
+#define DATA_SIZE       ((2u * SCAN_BLOCK_SIZE))
+
+
+/* Padding Macros for Eliminating Bank Conflicts
+/* --------------------------------------------------------- */
+#define NUM_BANKS       32
+#define LOG_NUM_BANKS   5
+#define OFFSET_BANK_CONFLICT_FREE(x) (((x) >> LOG_NUM_BANKS))
+
+
+// Tree Scan LDS Caches
+// ------------------------------------------------------------
+#define TREE_SCAN_CACHE CAT(TreeScanCache, tag)
+#define TREE_SCAN_CACHE_SIZE (DATA_SIZE + DATA_SIZE / NUM_BANKS)
+#define TREE_SCAN_CACHE_HF CAT(TreeScanCacheHF, tag)
+
+
+#define DECLARE_TREE_SCAN_CACHE \
+	shared T TREE_SCAN_CACHE[TREE_SCAN_CACHE_SIZE]; \
+
+#define DECLARE_TREE_SCAN_CACHE_HF \
+	shared uint TREE_SCAN_CACHE_HF[TREE_SCAN_CACHE_SIZE]; \
+
+
+
+// Tree Scan
+// ------------------------------------------------------------
+struct TreeScanIndices
+{
+  uvec2 global_x2; /* index of element in global compute buffer */
+  uvec2 lds_x2;    /* index of element 0/1 in shared memory */
+};
+
+/**
+ * \brief Returns (Global_scanAddr0, Global_scanAddr1, LDS_scanAddr0, LDS_scanAddr1)
+ *			LDS_scanAddr0/1 : index of element 0/1 in shared memory
+ *			Global_scanAddr0/1 : index of element in global compute buffer
+ */
+#define DECLARE_TREE_SCAN_INDEXING_FUNCTION                                                             \
+TreeScanIndices GetTreeScanIndices(					                                                        \
+	uint groupIdx, uint gIdx					                                                              \
+){  																				                                         \
+	const uint groupOffset = (DATA_SIZE) * gIdx.x;									                             \
+                                                                                                        \
+	uint ai = groupIdx;                /*   0   1   2   3 ... 255  => ai	*/	                          \
+	/* ------ + 1 * 512 ------- (Suppose gIdx.x == 1)						*/		                          \
+	uint scanAddrA = groupOffset + ai; /* 512 513 514 515 ... 767  => scanAddrA	*/	                    \
+                                                                                                        \
+	uint bi = ai + DATA_SIZE / 2; /* 256 257 258 259 ... 511   => bi			*/	                          \
+	uint scanAddrB = groupOffset + bi; /* 768 641 642 643 ... 1151  => scanAddrB*/	                    \
+                                                                                                        \
+	return TreeScanIndices(uvec2(scanAddrA, scanAddrB), uvec2(ai, bi));						                 \
+}                                                                                                       \
+
+
+#define _FUNC_CLEAN_SCAN_DATA CAT(TreeScanCleanData, tag)
+/**
+ * \brief Clear item that not mapped to actual scanned data
+ */
+#define DECLARE_TREE_SCAN_FUNC_CLEAN_SCAN_DATA \
+void _FUNC_CLEAN_SCAN_DATA( \
+    TreeScanIndices scan_ids,       \
+    uint num_scanned_items,         \
+    inout T scan_data_A,            \
+    inout T scan_data_B             \
+){ \
+  if (scan_ids.global_x2.x >= num_scanned_items)        \
+    scan_data_A = SCAN_ZERO_VAL;                        \
+  if (scan_ids.global_x2.y >= num_scanned_items)        \
+    scan_data_B = SCAN_ZERO_VAL;                        \
+} \
+
+
+#define _FUNC_CLEAN_SEG_SCAN_DATA CAT(TreeScanCleanData, tag)
+/**
+ * \brief Clear item that not mapped to actual scanned data
+ */
+#define DECLARE_TREE_SCAN_FUNC_CLEAN_SEG_SCAN_DATA \
+void _FUNC_CLEAN_SEG_SCAN_DATA( \
+	TreeScanIndices scan_ids,       \
+	uint num_scanned_items,         \
+	inout uint hf_A,                \
+	inout T scan_data_A,            \
+	inout uint hf_B,                \
+	inout T scan_data_B             \
+){ \
+	if (scan_ids.global_x2.x >= num_scanned_items)        \
+	{ \
+		scan_data_A = SCAN_ZERO_VAL;                       \
+		hf_A = 1u;                                         \
+	} \
+	if (scan_ids.global_x2.y >= num_scanned_items)        \
+	{ \
+		scan_data_B = SCAN_ZERO_VAL;                       \
+		hf_B = 1u;                                         \
+	} \
+} \
+
+
+#define _FUNC_TREE_SCAN_BLOCK CAT(TreeScanBlockExc, tag)
+/**
+ * \brief Declares a block-wise exclusive tree scan function.
+ */
+#define DECLARE_TREE_SCAN_FUNC_BLOCK \
+void _FUNC_TREE_SCAN_BLOCK( \
+    uint groupIdx,                    \
+    uint gIdx,                        \
+    T initialData_A,                  \
+    T initialData_B,                  \
+    out T scanRes_A,                  \
+    out T scanRes_B                   \
+){ \
+  TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);						           \
+  uint ai = scanAddrs.lds_x2.x;                                                        \
+  uint bi = scanAddrs.lds_x2.y;                                                        \
+  /* Bank Offset == index >> bits_banks(5 in Nvidia card) */                         \
+  uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);                                       \
+  uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);                                       \
+                                                                                       \
+  /*  Store data into LDS with memory bank offset                                      \
+  ---------------------------------------------------------------------                \
+  about 'tailvalue':                                                                   \
+  in prefix sum, last elem is going to be erased                                       \
+  but we will need it later, so cache it here */                                       \
+  TREE_SCAN_CACHE[ai + aiOffset] = initialData_A;                                      \
+  TREE_SCAN_CACHE[bi + biOffset] = initialData_B;                                      \
+  /* about LDS memory layout:                                                          \
+  Interleaved storage,                                                                 \
+  that is, ith(i % 32 == 0) is not used;                                               \
+  e.g:                                                                                 \
+  [0, 31]  X [32, 63] X  [64, 95]  X [96, 127]  -- Input CBuffer                       \
+      + 0________+1___________+2___________+3 ... -- + OFFSET_BANK...(x)               \
+  [0, 31] 32 [33, 64] 65 [66, 97] 98 [99, 130]  -- TREE_SCAN_CACHE                   */\
+  \
+  \
+  \
+  /* //////////////////////////////////////////////////////////////////////// */       \
+  /* Scan --- Phase II        Up-Sweeping                                     */       \
+  /* Work Indices:                                                            */       \
+  /* offset = 2^k                                                             */       \
+  /* a(i, k) = (2^k) * (2i + 1) - 1 = (2*gidx)*offset + offset - 1            */       \
+  /* b(i, k) = a(i, k) + 2^k = a(i, k) + offset                               */       \
+  /* i ~ groupIdx, k ~ iteration, all start from 0.                           */       \
+  uint offset = 1;     /* Step Length == 2^k */                                        \
+  uint d = DATA_SIZE / 2u; /* [0, ... , d]th threads are dispatched */           \
+  for (; d > 0; d >>= 1){                                                       \
+      barrier();                                                                \
+      if (groupIdx < d){                                                        \
+          ai = offset * (2 * groupIdx + 1) - 1;                                 \
+          bi = offset * (2 * groupIdx + 2) - 1;                                 \
+          ai += OFFSET_BANK_CONFLICT_FREE(ai);                                  \
+          bi += OFFSET_BANK_CONFLICT_FREE(bi);                                  \
+                                                                                \
+          TREE_SCAN_CACHE[bi] = OP(TREE_SCAN_CACHE[ai], TREE_SCAN_CACHE[bi]);		\
+      }                                                                         \
+      offset *= 2;                                                              \
+  }                                                                             \
+  \
+  \
+  \
+  /* ////////////////////////////////////////////////////////////////////////*/ \
+  /* Phase III */                                                               \
+  if (groupIdx == 0)                                                            \
+  {                                                                             \
+      /* Zero out last elem, prepare for up-sweeping */                         \
+      uint lastIndex = DATA_SIZE - 1 + OFFSET_BANK_CONFLICT_FREE(DATA_SIZE - 1);\
+      TREE_SCAN_CACHE[lastIndex] = SCAN_ZERO_VAL;                               \
+  }                                                                             \
+  \
+  \
+  \
+  /* ///////////////////////////////////////////////////////////////////////// */ \
+  /* Phase IV                 Down-Sweeping                                    */ \
+  /* Util this point,                                                          */ \
+  /* d == 0,                                                                   */ \
+  /* offset == GROUP_SIZE * 2 == DATA_SIZE                                     */ \
+  /* This is actually "rolling back + mirror" version of Phase I,              */ \
+  /* So this execution code is a mirrored loop                                 */ \
+  for (d = 1; d < DATA_SIZE; d *= 2){                                              \
+      offset >>= 1;                                                                \
+      barrier();                                           \
+      if (groupIdx < d){                                                           \
+          /* So the indexing function is the same, (rolling back)                  \
+          just the roles of ai & bi are switched                              */   \
+          ai = offset * (2 * groupIdx + 1) - 1;                                    \
+          bi = offset * (2 * groupIdx + 2) - 1;                                    \
+          ai += OFFSET_BANK_CONFLICT_FREE(ai);                                     \
+          bi += OFFSET_BANK_CONFLICT_FREE(bi);                                     \
+          /* swap */                                                               \
+          T aiValOld = TREE_SCAN_CACHE[ai];                                        \
+          TREE_SCAN_CACHE[ai] = TREE_SCAN_CACHE[bi];                               \
+          TREE_SCAN_CACHE[bi] = OP(aiValOld, TREE_SCAN_CACHE[bi]);                 \
+      }                                                                            \
+  }                                                                                \
+  barrier();                                               \
+  \
+  \
+  \
+  T pSumAtAi = TREE_SCAN_CACHE[groupIdx + aiOffset];                               \
+  T pSumAtBi = TREE_SCAN_CACHE[groupIdx + SCAN_BLOCK_SIZE + biOffset];             \
+  \
+  \
+  scanRes_A = pSumAtAi;                                     \
+  scanRes_B = pSumAtBi;                                     \
+} \
+
+
+#define _FUNC_TREE_SCAN_AGGREGATE CAT(TreeScanBlockAggregate, tag)
+/**
+ \brief Second step for tree scan.
+ *  Apply exclusive scan on
+ *  inclusive sums from each scanned data-block.
+*/
+#define DECLARE_TREE_SCAN_FUNC_AGGREGATE \
+void _FUNC_TREE_SCAN_AGGREGATE( \
+  uint groupIdx,        \
+  uint gIdx,            \
+  T aggregateA,         \
+  T aggregateB,         \
+  out T aggSumA,        \
+  out T aggSumB         \
+) \
+{				                    \
+  _FUNC_TREE_SCAN_BLOCK	        \
+  (			                    \
+    groupIdx,                   \
+    gIdx,                       \
+    aggregateA,                 \
+    aggregateB,                 \
+    aggSumA, /*out*/            \
+    aggSumB  /*out*/            \
+  );			                    \
+} \
+
+
+
+
+
+
+/* -------------------------------------------------------------------- */
+/** \name Segmented Tree Scan
+ *
+ * \{ */
+#define _FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE CAT(TreeSegScanExc_DwSweep_FillLDS_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP_FILL_CACHE	\
+void _FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(	\
+	uint groupId, 					\
+	TreeScanIndices scanAddrs, 	  \
+	/* --- LDS inputs --- */ 	     \
+	uint encodedHFs_A,	           \
+	T partialSum_A,	              \
+	uint encodedHFs_B,	           \
+	T partialSum_B,	              \
+	T aggregateScanRes 				  \
+) {																																\
+	uint ai = scanAddrs.lds_x2.x;																			            \
+	uint bi = scanAddrs.lds_x2.y;																			            \
+	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
+	\
+	/*  Store data into LDS with memory bank offset								 	\
+	--------------------------------------------------------------------- 	\
+	about 'tailvalue':																		   \
+	in prefix sum, last elem is going to be erased								   \
+	but we will need it later, so cache it here                          */	\
+	uint cacheAddrAi = ai + aiOffset;																              \
+	uint cacheAddrBi = bi + biOffset;																              \
+	TREE_SCAN_CACHE[cacheAddrAi] = partialSum_A;													              \
+	TREE_SCAN_CACHE_HF[cacheAddrAi] = encodedHFs_A;													           \
+	/* Different from normal down-sweep that zeros out last elem, */								     \
+	/* We use output from prev inter-block scan kernel instead */									     \
+	TREE_SCAN_CACHE[cacheAddrBi] =                                                                 \
+		(groupId == SCAN_BLOCK_SIZE - 1)                                                            \
+			? aggregateScanRes : partialSum_B;	                                                     \
+	TREE_SCAN_CACHE_HF[cacheAddrBi] = encodedHFs_B;													           \
+} \
+
+
+#define _FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE CAT(TreeSegScanExc_Aggregate_FillLDS_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_AGGREGATE_FILL_CACHE \
+void _FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE( \
+	uint groupId, 					\
+	TreeScanIndices scanAddrs, \
+	/* --- LDS inputs --- */ 	\
+	uint firstInitialHFAi,	   \
+	uint firstInitialHFBi	   \
+){ \
+	uint ai = scanAddrs.lds_x2.x;																			            \
+	uint bi = scanAddrs.lds_x2.y;																			            \
+	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
+	uint cacheAddrAi = ai + aiOffset;																               \
+	uint cacheAddrBi = bi + biOffset;																               \
+	if (groupId == 0u)                                                                              \
+	{                                                                                               \
+		/* Zero out last elem, prepare for up-sweeping */                                          \
+		uint lastIndex = DATA_SIZE - 1 + OFFSET_BANK_CONFLICT_FREE(DATA_SIZE - 1);                   \
+		TREE_SCAN_CACHE[lastIndex] = SCAN_ZERO_VAL;                                                  \
+	}                                                                                               \
+	barrier();                                                                                      \
+	                                                                                                \
+	/* Compared to normal seg-scan,						  */                                            \
+	/* need to encode original hfs differently here */                                            \
+	TREE_SCAN_CACHE_HF[cacheAddrAi] = tree_seg_scan_encode_upsweep_hfs(                             \
+		TREE_SCAN_CACHE_HF[cacheAddrAi], firstInitialHFAi                                            \
+	);                                                                                              \
+	TREE_SCAN_CACHE_HF[cacheAddrBi] = tree_seg_scan_encode_upsweep_hfs(                             \
+		TREE_SCAN_CACHE_HF[cacheAddrBi], firstInitialHFBi                                            \
+	);                                                                                              \
+}
+
+
+#define _FUNC_TREE_SEG_SCAN_UPSWEEP CAT(TreeSegScanExc_UpSweep_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_UPSWEEP	\
+void _FUNC_TREE_SEG_SCAN_UPSWEEP(	\
+	uint groupIdx,				        \
+	uint gIdx,                      \
+	/* --- scan inputs --- */ 	  \
+	uint headFlagAi,	              \
+	T initialDataAi,	              \
+	uint headFlagBi,	              \
+	T initialDataBi,	              \
+	/* --- block partial sums --- */ \
+ 	out uint headFlagPartialSum_A,  \
+	out T partialSum_A,		        \
+	out uint headFlagPartialSum_B,  \
+	out T partialSum_B		        \
+) \
+{ \
+	/* -------------------------------------------------------	*/									      \
+	/* nAddr:													*/									                     \
+	/* .x: Global_scanAddr0, .y: Global_scanAddr1, 				*/									         \
+	/* .z: LDS_scanAddr0, .w: LDS_scanAddr1						*/									            \
+	TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);									      \
+	uint ai = scanAddrs.lds_x2.x;																			            \
+	uint bi = scanAddrs.lds_x2.y;																			            \
+																																	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
+																																	\
+	/*  Store data into LDS with memory bank offset								 \
+	--------------------------------------------------------------------- \
+	about 'tailvalue':																		\
+	in prefix sum, last elem is going to be erased								\
+	but we will need it later, so cache it here                          */	\
+	uint cacheAddrAi = ai + aiOffset;																               \
+	uint cacheAddrBi = bi + biOffset;																               \
+	TREE_SCAN_CACHE[cacheAddrAi] = initialDataAi;													            \
+	TREE_SCAN_CACHE_HF[cacheAddrAi] = headFlagAi;													            \
+	TREE_SCAN_CACHE[cacheAddrBi] = initialDataBi;													            \
+	TREE_SCAN_CACHE_HF[cacheAddrBi] = headFlagBi;													            \
+	/* about LDS memory layout:																		               \
+	Interleaved storage,																			                  \
+	that is, ith(i % 32 == 0) is not used;															            \
+	e.g:																							                        \
+	[0, 31]  X [32, 63] X  [64, 95]  X [96, 127]  -- Input CBuffer									      \
+		+ 0________+1___________+2___________+3 ... -- + OFFSET_BANK...(x)							   \
+	[0, 31] 32 [33, 64] 65 [66, 97] 98 [99, 130]  -- TREE_SCAN_CACHE			*/					      \
+                                                                                                	\
+                                                                                                	\
+	/* //////////////////////////////////////////////////////////////////////// */					\
+	/* Scan --- Phase II        Up-Sweeping                                     */					\
+	/* Work Indices:                                                            */					\
+	/* offset = 2^k                                                             */					\
+	/* a(i, k) = (2^k) * (2i + 1) - 1 = (2*gidx)*offset + offset - 1            */					\
+	/* b(i, k) = a(i, k) + 2^k = a(i, k) + offset                               */					\
+	/* i ~ groupIdx, k ~ iteration, all start from 0.                           */					\
+	uint offset = 1u; /* Step Length == 2^k */														            \
+	uint d = DATA_SIZE / 2u; /* [0, ... , d]th threads are dispatched */								   \
+                                                                                                   \
+	bool activeThread;																				                  \
+	for (; d > 0; d >>= 1)																			                  \
+	{																								                        \
+		activeThread = groupIdx < d;																                  \
+																																	\
+		ai = offset * (2u * groupIdx + 1u) - 1u;														            \
+		bi = offset * (2u * groupIdx + 2u) - 1u;														            \
+		ai += OFFSET_BANK_CONFLICT_FREE(ai);														               \
+		bi += OFFSET_BANK_CONFLICT_FREE(bi);														               \
+																																	\
+		barrier();															                                       \
+		bool isSegHeadAtBi = (0u != (1u & TREE_SCAN_CACHE_HF[bi]));												\
+		if (activeThread && (!isSegHeadAtBi))														               \
+		{																							                        \
+			TREE_SCAN_CACHE[bi] = OP(TREE_SCAN_CACHE[ai], TREE_SCAN_CACHE[bi]);						      \
+		}																							                        \
+		barrier();															                                       \
+	                                                                                                \
+		TREE_SCAN_CACHE_HF[bi] = activeThread																		   \
+			? uint(isSegHeadAtBi || bool(TREE_SCAN_CACHE_HF[ai]))												   \
+			: uint(isSegHeadAtBi);																		               \
+                                                                                                   \
+		offset *= 2u;																				                     \
+	}																								                        \
+                                                                                                   \
+	barrier();																                                       \
+                                                                                                   \
+																																	\
+	partialSum_A = TREE_SCAN_CACHE[cacheAddrAi];													               \
+	partialSum_B = TREE_SCAN_CACHE[cacheAddrBi];													               \
+	headFlagPartialSum_A = TREE_SCAN_CACHE_HF[cacheAddrAi];											         \
+	headFlagPartialSum_B = TREE_SCAN_CACHE_HF[cacheAddrBi];											         \
+} \
+
+
+#define _FUNC_TREE_SEG_SCAN_DWSWEEP CAT(TreeSegScanExc_DwSweep_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP	\
+void _FUNC_TREE_SEG_SCAN_DWSWEEP( \
+	uint groupIdx,	                  \
+	uint gIdx,		                  \
+	/* --- scan results --- */ \
+	out T scanResult_A,	            \
+	out T scanResult_B	            \
+) \
+{																									            \
+	/* Addressing & Data Loading											*/					         \
+	/* scanAddrs:																*/					         \
+	/* -- .x: Global_scanAddr0, .y: Global_scanAddr1, 			*/				            \
+	/* -- .z: LDS_scanAddr0,    .w: LDS_scanAddr1					*/					         \
+	TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);                     \
+	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */                        \
+	uint ai = scanAddrs.lds_x2.x;																			\
+	uint bi = scanAddrs.lds_x2.y;																			\
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													\
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													\
+	\
+	/*  Store data into LDS with memory bank offset												\
+	/* instead should call "_FUNC_TREE_SEG_SCAN_FILL_CACHE"                            \
+	* ---------------------------------------------------------------------				\
+	* about 'tailvalue':																				   \
+	* in prefix sum, last elem is going to be erased												\
+	* but we will need it later, so cache it here */					                     \
+	uint cacheAddrAi = ai + aiOffset;																   \
+	uint cacheAddrBi = bi + biOffset;																   \
+	/**TREE_SCAN_CACHE[cacheAddrAi] = partialSum_A;		*/										\
+	/**TREE_SCAN_CACHE_HF[cacheAddrAi] = encodedHFs_A;	*/										\
+	/**TREE_SCAN_CACHE[cacheAddrBi] = partialSum_B;		*/										\
+	/**TREE_SCAN_CACHE_HF[cacheAddrBi] = encodedHFs_B;	*/										\
+	\
+	\
+	/* ///////////////////////////////////////////////////////////////////////// */	\
+	/* Phase IV                 Down-Sweeping                                    */	\
+	/* Util this point,                                                          */	\
+	/* d == 0,                                                                   */	\
+	/* offset == GROUP_SIZE * 2 == DATA_SIZE                                     */	\
+	/* This is actually "rolling back + mirror" version of Phase I,              */	\
+	/* So this execution code is a mirrored loop                                 */	\
+	uint offset = DATA_SIZE;																		      \
+	uint d = 0u;																						      \
+	bool activeThread;																				      \
+	for (d = 1u; d < DATA_SIZE; d *= 2u)																\
+	{																								            \
+		offset >>= 1;																				         \
+		/* So the indexing function is the same, (rolling back)	                    \
+		 * just the roles of ai & bi are switched */                                   \
+		ai = offset * (2u * groupIdx + 1u) - 1u;														\
+		bi = offset * (2u * groupIdx + 2u) - 1u;														\
+		uint aiNext = ai + 1u + OFFSET_BANK_CONFLICT_FREE(ai + 1u);						      \
+		ai += OFFSET_BANK_CONFLICT_FREE(ai);														   \
+		bi += OFFSET_BANK_CONFLICT_FREE(bi);														   \
+	                                                                                    \
+		activeThread = groupIdx < d;																      \
+		                                                                                 \
+		barrier();															                           \
+		T valAi = TREE_SCAN_CACHE[ai];																   \
+		T valBi = TREE_SCAN_CACHE[bi];																   \
+		                                                                                 \
+		barrier();															                           \
+		if (activeThread) /* swap */																      \
+			TREE_SCAN_CACHE[ai] = valBi;															      \
+		                                                                                 \
+		barrier();															                           \
+		uint origHFAiNext = /*DECODE_ORIG_HF(TREE_SCAN_CACHE_HF[aiNext]);*/            \
+			tree_seg_scan_decode_upsweep_hfs_get_origHF(TREE_SCAN_CACHE_HF[aiNext]);	   \
+		uint currHFAi = /**DECODE_CURR_HF(TREE_SCAN_CACHE_HF[ai]);*/							\
+			tree_seg_scan_decode_upsweep_hfs_get_sumHF(TREE_SCAN_CACHE_HF[ai]);           \
+		                                                                                 \
+		if (activeThread)																			         \
+		{																							            \
+			TREE_SCAN_CACHE[bi] = (origHFAiNext == 1u)                                    \
+ 				? SCAN_ZERO_VAL : ((currHFAi == 1u) ? valAi : OP(valAi, valBi));           \
+		}																							            \
+		                                                                                 \
+		barrier();															                           \
+		/* Clear partial sum hf, keep original flag */										   \
+		TREE_SCAN_CACHE_HF[ai] &= 0x00000002u;														   \
+	}																								            \
+	                                                                                    \
+	barrier();																                           \
+	                                                                                    \
+	scanResult_A = TREE_SCAN_CACHE[cacheAddrAi];                                        \
+	scanResult_B = TREE_SCAN_CACHE[cacheAddrBi];                                        \
+} \
+
+
+
+/** \} */
+
+
+
+
+#endif
+
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
new file mode 100644
index 00000000000..30b1fc097a8
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
@@ -0,0 +1,279 @@
+#pragma BLENDER_REQUIRE(bnpr_scan_no_subgroup_codegen_lib.glsl)
+
+
+/* input buffers:
+ * -----------------------------------------------
+ * BnprScanDataBuf        bnpr_in_scan_data_buf_
+ * BnprScanDataBuf        bnpr_out_scan_data_buf_
+ * BnprScanBlockSumBuf    bnpr_scan_block_sum_buf_
+*/
+
+#define T_To_Uint(x) x
+#define Uint_To_T(x) x
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP)
+void main()
+{
+  const uint groupId =  gl_LocalInvocationID.x;
+
+  TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+  T scanval_A, scanval_B;
+  { /* init & store random scan input vals */
+    scanval_A = T(
+      wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
+    );
+    scanval_B = T(
+      wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
+    );
+    /* avoid invalid loads */
+    _FUNC_CLEAN_SCAN_DATA(
+      scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
+      scanval_A, scanval_B /* <- inout */
+    );
+    bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanval_A);
+    bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanval_B);
+  }
+
+
+
+  /* execute block-wise exlusive scan */
+  T scanRes_ai, scanRes_bi;
+  _FUNC_TREE_SCAN_BLOCK(
+        groupId,
+        gl_WorkGroupID.x,
+        scanval_A,
+        scanval_B,
+        /* -out- */
+        scanRes_ai,
+        scanRes_bi
+  );
+
+  /* store scan results */
+  bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanRes_ai);
+  bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanRes_bi);
+
+  /* store block aggregate */
+  if (groupId == gl_WorkGroupSize.x - 1)
+  {
+    bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = /**floatBitsToUint*/(SCAN_OP(scanRes_bi, scanval_B));
+  }
+}
+#endif
+
+
+
+
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE)
+void main()
+{
+  const uint groupId =  gl_LocalInvocationID.x;
+  const uint gIdx =     gl_WorkGroupID.x;
+
+  TreeScanIndices scanAddrs = GetTreeScanIndices(groupId, 0);
+  T aggregate_A = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x]);
+  T aggregate_B = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y]);
+
+  T aggregateSum_A, aggregateSum_B;
+  _FUNC_TREE_SCAN_AGGREGATE(
+	  groupId,
+	  gIdx,
+	  aggregate_A,
+	  aggregate_B,
+	  aggregateSum_A,
+	  aggregateSum_B
+  );
+
+  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x] = /**floatBitsToUint*/(aggregateSum_A);
+  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y] = /**floatBitsToUint*/(aggregateSum_B);
+
+
+}
+#endif
+
+
+
+
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP)
+void main()
+{
+	const uint groupId = gl_LocalInvocationID.x;
+	const uint gIdx = gl_WorkGroupID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	T block_scan_res_A, block_scan_res_B;
+	block_scan_res_A = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2[0]]);
+	block_scan_res_B = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2[1]]);
+
+	T aggregate_sum = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
+
+	bnpr_out_scan_data_buf_[scan_ids.global_x2[0]] = /**floatBitsToUint*/(SCAN_OP(aggregate_sum, block_scan_res_A));
+	bnpr_out_scan_data_buf_[scan_ids.global_x2[1]] = /**floatBitsToUint*/(SCAN_OP(aggregate_sum, block_scan_res_B));
+}
+#endif
+
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_UPSWEEP)
+void main()
+{
+	const uint groupId =  gl_LocalInvocationID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	T scanval_A, scanval_B;
+	uint hf_A, hf_B;
+	{ /* init & store random scan input vals */
+		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
+		scanval_A = T(
+			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
+		);
+		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
+		scanval_B = T(
+			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
+		);
+		/* avoid invalid loads */
+		_FUNC_CLEAN_SEG_SCAN_DATA(
+			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
+			hf_A, scanval_A, hf_B, scanval_B /* <- inout */
+		);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(hf_A, scanval_A);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(hf_B, scanval_B);
+	}
+
+
+
+	/* execute block-wise exlusive scan */
+	uint headFlagPartialSum_A, headFlagPartialSum_B;
+	T scanRes_ai, scanRes_bi;
+	_FUNC_TREE_SEG_SCAN_UPSWEEP(
+		groupId,
+		gl_WorkGroupID.x,
+		hf_A, 						scanval_A,
+		hf_B, 						scanval_B,
+		/* -out- */
+		headFlagPartialSum_A, 	scanRes_ai,
+		headFlagPartialSum_B, 	scanRes_bi
+	);
+
+	/* store scan results */
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(
+		tree_seg_scan_encode_upsweep_hfs(hf_A, headFlagPartialSum_A),
+		scanRes_ai
+	);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(
+		tree_seg_scan_encode_upsweep_hfs(hf_B, headFlagPartialSum_B),
+		scanRes_bi
+	);
+
+	/* store block aggregate */
+	if (groupId == gl_WorkGroupSize.x - 1)
+	{
+		bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = SEGSCAN_STRUCT_TYPE(
+			tree_seg_scan_encode_upsweep_hfs(
+				headFlagPartialSum_B,  /* or sum of block hfs */
+				TREE_SCAN_CACHE_HF[0]  /* original hf of block */
+			),
+			/* different from ordinary scan, we store exclusive sum here */
+			scanval_B
+		);
+	}
+}
+#endif
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_AGGREGATE)
+void main()
+{
+	const uint groupId = gl_LocalInvocationID.x;
+	const uint gIdx = gl_WorkGroupID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, 0);
+
+	SEGSCAN_STRUCT_TYPE aggregate_A = bnpr_scan_block_sum_buf_[scan_ids.global_x2.x];
+	T partialSumTreeAi = aggregate_A.val;
+	uint partialOrTreeAi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_A.hf);
+	uint firstInitialHFAi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_A.hf);
+
+	SEGSCAN_STRUCT_TYPE aggregate_B = bnpr_scan_block_sum_buf_[scan_ids.global_x2.y];
+	T partialSumTreeBi = aggregate_B.val;
+	uint partialOrTreeBi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_B.hf);
+	uint firstInitialHFBi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_B.hf);
+
+	T upsweep_res_sum_A, upsweep_res_sum_B;
+	uint upsweep_res_hf_A, upsweep_res_hf_B;
+	_FUNC_TREE_SEG_SCAN_UPSWEEP(
+		groupId,
+		gl_WorkGroupID.x,
+		partialOrTreeAi, partialSumTreeAi,
+		partialOrTreeBi, partialSumTreeBi,
+		/* -out- */
+		upsweep_res_hf_A, upsweep_res_sum_A,
+		upsweep_res_hf_B, upsweep_res_sum_B
+	);
+
+
+
+	_FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE(
+		groupId, scan_ids,
+		/* --- LDS inputs --- */
+		firstInitialHFAi, firstInitialHFBi
+	);
+
+
+
+	T scan_res_A, scan_res_B;
+	_FUNC_TREE_SEG_SCAN_DWSWEEP
+	(
+		groupId, gIdx,
+		/* --- out --- */
+		scan_res_A, scan_res_B
+	);
+
+
+	/* store scan results */
+	bnpr_scan_block_sum_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(0, scan_res_A); /* no hf needed */
+	bnpr_scan_block_sum_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(0, scan_res_B); /* no hf needed */
+}
+#endif
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_DWSWEEP)
+void main()
+{
+	const uint groupId = gl_LocalInvocationID.x;
+	const uint gIdx = gl_WorkGroupID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	SEGSCAN_STRUCT_TYPE block_scan_res_A, block_scan_res_B, aggregate_scan_res;
+	block_scan_res_A = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2.x]);
+	block_scan_res_B = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2.y]);
+	aggregate_scan_res = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
+
+	_FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(
+		groupId, scan_ids,
+		/* --- block partial sums --- */
+		block_scan_res_A.hf, block_scan_res_A.val,
+		block_scan_res_B.hf, block_scan_res_B.val,
+		/* --- scanned block aggregate --- */
+		aggregate_scan_res.val
+	);
+
+	T scan_res_A, scan_res_B;
+	_FUNC_TREE_SEG_SCAN_DWSWEEP
+	(
+		groupId, gIdx,
+		/* --- out --- */
+		scan_res_A, scan_res_B
+	);
+
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(block_scan_res_A.hf, scan_res_A);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(block_scan_res_B.hf, scan_res_B);
+}
+#endif
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
index 964ee4114e3..b34970b05d3 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -7,5 +7,5 @@
 
 void main()
 {
-
+  buf_test[0] = buf_ibo[0];
 }
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
index bea2190c8d3..410ed1085ac 100644
--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -57,14 +57,135 @@
 /** \} */
 
 
+/* -------------------------------------------------------------------- */
+/** \shared shader infos
+ * \{ */
+GPU_SHADER_CREATE_INFO(bnpr_scan_uint_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uint")
+  .define("SCAN_OP", "u32_add")
+  .define("SCAN_ZERO_VAL", "0u")
+  .define("SCAN_FUNCTION_TAG", "_u32_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_uvec2_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uvec2")
+  .define("SCAN_OP", "uvec2_add")
+  .define("SCAN_ZERO_VAL", "uvec2(0u, 0u)")
+  .define("SCAN_FUNCTION_TAG", "uvec2_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_uvec3_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uvec3")
+  .define("SCAN_OP", "uvec3_add")
+  .define("SCAN_ZERO_VAL", "uvec3(0u, 0u, 0u)")
+  .define("SCAN_FUNCTION_TAG", "uvec3_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_uvec4_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uvec4")
+  .define("SCAN_OP", "uvec4_add")
+  .define("SCAN_ZERO_VAL", "uvec4(0u, 0u, 0u, 0u)")
+  .define("SCAN_FUNCTION_TAG", "uvec4_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_float_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "float")
+  .define("SCAN_OP", "f32_add")
+  .define("SCAN_ZERO_VAL", ".0f")
+  .define("SCAN_FUNCTION_TAG", "_f32_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_inputs)
+  .additional_info("bnpr_scan_uvec3_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_inputs)
+  .additional_info("bnpr_scan_uvec3_add")
+  .define("SEGSCAN_STRUCT_TYPE", "SSBOData_SegScanTest")
+;
+
 
 /* -------------------------------------------------------------------- */
-/** \test
+/** \test shaders
  * \{ */
 GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
   .do_static_compilation(true)
-  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
+  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test[]")
+  .storage_buf(1, Qualifier::READ, "uint", "buf_ibo[]")
   .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
-  .compute_source("bnpr_strokegen_test_comp.glsl");
+  .compute_source("bnpr_strokegen_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_upsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_scan_test_inputs")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_in_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(2, Qualifier::WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_aggregate)
+  .do_static_compilation(true)
+  .additional_info("bnpr_scan_test_inputs")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_dwsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_scan_test_inputs")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_upsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_segscan_test_inputs")
+  .define("IS_TREE_SEG_SCAN", "1")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_UPSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_in_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(2, Qualifier::WRITE,       BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_aggregate)
+  .do_static_compilation(true)
+  .additional_info("bnpr_segscan_test_inputs")
+  .define("IS_TREE_SEG_SCAN", "1")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_AGGREGATE", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_dwsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_segscan_test_inputs")
+  .define("IS_TREE_SEG_SCAN",                             "1")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_DWSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
 
 /** \} */
-- 
2.38.1.windows.1


From ce1b4301d24dc432ac5016f6b596c4870515db0c Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Thu, 12 Jan 2023 00:07:25 +0800
Subject: [PATCH 11/13] Learning ssbo alignment

---
 source/blender/draw/engines/bnpr/bnpr_defines.hh     |  2 +-
 .../engines/bnpr/shaders/bnpr_scan_test_comp.glsl    | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
index 4cc48d0ddd0..f56a53922e9 100644
--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -19,7 +19,7 @@
 
 
 #ifndef GPU_SHADER
-# define BNPR_SCAN_TEST_DATA_TYPE uint4
+# define BNPR_SCAN_TEST_DATA_TYPE uint3
 # define BNPR_SCAN_TEST_DATA_TYPE_STR "uvec3"
 
 // remember to update SSBOData_SegScanTest if this changes
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
index 30b1fc097a8..62d535037b5 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
@@ -129,14 +129,14 @@ void main()
 	T scanval_A, scanval_B;
 	uint hf_A, hf_B;
 	{ /* init & store random scan input vals */
-		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
-		scanval_A = T(
+		hf_A = 0xffffffff; /**uint(scan_ids.global_x2.x % 3u == 0u);*/ /**1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);*/
+		scanval_A = T(scan_ids.global_x2.x); /**T(
 			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
-		);
-		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
-		scanval_B = T(
+		);*/
+		hf_B = 0xffffffff;/**uint(scan_ids.global_x2.y % 3u == 0u);*//**1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u)*/;
+		scanval_B = T(scan_ids.global_x2.y); /**T(
 			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
-		);
+		);*/
 		/* avoid invalid loads */
 		_FUNC_CLEAN_SEG_SCAN_DATA(
 			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
-- 
2.38.1.windows.1


From 08c0fee814cbf6a3b5fde914ff19bbf5da0a65d9 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Thu, 12 Jan 2023 22:09:58 +0800
Subject: [PATCH 12/13] Use correct uve3 padding

dont use { uint, uvec3 }
instead use { uvec3, uint }
---
 group-of-patches.mbx                          | 5950 +++++++++++++++++
 .../draw/engines/bnpr/bnpr_shader_shared.hh   |    2 +-
 .../bnpr/shaders/bnpr_scan_test_comp.glsl     |   40 +-
 3 files changed, 5972 insertions(+), 20 deletions(-)
 create mode 100644 group-of-patches.mbx

diff --git a/group-of-patches.mbx b/group-of-patches.mbx
new file mode 100644
index 00000000000..7ef7b8d2f0a
--- /dev/null
+++ b/group-of-patches.mbx
@@ -0,0 +1,5950 @@
+From 216725151c9a50fa6d2c2eb756e143a4b9fadfd2 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sat, 3 Dec 2022 16:46:19 +0800
+Subject: [PATCH 01/11] strokegen engine basic framework try#1
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+implemented based on BasicEngine, EEVEE Next, and the code snippet given by Clément Foucault.
+
+Including
+1) the integration into blender ui,
+2) instance(empty yet)
+3) shader module
+---
+ source/blender/draw/CMakeLists.txt            |   8 +
+ .../shaders/infos/strokegen_depth_info.hh     |  65 +++
+ .../shaders/strokegen_depth_curves_vert.glsl  |  27 ++
+ .../shaders/strokegen_depth_frag.glsl         |   5 +
+ .../strokegen_depth_pointcloud_vert.glsl      |  15 +
+ .../shaders/strokegen_depth_vert.glsl         |  14 +
+ .../strokgen_conservative_depth_geom.glsl     |  51 +++
+ .../engines/strokegen/strokegen_engine.cc     | 413 ++++++++++++++++++
+ .../draw/engines/strokegen/strokegen_engine.h |  31 ++
+ .../engines/strokegen/strokegen_instance.cc   |  29 ++
+ .../engines/strokegen/strokegen_instance.hh   |  75 ++++
+ .../engines/strokegen/strokegen_shader.cc     | 119 +++++
+ .../engines/strokegen/strokegen_shader.hh     |  62 +++
+ source/blender/draw/intern/draw_manager.c     |   4 +
+ 14 files changed, 918 insertions(+)
+ create mode 100644 source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
+ create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
+ create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
+ create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
+ create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
+ create mode 100644 source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_engine.cc
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_engine.h
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_instance.cc
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_instance.hh
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader.cc
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader.hh
+
+diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
+index 2093c8a2331..76bdd97ae20 100644
+--- a/source/blender/draw/CMakeLists.txt
++++ b/source/blender/draw/CMakeLists.txt
+@@ -208,6 +208,11 @@ set(SRC
+   engines/overlay/overlay_viewer_attribute.cc
+   engines/overlay/overlay_volume.cc
+   engines/overlay/overlay_wireframe.cc
++  engines/strokegen/strokegen_engine.cc
++  engines/strokegen/strokegen_shader.cc
++  engines/strokegen/strokegen_instance.cc
++
++
+ 
+   DRW_engine.h
+   DRW_pbvh.h
+@@ -297,6 +302,9 @@ set(SRC
+   engines/select/select_private.h
+   engines/overlay/overlay_engine.h
+   engines/overlay/overlay_private.hh
++  engines/strokegen/strokegen_engine.h
++  engines/strokegen/strokegen_shader.hh
++  engines/strokegen/strokegen_instance.hh
+ )
+ 
+ set(LIB
+diff --git a/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
+new file mode 100644
+index 00000000000..e275d208c7a
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
+@@ -0,0 +1,65 @@
++/* SPDX-License-Identifier: GPL-2.0-or-later */
++
++#include "gpu_shader_create_info.hh"
++
++/* -------------------------------------------------------------------- */
++/** \name Conservative Rasterization
++ *
++ * Allow selection of sub-pixel objects.
++ * \{ */
++
++GPU_SHADER_CREATE_INFO(basic_conservative)
++    .geometry_layout(PrimitiveIn::TRIANGLES, PrimitiveOut::TRIANGLE_STRIP, 3)
++    .geometry_source("basic_conservative_depth_geom.glsl");
++
++/** \} */
++
++/* -------------------------------------------------------------------- */
++/** \name Object types
++ * \{ */
++
++GPU_SHADER_CREATE_INFO(basic_mesh)
++    .vertex_in(0, Type::VEC3, "pos")
++    .vertex_source("basic_depth_vert.glsl")
++    .additional_info("draw_mesh");
++
++GPU_SHADER_CREATE_INFO(basic_pointcloud)
++    .vertex_source("basic_depth_pointcloud_vert.glsl")
++    .additional_info("draw_pointcloud");
++
++GPU_SHADER_CREATE_INFO(basic_curves)
++    .vertex_source("basic_depth_curves_vert.glsl")
++    .additional_info("draw_hair");
++/** \} */
++
++/* -------------------------------------------------------------------- */
++/** \name Variations Declaration
++ * \{ */
++
++#define BASIC_FINAL_VARIATION(name, ...) \
++  GPU_SHADER_CREATE_INFO(name).additional_info(__VA_ARGS__).do_static_compilation(true);
++
++#define BASIC_CLIPPING_VARIATIONS(prefix, ...) \
++  BASIC_FINAL_VARIATION(prefix##_clipped, "drw_clipped", __VA_ARGS__) \
++  BASIC_FINAL_VARIATION(prefix, __VA_ARGS__)
++
++#define BASIC_CONSERVATIVE_VARIATIONS(prefix, ...) \
++  BASIC_CLIPPING_VARIATIONS(prefix##_conservative, "basic_conservative", __VA_ARGS__) \
++  BASIC_CLIPPING_VARIATIONS(prefix, __VA_ARGS__)
++
++#define BASIC_OBTYPE_VARIATIONS(prefix, ...) \
++  BASIC_CONSERVATIVE_VARIATIONS(prefix##_mesh, "basic_mesh", __VA_ARGS__) \
++  BASIC_CONSERVATIVE_VARIATIONS(prefix##_pointcloud, "basic_pointcloud", __VA_ARGS__) \
++  BASIC_CLIPPING_VARIATIONS(prefix##_curves, "basic_curves", __VA_ARGS__)
++
++/** \} */
++
++/* -------------------------------------------------------------------- */
++/** \name Depth shader types.
++ * \{ */
++
++GPU_SHADER_CREATE_INFO(basic_depth).fragment_source("basic_depth_frag.glsl");
++
++BASIC_OBTYPE_VARIATIONS(basic_depth, "basic_depth", "draw_globals");
++
++/** \} */
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
+new file mode 100644
+index 00000000000..b0da9754fc6
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
+@@ -0,0 +1,27 @@
++
++#pragma BLENDER_REQUIRE(common_hair_lib.glsl)
++#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
++#pragma BLENDER_REQUIRE(common_view_lib.glsl)
++
++void main()
++{
++  GPU_INTEL_VERTEX_SHADER_WORKAROUND
++
++  bool is_persp = (ProjectionMatrix[3][3] == 0.0);
++  float time, thick_time, thickness;
++  vec3 world_pos, tan, binor;
++  hair_get_pos_tan_binor_time(is_persp,
++                              ModelMatrixInverse,
++                              ViewMatrixInverse[3].xyz,
++                              ViewMatrixInverse[2].xyz,
++                              world_pos,
++                              tan,
++                              binor,
++                              time,
++                              thickness,
++                              thick_time);
++
++  gl_Position = point_world_to_ndc(world_pos);
++
++  view_clipping_distances(world_pos);
++}
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
+new file mode 100644
+index 00000000000..ff4a015c335
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
+@@ -0,0 +1,5 @@
++
++void main()
++{
++  /* Passthrough shader. */
++}
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
+new file mode 100644
+index 00000000000..b82edc61cee
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
+@@ -0,0 +1,15 @@
++
++#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
++#pragma BLENDER_REQUIRE(common_view_lib.glsl)
++#pragma BLENDER_REQUIRE(common_pointcloud_lib.glsl)
++
++void main()
++{
++  GPU_INTEL_VERTEX_SHADER_WORKAROUND
++
++  vec3 world_pos = pointcloud_get_pos();
++
++  gl_Position = point_world_to_ndc(world_pos);
++
++  view_clipping_distances(world_pos);
++}
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
+new file mode 100644
+index 00000000000..7046979cf97
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
+@@ -0,0 +1,14 @@
++
++#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
++#pragma BLENDER_REQUIRE(common_view_lib.glsl)
++
++void main()
++{
++  GPU_INTEL_VERTEX_SHADER_WORKAROUND
++
++  vec3 world_pos = point_object_to_world(pos);
++
++  gl_Position = point_world_to_ndc(world_pos);
++
++  view_clipping_distances(world_pos);
++}
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl b/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
+new file mode 100644
+index 00000000000..73b171e5cb6
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
+@@ -0,0 +1,51 @@
++#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
++#pragma BLENDER_REQUIRE(common_view_lib.glsl)
++
++/* Adaptation of Conservative Rasterization
++ * from GPU Gems 2
++ * Using method 2.
++ *
++ * Actual final implementation does not do conservative rasterization and only
++ * avoids triangles producing no fragments.
++ */
++
++void main()
++{
++  /* Compute plane normal in NDC space. */
++  vec3 pos0 = gl_in[0].gl_Position.xyz / gl_in[0].gl_Position.w;
++  vec3 pos1 = gl_in[1].gl_Position.xyz / gl_in[1].gl_Position.w;
++  vec3 pos2 = gl_in[2].gl_Position.xyz / gl_in[2].gl_Position.w;
++  vec3 plane = normalize(cross(pos1 - pos0, pos2 - pos0));
++  /* Compute NDC bound box. */
++  vec4 bbox = vec4(min(min(pos0.xy, pos1.xy), pos2.xy), max(max(pos0.xy, pos1.xy), pos2.xy));
++  /* Convert to pixel space. */
++  bbox = (bbox * 0.5 + 0.5) * sizeViewport.xyxy;
++  /* Detect failure cases where triangles would produce no fragments. */
++  bvec2 is_subpixel = lessThan(bbox.zw - bbox.xy, vec2(1.0));
++  /* View aligned triangle. */
++  const float threshold = 0.00001;
++  bool is_coplanar = abs(plane.z) < threshold;
++
++  for (int i = 0; i < 3; i++) {
++    gl_Position = gl_in[i].gl_Position;
++    if (all(is_subpixel)) {
++      vec2 ofs = (i == 0) ? vec2(-1.0) : ((i == 1) ? vec2(2.0, -1.0) : vec2(-1.0, 2.0));
++      /* HACK: Fix cases where the triangle is too small make it cover at least one pixel. */
++      gl_Position.xy += sizeViewportInv * gl_Position.w * ofs;
++    }
++    /* Test if the triangle is almost parallel with the view to avoid precision issues. */
++    else if (any(is_subpixel) || is_coplanar) {
++      /* HACK: Fix cases where the triangle is Parallel to the view by deforming it slightly. */
++      vec2 ofs = (i == 0) ? vec2(-1.0) : ((i == 1) ? vec2(1.0, -1.0) : vec2(1.0));
++      gl_Position.xy += sizeViewportInv * gl_Position.w * ofs;
++    }
++    else {
++      /* Triangle expansion should happen here, but we decide to not implement it for
++       * depth precision & performance reasons. */
++    }
++
++    view_clipping_distances_set(gl_in[i]);
++    EmitVertex();
++  }
++  EndPrimitive();
++}
+diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/strokegen/strokegen_engine.cc
+new file mode 100644
+index 00000000000..b4267ce42f5
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_engine.cc
+@@ -0,0 +1,413 @@
++/* SPDX-License-Identifier: GPL-2.0-or-later
++ * Copyright 2016 Blender Foundation. */
++
++/** \file
++ * \ingroup draw_engine
++ *
++ * Simple engine for drawing color and/or depth.
++ * When we only need simple flat shaders.
++ */
++
++#include "DRW_render.h"
++
++#include "BKE_object.h"
++#include "BKE_paint.h"
++
++#include "BLI_alloca.h"
++
++#include "GPU_shader.h"
++
++#include "strokegen_engine.h"
++
++#include "strokegen_instance.hh"
++#include "strokegen_shader.hh"
++
++
++using namespace blender;
++
++
++
++#define STROKEGEN_ENGINE "BLENDER_STROKEGEN"
++
++/* *********** LISTS *********** */
++
++/* GPUViewport.storage
++ * Is freed every time the viewport engine changes. */
++typedef struct STROKEGEN_StorageList {
++  struct STROKEGEN_PrivateData *g_data;
++} STROKEGEN_StorageList;
++
++typedef struct STROKEGEN_PassList {
++  struct DRWPass *depth_pass[2];
++  struct DRWPass *depth_pass_pointcloud[2];
++  struct DRWPass *depth_pass_cull[2];
++} STROKEGEN_PassList;
++
++// Per-engine data
++// Sent by draw manager to the draw-engine.
++typedef struct STROKEGEN_Data {
++  void *engine_type;
++  DRWViewportEmptyList *fbl;
++  DRWViewportEmptyList *txl;
++  STROKEGEN_PassList *psl;
++  STROKEGEN_StorageList *stl;
++
++  strokegen::Instance *instance;
++  char info[GPU_INFO_SIZE];
++
++} STROKEGEN_Data;
++
++/* *********** STATIC *********** */
++
++typedef struct STROKEGEN_PrivateData {
++  DRWShadingGroup *depth_shgrp[2];
++  DRWShadingGroup *depth_shgrp_cull[2];
++  DRWShadingGroup *depth_hair_shgrp[2];
++  DRWShadingGroup *depth_curves_shgrp[2];
++  DRWShadingGroup *depth_pointcloud_shgrp[2];
++  bool use_material_slot_selection;
++} STROKEGEN_PrivateData; /* Transient data */
++
++
++
++static bool check_strokegen_support()
++{
++  return GPU_shader_storage_buffer_objects_support();
++}
++
++
++static void strokegen_engine_init(void *vedata)
++{
++  if (!check_strokegen_support()) { return; }
++
++  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
++  if (ved->instance == nullptr) {
++    ved->instance = new strokegen::Instance();
++  }
++
++  const DRWContextState *ctx_state = DRW_context_state_get();
++  ved->instance->init(ctx_state->depsgraph, ctx_state->v3d);
++}
++
++
++
++static void strokegen_draw_scene_legacy(void *vedata)
++{
++  STROKEGEN_PassList *psl = ((STROKEGEN_Data *)vedata)->psl;
++
++  DRW_draw_pass(psl->depth_pass[0]);
++  DRW_draw_pass(psl->depth_pass_pointcloud[0]);
++  DRW_draw_pass(psl->depth_pass_cull[0]);
++  DRW_draw_pass(psl->depth_pass[1]);
++  DRW_draw_pass(psl->depth_pass_pointcloud[1]);
++  DRW_draw_pass(psl->depth_pass_cull[1]);
++}
++
++static void strokegen_draw_scene(void *vedata)
++{
++  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
++  if (!check_strokegen_support()) {
++    STRNCPY(ved->info, "Error: No shader storage buffer support, required by StrokeGen.");
++    return;
++  }
++
++
++  // TODO: not sure which is better, frame-buffer or texture list?
++  // DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
++  DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
++
++  const DRWView *default_view = DRW_view_default_get();
++  draw::Manager *manager = DRW_manager_get();
++  draw::View view("DefaultView", default_view);
++  ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
++
++
++  strokegen_draw_scene_legacy(vedata);
++
++
++  /* Reset view for other following engines. */
++  DRW_view_set_active(nullptr);
++}
++
++
++
++
++static void strokegen_cache_init_legacy(void *vedata)
++{
++  STROKEGEN_PassList *psl = static_cast<STROKEGEN_Data*>(vedata)->psl;
++  STROKEGEN_StorageList *stl = static_cast<STROKEGEN_Data*>(vedata)->stl;
++  DRWShadingGroup *grp;
++
++  const DRWContextState *draw_ctx = DRW_context_state_get();
++
++  if (!stl->g_data) {
++    /* Alloc transient pointers */
++    stl->g_data = (STROKEGEN_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
++  }
++
++  stl->g_data->use_material_slot_selection = DRW_state_is_material_select();
++
++  /* Twice for normal and in front objects. */
++  for (int i = 0; i < 2; i++) {
++    DRWState clip_state = static_cast<DRWState>(
++      (draw_ctx->sh_cfg == GPU_SHADER_CFG_CLIPPED) ? DRW_STATE_CLIP_PLANES : 0
++    );
++    DRWState infront_state = static_cast<DRWState>(
++      (DRW_state_is_select() && (i == 1)) ? DRW_STATE_IN_FRONT_SELECT : 0
++    );
++    DRWState state = DRW_STATE_WRITE_DEPTH | DRW_STATE_DEPTH_LESS_EQUAL;
++
++    blender::strokegen::ShaderModule* shaderModule =
++      blender::strokegen::ShaderModule::module_get();
++
++    GPUShader *sh = DRW_state_is_select() ?
++                        shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
++                        shaderModule->static_shader_get(blender::strokegen::DEPTH);
++
++    DRW_PASS_CREATE(psl->depth_pass[i], state | clip_state | infront_state);
++    stl->g_data->depth_shgrp[i] = grp = DRW_shgroup_create(sh, psl->depth_pass[i]);
++    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
++
++    sh = DRW_state_is_select() ?
++        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH_CONSERVATIVE) :
++        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH);
++    DRW_PASS_CREATE(psl->depth_pass_pointcloud[i], state | clip_state | infront_state);
++    stl->g_data->depth_pointcloud_shgrp[i] = grp = DRW_shgroup_create(
++        sh, psl->depth_pass_pointcloud[i]);
++    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
++
++    stl->g_data->depth_hair_shgrp[i] = grp = DRW_shgroup_create(
++        shaderModule->static_shader_get(blender::strokegen::DEPTH), psl->depth_pass[i]);
++    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
++
++    stl->g_data->depth_curves_shgrp[i] = grp = DRW_shgroup_create(
++        shaderModule->static_shader_get(blender::strokegen::CURVES_DEPTH), psl->depth_pass[i]);
++    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
++
++    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
++                                 shaderModule->static_shader_get(blender::strokegen::DEPTH);
++    state |= DRW_STATE_CULL_BACK;
++    DRW_PASS_CREATE(psl->depth_pass_cull[i], state | clip_state | infront_state);
++    stl->g_data->depth_shgrp_cull[i] = grp = DRW_shgroup_create(sh, psl->depth_pass_cull[i]);
++    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
++  }
++}
++static void strokegen_cache_init(void *vedata)
++{
++  if (!check_strokegen_support()) return;
++
++  draw::Manager* drwmgr = DRW_manager_get();
++  reinterpret_cast<STROKEGEN_Data *>(vedata)->instance->begin_sync(*drwmgr);
++
++
++  strokegen_cache_init_legacy(vedata);
++}
++
++
++
++
++
++
++
++
++
++/* TODO(fclem): DRW_cache_object_surface_material_get needs a refactor to allow passing NULL
++ * instead of gpumat_array. Avoiding all this boilerplate code. */
++static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
++{
++  const int materials_len = DRW_cache_object_material_count_get(ob);
++  struct GPUMaterial **gpumat_array =
++    static_cast<GPUMaterial**>(BLI_array_alloca(gpumat_array, materials_len));
++  memset(gpumat_array, 0, sizeof(*gpumat_array) * materials_len);
++
++  return DRW_cache_object_surface_material_get(ob, gpumat_array, materials_len);
++}
++
++static void strokegen_cache_populate_particles(void *vedata, Object *ob)
++{
++  // do nothing here.
++}
++
++static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
++{
++  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
++
++  /* TODO(fclem): fix selection of smoke domains. */
++
++  if (!DRW_object_is_renderable(ob) || (ob->dt < OB_SOLID)) {
++    return;
++  }
++
++  const DRWContextState *draw_ctx = DRW_context_state_get();
++  if (ob != draw_ctx->object_edit) {
++    strokegen_cache_populate_particles(vedata, ob);
++  }
++
++  const bool do_in_front = (ob->dtx & OB_DRAW_IN_FRONT) != 0;
++  if (ob->type == OB_CURVES) {
++    DRW_shgroup_curves_create_sub(ob, stl->g_data->depth_curves_shgrp[do_in_front], NULL);
++  }
++
++  /* Make flat object selectable in ortho view if wireframe is enabled. */
++  if ((draw_ctx->v3d->overlay.flag & V3D_OVERLAY_WIREFRAMES) ||
++      (draw_ctx->v3d->shading.type == OB_WIRE) || (ob->dtx & OB_DRAWWIRE) || (ob->dt == OB_WIRE)) {
++    int flat_axis = 0;
++    bool is_flat_object_viewed_from_side = ((draw_ctx->rv3d->persp == RV3D_ORTHO) &&
++                                            DRW_object_is_flat(ob, &flat_axis) &&
++                                            DRW_object_axis_orthogonal_to_view(ob, flat_axis));
++
++    if (is_flat_object_viewed_from_side) {
++      /* Avoid losing flat objects when in ortho views (see T56549) */
++      struct GPUBatch *geom = DRW_cache_object_all_edges_get(ob);
++      if (geom) {
++        DRW_shgroup_call(stl->g_data->depth_shgrp[do_in_front], geom, ob);
++      }
++      return;
++    }
++  }
++
++  const bool use_sculpt_pbvh = BKE_sculptsession_use_pbvh_draw(ob, draw_ctx->rv3d) &&
++                               !DRW_state_is_image_render();
++  const bool do_cull = (draw_ctx->v3d &&
++                        (draw_ctx->v3d->shading.flag & V3D_SHADING_BACKFACE_CULLING));
++
++  DRWShadingGroup *shgrp = NULL;
++
++  if (ob->type == OB_POINTCLOUD) {
++    shgrp = stl->g_data->depth_pointcloud_shgrp[do_in_front];
++  }
++  else {
++    shgrp = (do_cull) ? stl->g_data->depth_shgrp_cull[do_in_front] :
++                        stl->g_data->depth_shgrp[do_in_front];
++  }
++
++  if (use_sculpt_pbvh) {
++    DRW_shgroup_call_sculpt(shgrp, ob, false, false, false, false, false);
++  }
++  else {
++    if (stl->g_data->use_material_slot_selection && BKE_object_supports_material_slots(ob)) {
++      struct GPUBatch **geoms = strokegen_object_surface_material_get(ob);
++      if (geoms) {
++        const int materials_len = DRW_cache_object_material_count_get(ob);
++        for (int i = 0; i < materials_len; i++) {
++          if (geoms[i] == NULL) {
++            continue;
++          }
++          const short material_slot_select_id = i + 1;
++          DRW_select_load_id(ob->runtime.select_id | (material_slot_select_id << 16));
++          DRW_shgroup_call(shgrp, geoms[i], ob);
++        }
++      }
++    }
++    else {
++      struct GPUBatch *geom = DRW_cache_object_surface_get(ob);
++      if (geom) {
++        DRW_shgroup_call(shgrp, geom, ob);
++      }
++    }
++  }
++}
++static void strokegen_cache_populate(void *vedata, Object *object)
++{
++  if (!check_strokegen_support()) return;
++
++  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
++
++  draw::Manager* drw_mgr = DRW_manager_get();
++  draw::ObjectRef ref {
++    object,
++    DRW_object_get_dupli(object),
++    DRW_object_get_dupli_parent(object)
++  };
++
++  ved->instance->object_sync(*drw_mgr, ref);
++
++
++
++  strokegen_cache_populate_legacy(vedata, object);
++}
++
++
++static void strokegen_cache_finish_legacy(void *vedata)
++{
++  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
++
++  UNUSED_VARS(stl);
++}
++static void strokegen_cache_finish(void *vedata)
++{
++  if (!check_strokegen_support()) return;
++
++  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data*>(vedata);
++  draw::Manager* drw_mgr = DRW_manager_get();
++
++  ved->instance->end_sync(*drw_mgr);
++
++
++
++  strokegen_cache_finish_legacy(vedata);
++}
++
++static void strokegen_instance_free(void *instance) {
++  if (!GPU_shader_storage_buffer_objects_support()) {
++    return;
++  }
++  delete reinterpret_cast<strokegen::Instance *>(instance);
++}
++
++static void strokegen_engine_free(void)
++{
++  strokegen::ShaderModule::module_free();
++}
++
++static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
++                                    struct RenderLayer *layer,
++                                    const struct rcti *UNUSED(rect)) {
++  UNUSED_VARS(vedata, engine, layer);
++}
++
++
++
++
++
++
++static const DrawEngineDataSize strokegen_data_size = DRW_VIEWPORT_DATA_SIZE(STROKEGEN_Data);
++
++DrawEngineType draw_engine_strokegen_type = {
++    NULL,
++    NULL,
++    N_("StrokeGen"),
++    &strokegen_data_size,
++    strokegen_engine_init,
++    &strokegen_engine_free,
++    &strokegen_instance_free,
++    &strokegen_cache_init,
++    &strokegen_cache_populate,
++    &strokegen_cache_finish,
++    &strokegen_draw_scene,
++    NULL,
++    NULL,
++    strokegen_render_to_image,
++    NULL,
++};
++
++RenderEngineType DRW_engine_viewport_strokegen_type = {
++  nullptr,
++  nullptr,
++  "STROKEGEN_VIEW",
++  N_("strokegen"),
++  RE_INTERNAL | RE_USE_PREVIEW | RE_USE_STEREO_VIEWPORT | RE_USE_GPU_CONTEXT,
++  nullptr,
++  &DRW_render_to_image,
++  nullptr,
++  nullptr,
++  nullptr,
++  nullptr,
++  nullptr,
++  nullptr,
++  nullptr, // TODO: impl this
++  &draw_engine_strokegen_type,
++  {nullptr, nullptr, nullptr},
++};
++
++#undef STROKEGEN_ENGINE
+diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.h b/source/blender/draw/engines/strokegen/strokegen_engine.h
+new file mode 100644
+index 00000000000..0df3623e738
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_engine.h
+@@ -0,0 +1,31 @@
++/* SPDX-License-Identifier: GPL-2.0-or-later
++ * Copyright 2016 Blender Foundation. */
++
++/** \file
++ * \ingroup draw_engine
++ */
++
++#pragma once
++
++#include "DRW_render.h"
++#include "RE_engine.h"
++
++#ifdef __cplusplus
++extern "C" { // to satisfy .cc files
++#endif
++
++extern DrawEngineType draw_engine_strokegen_type;
++extern RenderEngineType DRW_engine_viewport_strokegen_type;
++
++// Also I spent some time reading the mesh extraction code,
++// feel like I could add one or more new mesh buffers & extractors?
++// In that way,
++// 1) Never need to touch the DNA data;
++// 2) DrawManager updates these buffers when populates caches for the DrawEngine;
++// 3) DrawEngine uses a eevee-next-style sync module, in its function "sync_mesh":
++// -- 3.1) duplicate a ref from the cache, and
++// -- 3.2) issue ordered compute dispatches & indirect procedural draws;
++
++#ifdef __cplusplus
++}
++#endif
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/strokegen/strokegen_instance.cc
+new file mode 100644
+index 00000000000..377dd9a11ef
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_instance.cc
+@@ -0,0 +1,29 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup strokegen
++ *
++ * An instance contains all structures needed to do a complete render.
++ */
++
++#include <sstream>
++
++#include "BKE_global.h"
++#include "BKE_object.h"
++#include "BLI_rect.h"
++#include "DEG_depsgraph_query.h"
++#include "DNA_ID.h"
++#include "DNA_lightprobe_types.h"
++#include "DNA_modifier_types.h"
++#include "RE_pipeline.h"
++
++#include "strokegen_instance.hh"
++
++namespace blender::strokegen
++{
++
++  
++
++}
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
+new file mode 100644
+index 00000000000..6944f5baa7e
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
+@@ -0,0 +1,75 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup strokegen
++ *
++ * An renderer instance that contains all data to render a full frame.
++*/
++
++#pragma once
++
++#include "BKE_image.h"
++#include "DEG_depsgraph_query.h"
++#include "DNA_shader_fx_types.h"
++#include "DRW_engine.h"
++#include "DRW_render.h"
++#include "ED_view3d.h"
++#include "GPU_capabilities.h"
++#include "IMB_imbuf_types.h"
++
++#include "draw_manager.hh"
++#include "draw_pass.hh"
++#include "strokegen_shader.hh"
++
++
++namespace blender::strokegen
++{
++  using namespace draw;
++
++  class Instance
++  {
++  private:
++
++
++  public:
++    Instance() : shaders(*ShaderModule::module_get())
++    {
++    };
++
++    void init(Depsgraph* depsgraph, View3D* v3d)
++    {
++      /* Init things static per render frame. (Not render graph related) */
++    }
++
++    void begin_sync(Manager& /* manager */)
++    {
++      /* Init draw passes and manager related stuff. (Begin render graph) */
++    }
++
++    void object_sync(Manager& manager, ObjectRef& object_ref)
++    {
++      /* Add object draw calls to passes. (Populate render graph) */
++    }
++
++    void end_sync(Manager& /* manager */)
++    {
++      /* Post processing after all object. (End render graph) */
++    }
++
++    void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
++                       GPUTexture* color_tx)
++    {
++      /* Submit passes here. (Execute render graph) */
++    }
++
++
++
++    ShaderModule shaders; // singleton class for handling GPUShader(s)
++
++
++  };
++}
++
++
+diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.cc b/source/blender/draw/engines/strokegen/strokegen_shader.cc
+new file mode 100644
+index 00000000000..efe37087ef0
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_shader.cc
+@@ -0,0 +1,119 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++ * Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup eevee
++ *
++ * Shader module that manage shader libraries, deferred compilation,
++ * and static shader usage.
++ */
++
++#include "GPU_capabilities.h"
++
++#include "gpu_shader_create_info.hh"
++
++#include "strokegen_shader.hh"
++
++namespace blender::strokegen {
++
++/* -------------------------------------------------------------------- */
++/** \name Module
++ *
++ * \{ */
++
++ShaderModule *ShaderModule::g_shader_module = nullptr;
++
++ShaderModule *ShaderModule::module_get()
++{
++  if (g_shader_module == nullptr) {
++    /* TODO(@fclem) thread-safety. */
++    g_shader_module = new ShaderModule();
++  }
++  return g_shader_module;
++}
++
++void ShaderModule::module_free()
++{
++  if (g_shader_module != nullptr) {
++    /* TODO(@fclem) thread-safety. */
++    delete g_shader_module;
++    g_shader_module = nullptr;
++  }
++}
++
++ShaderModule::ShaderModule()
++{
++  for (GPUShader *&shader : shaders_) {
++    shader = nullptr;
++  }
++
++#ifdef DEBUG
++  /* Ensure all shader are described. */
++  for (auto i : IndexRange(MAX_SHADER_TYPE)) {
++    const char *name = static_shader_create_info_name_get(eShaderType(i));
++    if (name == nullptr) {
++      std::cerr << "STROKEGEN: Missing case for eShaderType(" << i
++                << ") in static_shader_create_info_name_get().";
++      BLI_assert(0);
++    }
++    const GPUShaderCreateInfo *create_info = GPU_shader_create_info_get(name);
++    BLI_assert_msg(create_info != nullptr, "STROKEGEN: Missing create info for static shader.");
++  }
++#endif
++}
++
++ShaderModule::~ShaderModule()
++{
++  for (GPUShader *&shader : shaders_) {
++    DRW_SHADER_FREE_SAFE(shader);
++  }
++}
++
++/** \} */
++
++/* -------------------------------------------------------------------- */
++/** \name Static shaders
++ *
++ * \{ */
++
++const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_type)
++{
++  switch (shader_type) {
++    case DEPTH:
++      return "basic_depth_mesh";
++    case POINTCLOUD_DEPTH:
++      return "basic_depth_pointcloud";
++    case CURVES_DEPTH:
++      return "basic_depth_curves";
++    case DEPTH_CONSERVATIVE:
++      return "basic_depth_mesh_conservative";
++    case POINTCLOUD_DEPTH_CONSERVATIVE:
++      return "basic_depth_pointcloud_conservative";
++
++    /* To avoid compiler warning about missing case. */
++    case MAX_SHADER_TYPE:
++      return "";
++  }
++  return "";
++}
++
++GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
++{
++  if (shaders_[shader_type] == nullptr) {
++    const char *shader_name = static_shader_create_info_name_get(shader_type);
++
++    shaders_[shader_type] = GPU_shader_create_from_info_name(shader_name);
++
++    if (shaders_[shader_type] == nullptr) {
++      fprintf(stderr, "STROKEGEN: error: Could not compile static shader \"%s\"\n", shader_name);
++    }
++    BLI_assert(shaders_[shader_type] != nullptr);
++  }
++  return shaders_[shader_type];
++}
++
++
++/** \} */
++
++}  // namespace blender::strokegen
+diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.hh b/source/blender/draw/engines/strokegen/strokegen_shader.hh
+new file mode 100644
+index 00000000000..92f8e90a4fe
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_shader.hh
+@@ -0,0 +1,62 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++ * Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup strokegen
++ *
++ * Shader module that manage shader libraries, deferred compilation,
++ * and static shader usage.
++ */
++
++#pragma once
++
++#include <array>
++#include <string>
++
++#include "BLI_string_ref.hh"
++#include "DRW_render.h"
++#include "GPU_material.h"
++#include "GPU_shader.h"
++
++
++namespace blender::strokegen {
++
++/* Keep alphabetical order and clean prefix. */
++enum eShaderType {
++  DEPTH = 0,
++  POINTCLOUD_DEPTH,
++  CURVES_DEPTH,
++  DEPTH_CONSERVATIVE,
++  POINTCLOUD_DEPTH_CONSERVATIVE,
++
++  MAX_SHADER_TYPE,
++};
++
++/**
++ * Shader module. shared between instances.
++ */
++class ShaderModule {
++ private:
++  std::array<GPUShader *, MAX_SHADER_TYPE> shaders_;
++
++  /** Shared shader module across all engine instances. */
++  static ShaderModule *g_shader_module;
++
++ public:
++  ShaderModule();
++  ~ShaderModule();
++
++  GPUShader *static_shader_get(eShaderType shader_type);
++  // TODO: GPUMaterial ? (see impl in eevee)
++
++
++  /** Only to be used by Instance constructor. */
++  static ShaderModule *module_get();
++  static void module_free();
++
++ private:
++  const char *static_shader_create_info_name_get(eShaderType shader_type);
++};
++
++}  // namespace blender::strokegen
+diff --git a/source/blender/draw/intern/draw_manager.c b/source/blender/draw/intern/draw_manager.c
+index 9e939fb490f..d10488abc22 100644
+--- a/source/blender/draw/intern/draw_manager.c
++++ b/source/blender/draw/intern/draw_manager.c
+@@ -96,6 +96,7 @@
+ #include "engines/overlay/overlay_engine.h"
+ #include "engines/select/select_engine.h"
+ #include "engines/workbench/workbench_engine.h"
++#include "engines/strokegen/strokegen_engine.h"
+ 
+ #include "GPU_context.h"
+ 
+@@ -3000,6 +3001,7 @@ void DRW_engines_register(void)
+ {
+   RE_engines_register(&DRW_engine_viewport_eevee_type);
+   RE_engines_register(&DRW_engine_viewport_workbench_type);
++  RE_engines_register(&DRW_engine_viewport_strokegen_type);
+ 
+   DRW_engine_register(&draw_engine_gpencil_type);
+ 
+@@ -3014,6 +3016,8 @@ void DRW_engines_register(void)
+   DRW_engine_register(&draw_engine_image_type);
+   DRW_engine_register(DRW_engine_viewport_external_type.draw_engine);
+ 
++  DRW_engine_register(&draw_engine_strokegen_type);
++
+   /* setup callbacks */
+   {
+     BKE_curve_batch_cache_dirty_tag_cb = DRW_curve_batch_cache_dirty_tag;
+-- 
+2.38.1.windows.1
+
+
+From 7b90c17f692386326aefcb707583c09e773532c9 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sat, 3 Dec 2022 18:11:57 +0800
+Subject: [PATCH 02/11] Basic data members
+
+Decl & Init for basic data members of strokegen::Instance.
+---
+ .../engines/strokegen/strokegen_engine.cc     | 24 ++++-
+ .../engines/strokegen/strokegen_instance.cc   | 89 ++++++++++++++++++-
+ .../engines/strokegen/strokegen_instance.hh   | 57 +++++++-----
+ 3 files changed, 146 insertions(+), 24 deletions(-)
+
+diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/strokegen/strokegen_engine.cc
+index b4267ce42f5..56b3b170660 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_engine.cc
++++ b/source/blender/draw/engines/strokegen/strokegen_engine.cc
+@@ -85,8 +85,26 @@ static void strokegen_engine_init(void *vedata)
+     ved->instance = new strokegen::Instance();
+   }
+ 
++  draw::Manager *drw_mgr = DRW_manager_get();
++
+   const DRWContextState *ctx_state = DRW_context_state_get();
+-  ved->instance->init(ctx_state->depsgraph, ctx_state->v3d);
++  View3D *v3d = ctx_state->v3d;
++  RegionView3D *rv3d = ctx_state->rv3d;
++
++  Object *camera = nullptr;
++  if (v3d && rv3d && rv3d->persp == RV3D_CAMOB)
++    camera = v3d->camera;
++
++  const DRWView* default_drw_view = DRW_view_default_get();
++
++
++  ved->instance->init(
++    ctx_state->depsgraph,
++    drw_mgr,
++    ctx_state->v3d, rv3d,
++    default_drw_view,
++    camera
++  );
+ }
+ 
+ 
+@@ -119,7 +137,11 @@ static void strokegen_draw_scene(void *vedata)
+   const DRWView *default_view = DRW_view_default_get();
+   draw::Manager *manager = DRW_manager_get();
+   draw::View view("DefaultView", default_view);
++  // draw passes
+   ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
++  // display error msg at the top of the render viewport
++  STRNCPY(ved->info, ved->instance->info.c_str());
++
+ 
+ 
+   strokegen_draw_scene_legacy(vedata);
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/strokegen/strokegen_instance.cc
+index 377dd9a11ef..74037bf3b76 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_instance.cc
++++ b/source/blender/draw/engines/strokegen/strokegen_instance.cc
+@@ -23,7 +23,94 @@
+ 
+ namespace blender::strokegen
+ {
++  /* -------------------------------------------------------------------- */
++  /** \name Initialization
++   *
++   * Initialization functions need to be called once at the start of a frame.
++   * Active camera, render extent and enabled render passes are immutable until next init.
++   * This takes care of resizing output buffers and view in case a parameter changed.
++   * IMPORTANT: xxx.init() functions are NOT meant to acquire and allocate DRW resources.
++   * Any attempt to do so will likely produce use after free situations.
++   * \{ */
++  void Instance::init(
++    Depsgraph* depsgraph_,
++    Manager* manager_,
++    const View3D* v3d_,
++    const RegionView3D* rv3d_,
++    const DRWView* drw_view_,
++    Object* camera_object_)
++  {
++    /* Init things static per render frame. (Not render graph related) */
++    depsgraph = depsgraph_;
++    manager = manager_;
++
++    drw_view = drw_view_;
++    v3d = v3d_;
++    rv3d = rv3d_;
++
++    camera_orig_object = camera_object_;
++
++    info = "";
++  }
++
++  void Instance::update_eval_members()
++  {
++    scene = DEG_get_evaluated_scene(depsgraph);
++    camera_eval_object = (camera_orig_object) ?
++                         DEG_get_evaluated_object(depsgraph, camera_orig_object) :
++                         nullptr;
++  }
++
++  /** \} */
++
++
++
++
++
++
++  /* -------------------------------------------------------------------- */
++  /** \name Sync
++   *
++   * Sync will gather data from the scene that can change over a time step (i.e: motion steps).
++   * IMPORTANT: xxx.sync() functions area responsible for creating DRW resources (i.e: DRWView) as
++   * well as querying temp texture pool. All DRWPasses should be ready by the end end_sync().
++   * \{ */
++  void Instance::begin_sync(Manager& manager)
++  {
++    /* Init draw passes and manager related stuff. (Begin render graph) */
++  }
++
++  void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
++  {
++    /* Add object draw calls to passes. (Populate render graph) */
++  }
++
++  void Instance::end_sync(Manager&)
++  {
++    /* Post processing after all object. (End render graph) */
++  }
++
++  /** \} */
++
++
++
++
++
++
++  /* -------------------------------------------------------------------- */
++  /** \name Rendering
++   * \{ */
++
++  void Instance::draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
++    GPUTexture* color_tx)
++  {
++    /* Submit passes here. (Execute render graph) */
++  }
++
++  /** \} */
++
++
++
+ 
+-  
+ 
+ }
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
+index 6944f5baa7e..ac1332c5838 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
++++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
+@@ -32,42 +32,55 @@ namespace blender::strokegen
+   {
+   private:
+ 
++  public:
++    /** Shading Modules */
++    ShaderModule shaders; // singleton class for handling GPUShader(s)
++
++
++    /** Input data. */
++    Depsgraph *depsgraph;
++    Manager *manager;
++
++    /** Evaluated IDs. */
++    Scene *scene;
++    Object *camera_eval_object;
++    Object *camera_orig_object;
++    /** Only available when rendering for viewport. */
++    const DRWView *drw_view;
++    const View3D *v3d;
++    const RegionView3D *rv3d;
++
++
++
++
++
++    /** Info string displayed at the top of the render / viewport. */
++    std::string info = "";
++    /** Debug mode from debug value. */
++    // eDebugMode debug_mode = eDebugMode::DEBUG_NONE;
++
++
+ 
+   public:
+     Instance() : shaders(*ShaderModule::module_get())
+     {
+     };
+ 
+-    void init(Depsgraph* depsgraph, View3D* v3d)
+-    {
+-      /* Init things static per render frame. (Not render graph related) */
+-    }
++    void init(Depsgraph* depsgraph_, draw::Manager* manager_, const View3D* v3d_, const RegionView3D* rv3d_, const
++              DRWView* drw_view_, Object* camera_object_);
++    void update_eval_members();
+ 
+-    void begin_sync(Manager& /* manager */)
+-    {
+-      /* Init draw passes and manager related stuff. (Begin render graph) */
+-    }
++    void begin_sync(Manager& manager);
+ 
+-    void object_sync(Manager& manager, ObjectRef& object_ref)
+-    {
+-      /* Add object draw calls to passes. (Populate render graph) */
+-    }
++    void object_sync(Manager& manager, ObjectRef& object_ref);
+ 
+-    void end_sync(Manager& /* manager */)
+-    {
+-      /* Post processing after all object. (End render graph) */
+-    }
++    void end_sync(Manager& /* manager */);
+ 
+     void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+-                       GPUTexture* color_tx)
+-    {
+-      /* Submit passes here. (Execute render graph) */
+-    }
++                       GPUTexture* color_tx);
+ 
+ 
+ 
+-    ShaderModule shaders; // singleton class for handling GPUShader(s)
+-
+ 
+   };
+ }
+-- 
+2.38.1.windows.1
+
+
+From 15803b42819ff5659c6a9b79ce6e05c7c0d4f386 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sat, 3 Dec 2022 19:08:34 +0800
+Subject: [PATCH 03/11] Basic setup for strokegen_sync
+
+Basic calls for sync module, all empty func for now.
+Also structs for reference object/resources in scene, copied from eevee_sync.hh
+---
+ source/blender/draw/CMakeLists.txt            |   5 +
+ .../engines/strokegen/strokegen_defines.hh    |  10 +
+ .../engines/strokegen/strokegen_instance.hh   |   7 +-
+ .../strokegen/strokegen_shader_shared.hh      |   7 +
+ .../draw/engines/strokegen/strokegen_sync.cc  |  29 +++
+ .../draw/engines/strokegen/strokegen_sync.hh  |  49 +++++
+ .../strokegen/strokegen_sync_handles.hh       | 171 ++++++++++++++++++
+ 7 files changed, 276 insertions(+), 2 deletions(-)
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_defines.hh
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.cc
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.hh
+ create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
+
+diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
+index 76bdd97ae20..33243161d91 100644
+--- a/source/blender/draw/CMakeLists.txt
++++ b/source/blender/draw/CMakeLists.txt
+@@ -211,6 +211,9 @@ set(SRC
+   engines/strokegen/strokegen_engine.cc
+   engines/strokegen/strokegen_shader.cc
+   engines/strokegen/strokegen_instance.cc
++  engines/strokegen/strokegen_sync.cc
++
++
+ 
+ 
+ 
+@@ -305,6 +308,8 @@ set(SRC
+   engines/strokegen/strokegen_engine.h
+   engines/strokegen/strokegen_shader.hh
+   engines/strokegen/strokegen_instance.hh
++  engines/strokegen/strokegen_sync_handles.hh
++  engines/strokegen/strokegen_sync.hh
+ )
+ 
+ set(LIB
+diff --git a/source/blender/draw/engines/strokegen/strokegen_defines.hh b/source/blender/draw/engines/strokegen/strokegen_defines.hh
+new file mode 100644
+index 00000000000..a1900395cc8
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_defines.hh
+@@ -0,0 +1,10 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++ * Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup eevee
++ *
++ * List of defines that are shared with the GPUShaderCreateInfos. We do this to avoid
++ * dragging larger headers into the createInfo pipeline which would cause problems.
++ */
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
+index ac1332c5838..6567f88cfaa 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
++++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
+@@ -22,6 +22,7 @@
+ #include "draw_manager.hh"
+ #include "draw_pass.hh"
+ #include "strokegen_shader.hh"
++#include "strokegen_sync.hh"
+ 
+ 
+ namespace blender::strokegen
+@@ -35,7 +36,7 @@ namespace blender::strokegen
+   public:
+     /** Shading Modules */
+     ShaderModule shaders; // singleton class for handling GPUShader(s)
+-
++    SyncModule sync;
+ 
+     /** Input data. */
+     Depsgraph *depsgraph;
+@@ -62,7 +63,9 @@ namespace blender::strokegen
+ 
+ 
+   public:
+-    Instance() : shaders(*ShaderModule::module_get())
++    Instance() :
++    shaders(*ShaderModule::module_get()),
++    sync(*this)
+     {
+     };
+ 
+diff --git a/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh b/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
+new file mode 100644
+index 00000000000..ca4e6ad46d7
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
+@@ -0,0 +1,7 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later */
++
++/**
++ * Shared structures, enums & defines between C++ and GLSL.
++ * Can also include some math functions but they need to be simple enough to be valid in both
++ * language.
++ */
+diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.cc b/source/blender/draw/engines/strokegen/strokegen_sync.cc
+new file mode 100644
+index 00000000000..2eda953508b
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_sync.cc
+@@ -0,0 +1,29 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup eevee
++ *
++ * Converts the different renderable object types to drawcalls.
++ */
++
++#include "strokegen_engine.h"
++
++#include "BKE_gpencil.h"
++#include "BKE_object.h"
++#include "DEG_depsgraph_query.h"
++#include "DNA_curves_types.h"
++#include "DNA_gpencil_types.h"
++#include "DNA_modifier_types.h"
++#include "DNA_particle_types.h"
++
++#include "strokegen_instance.hh"
++#include "strokegen_sync.hh"
++
++namespace blender::strokegen
++{
++
++
++
++}
+diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.hh b/source/blender/draw/engines/strokegen/strokegen_sync.hh
+new file mode 100644
+index 00000000000..ff979e63d6e
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_sync.hh
+@@ -0,0 +1,49 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup eevee
++ *
++ * Module for synchronization between draw engine and outside
++ */
++
++#pragma once
++
++#include "BKE_duplilist.h"
++#include "BLI_ghash.h"
++#include "BLI_map.hh"
++#include "DNA_object_types.h"
++#include "DRW_render.h"
++#include "GPU_material.h"
++
++#include "strokegen_shader_shared.hh"
++#include "strokegen_sync_handles.hh"
++
++namespace blender::strokegen
++{
++
++  class Instance;
++
++  class SyncModule
++  {
++  private:
++    Instance &inst_;
++
++  public:
++    SyncModule(Instance &inst) : inst_(inst) {};
++    ~SyncModule(){};
++
++    ObjectHandle &sync_object(Object *ob) {};
++    WorldHandle &sync_world(::World *world) {};
++    SceneHandle &sync_scene(::Scene *scene) {};
++
++    void sync_mesh(Object *ob,
++                   ObjectHandle &ob_handle,
++                   draw::ResourceHandle res_handle,
++                   const draw::ObjectRef &ob_ref) {};
++  };
++
++}
++
++
+diff --git a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh b/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
+new file mode 100644
+index 00000000000..2e0354a856d
+--- /dev/null
++++ b/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
+@@ -0,0 +1,171 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup eevee
++ *
++ * Structures to identify unique data blocks.
++ * The keys are unique so we are able to match ids across frame updates.
++ */
++
++#pragma once
++
++
++// Copied from eevee_sync.hh
++
++namespace blender::strokegen
++{
++  /* -------------------------------------------------------------------- */
++  /** \name ObjectKey
++   *
++   * Unique key to identify each object in the hash-map.
++   * Note that we get a unique key for each object component.
++   * \{ */
++
++  struct ObjectKey
++  {
++    /** Hash value of the key. */
++    uint64_t hash_value;
++    /** Original Object or source object for duplis. */
++    Object* ob;
++    /** Original Parent object for duplis. */
++    Object* parent;
++    /** Dupli objects recursive unique identifier */
++    int id[MAX_DUPLI_RECUR];
++    /** If object uses particle system hair. */
++    bool use_particle_hair;
++#ifdef DEBUG
++    char name[64];
++#endif
++    ObjectKey() : ob(nullptr), parent(nullptr)
++    {
++    };
++
++    ObjectKey(Object* ob_, Object* parent_, int id_[MAX_DUPLI_RECUR], bool use_particle_hair_)
++      : ob(ob_), parent(parent_), use_particle_hair(use_particle_hair_)
++    {
++      if (id_)
++      {
++        memcpy(id, id_, sizeof(id));
++      }
++      else
++      {
++        memset(id, 0, sizeof(id));
++      }
++      /* Compute hash on creation so we avoid the cost of it for every sync. */
++      hash_value = BLI_ghashutil_ptrhash(ob);
++      hash_value = BLI_ghashutil_combine_hash(hash_value, BLI_ghashutil_ptrhash(parent));
++      for (int i = 0; i < MAX_DUPLI_RECUR; i++)
++      {
++        if (id[i] != 0)
++        {
++          hash_value = BLI_ghashutil_combine_hash(hash_value, BLI_ghashutil_inthash(id[i]));
++        }
++        else
++        {
++          break;
++        }
++      }
++#ifdef DEBUG
++      STRNCPY(name, ob->id.name);
++#endif
++    }
++
++    ObjectKey(Object* ob, DupliObject* dupli, Object* parent)
++      : ObjectKey(ob, parent, dupli ? dupli->persistent_id : nullptr, false)
++    {
++    };
++
++    ObjectKey(Object* ob)
++      : ObjectKey(ob, DRW_object_get_dupli(ob), DRW_object_get_dupli_parent(ob))
++    {
++    };
++
++    uint64_t hash() const
++    {
++      return hash_value;
++    }
++
++    bool operator<(const ObjectKey& k) const
++    {
++      if (ob != k.ob)
++      {
++        return (ob < k.ob);
++      }
++      if (parent != k.parent)
++      {
++        return (parent < k.parent);
++      }
++      if (use_particle_hair != k.use_particle_hair)
++      {
++        return (use_particle_hair < k.use_particle_hair);
++      }
++      return memcmp(id, k.id, sizeof(id)) < 0;
++    }
++
++    bool operator==(const ObjectKey& k) const
++    {
++      if (ob != k.ob)
++      {
++        return false;
++      }
++      if (parent != k.parent)
++      {
++        return false;
++      }
++      if (use_particle_hair != k.use_particle_hair)
++      {
++        return false;
++      }
++      return memcmp(id, k.id, sizeof(id)) == 0;
++    }
++  };
++
++  /** \} */
++
++  /* -------------------------------------------------------------------- */
++  /** \name Sync Module
++   *
++   * \{ */
++
++  struct ObjectHandle : public DrawData
++  {
++    ObjectKey object_key;
++
++    void reset_recalc_flag()
++    {
++      if (recalc != 0)
++      {
++        recalc = 0;
++      }
++    }
++  };
++
++  struct WorldHandle : public DrawData
++  {
++    void reset_recalc_flag()
++    {
++      if (recalc != 0)
++      {
++        recalc = 0;
++      }
++    }
++  };
++
++  struct SceneHandle : public DrawData
++  {
++    void reset_recalc_flag()
++    {
++      if (recalc != 0)
++      {
++        recalc = 0;
++      }
++    }
++  };
++
++
++
++}
++
++/** \} */
+-- 
+2.38.1.windows.1
+
+
+From b9653cd9fc75bc4d5eac95fdb1a4f9b142616c14 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sun, 4 Dec 2022 21:08:13 +0800
+Subject: [PATCH 04/11] Change engine name from strokegen to bnpr
+
+---
+ source/blender/draw/CMakeLists.txt            |  25 ++-
+ .../bnpr_engine.cc}                           | 168 +++++++++---------
+ .../strokegen_engine.h => bnpr/bnpr_engine.h} |   4 +-
+ .../bnpr_instance.cc}                         |   6 +-
+ .../bnpr_instance.hh}                         |   8 +-
+ .../bnpr_shader.cc}                           |  12 +-
+ .../bnpr_shader.hh}                           |   6 +-
+ source/blender/draw/engines/bnpr/bnpr_sync.cc |  45 +++++
+ .../strokegen_sync.hh => bnpr/bnpr_sync.hh}   |   6 +-
+ .../bnpr_sync_handles.hh}                     |   2 +-
+ .../shaders/infos/strokegen_depth_info.hh     |   0
+ .../shaders/strokegen_depth_curves_vert.glsl  |   0
+ .../shaders/strokegen_depth_frag.glsl         |   0
+ .../strokegen_depth_pointcloud_vert.glsl      |   0
+ .../shaders/strokegen_depth_vert.glsl         |   0
+ .../strokgen_conservative_depth_geom.glsl     |   0
+ .../{strokegen => bnpr}/strokegen_defines.hh  |   0
+ .../strokegen_shader_shared.hh                |   0
+ .../draw/engines/strokegen/strokegen_sync.cc  |  29 ---
+ source/blender/draw/intern/draw_manager.c     |   6 +-
+ 20 files changed, 170 insertions(+), 147 deletions(-)
+ rename source/blender/draw/engines/{strokegen/strokegen_engine.cc => bnpr/bnpr_engine.cc} (68%)
+ rename source/blender/draw/engines/{strokegen/strokegen_engine.h => bnpr/bnpr_engine.h} (87%)
+ rename source/blender/draw/engines/{strokegen/strokegen_instance.cc => bnpr/bnpr_instance.cc} (97%)
+ rename source/blender/draw/engines/{strokegen/strokegen_instance.hh => bnpr/bnpr_instance.hh} (94%)
+ rename source/blender/draw/engines/{strokegen/strokegen_shader.cc => bnpr/bnpr_shader.cc} (87%)
+ rename source/blender/draw/engines/{strokegen/strokegen_shader.hh => bnpr/bnpr_shader.hh} (92%)
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_sync.cc
+ rename source/blender/draw/engines/{strokegen/strokegen_sync.hh => bnpr/bnpr_sync.hh} (89%)
+ rename source/blender/draw/engines/{strokegen/strokegen_sync_handles.hh => bnpr/bnpr_sync_handles.hh} (99%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/shaders/infos/strokegen_depth_info.hh (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_curves_vert.glsl (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_frag.glsl (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_pointcloud_vert.glsl (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_vert.glsl (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokgen_conservative_depth_geom.glsl (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/strokegen_defines.hh (100%)
+ rename source/blender/draw/engines/{strokegen => bnpr}/strokegen_shader_shared.hh (100%)
+ delete mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.cc
+
+diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
+index 33243161d91..90579052df5 100644
+--- a/source/blender/draw/CMakeLists.txt
++++ b/source/blender/draw/CMakeLists.txt
+@@ -208,10 +208,10 @@ set(SRC
+   engines/overlay/overlay_viewer_attribute.cc
+   engines/overlay/overlay_volume.cc
+   engines/overlay/overlay_wireframe.cc
+-  engines/strokegen/strokegen_engine.cc
+-  engines/strokegen/strokegen_shader.cc
+-  engines/strokegen/strokegen_instance.cc
+-  engines/strokegen/strokegen_sync.cc
++  engines/bnpr/bnpr_engine.cc
++  engines/bnpr/bnpr_shader.cc
++  engines/bnpr/bnpr_instance.cc
++  engines/bnpr/bnpr_sync.cc
+ 
+ 
+ 
+@@ -305,11 +305,11 @@ set(SRC
+   engines/select/select_private.h
+   engines/overlay/overlay_engine.h
+   engines/overlay/overlay_private.hh
+-  engines/strokegen/strokegen_engine.h
+-  engines/strokegen/strokegen_shader.hh
+-  engines/strokegen/strokegen_instance.hh
+-  engines/strokegen/strokegen_sync_handles.hh
+-  engines/strokegen/strokegen_sync.hh
++  engines/bnpr/bnpr_engine.h
++  engines/bnpr/bnpr_shader.hh
++  engines/bnpr/bnpr_instance.hh
++  engines/bnpr/bnpr_sync_handles.hh
++  engines/bnpr/bnpr_sync.hh
+ )
+ 
+ set(LIB
+@@ -699,6 +699,13 @@ set(GLSL_SRC
+   engines/image/shaders/image_engine_color_vert.glsl
+   engines/image/shaders/image_engine_depth_frag.glsl
+   engines/image/shaders/image_engine_depth_vert.glsl
++
++
++
++
++
++
++
+ )
+ 
+ set(GLSL_C)
+diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/bnpr/bnpr_engine.cc
+similarity index 68%
+rename from source/blender/draw/engines/strokegen/strokegen_engine.cc
+rename to source/blender/draw/engines/bnpr/bnpr_engine.cc
+index 56b3b170660..0e123f6e50c 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_engine.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_engine.cc
+@@ -17,72 +17,72 @@
+ 
+ #include "GPU_shader.h"
+ 
+-#include "strokegen_engine.h"
++#include "bnpr_engine.h"
+ 
+-#include "strokegen_instance.hh"
+-#include "strokegen_shader.hh"
++#include "bnpr_instance.hh"
++#include "bnpr_shader.hh"
+ 
+ 
+ using namespace blender;
+ 
+ 
+ 
+-#define STROKEGEN_ENGINE "BLENDER_STROKEGEN"
++#define bnpr_ENGINE "BLENDER_bnpr"
+ 
+ /* *********** LISTS *********** */
+ 
+ /* GPUViewport.storage
+  * Is freed every time the viewport engine changes. */
+-typedef struct STROKEGEN_StorageList {
+-  struct STROKEGEN_PrivateData *g_data;
+-} STROKEGEN_StorageList;
++typedef struct bnpr_StorageList {
++  struct bnpr_PrivateData *g_data;
++} bnpr_StorageList;
+ 
+-typedef struct STROKEGEN_PassList {
++typedef struct bnpr_PassList {
+   struct DRWPass *depth_pass[2];
+   struct DRWPass *depth_pass_pointcloud[2];
+   struct DRWPass *depth_pass_cull[2];
+-} STROKEGEN_PassList;
++} bnpr_PassList;
+ 
+ // Per-engine data
+ // Sent by draw manager to the draw-engine.
+-typedef struct STROKEGEN_Data {
++typedef struct bnpr_Data {
+   void *engine_type;
+   DRWViewportEmptyList *fbl;
+   DRWViewportEmptyList *txl;
+-  STROKEGEN_PassList *psl;
+-  STROKEGEN_StorageList *stl;
++  bnpr_PassList *psl;
++  bnpr_StorageList *stl;
+ 
+-  strokegen::Instance *instance;
++  bnpr::Instance *instance;
+   char info[GPU_INFO_SIZE];
+ 
+-} STROKEGEN_Data;
++} bnpr_Data;
+ 
+ /* *********** STATIC *********** */
+ 
+-typedef struct STROKEGEN_PrivateData {
++typedef struct bnpr_PrivateData {
+   DRWShadingGroup *depth_shgrp[2];
+   DRWShadingGroup *depth_shgrp_cull[2];
+   DRWShadingGroup *depth_hair_shgrp[2];
+   DRWShadingGroup *depth_curves_shgrp[2];
+   DRWShadingGroup *depth_pointcloud_shgrp[2];
+   bool use_material_slot_selection;
+-} STROKEGEN_PrivateData; /* Transient data */
++} bnpr_PrivateData; /* Transient data */
+ 
+ 
+ 
+-static bool check_strokegen_support()
++static bool check_bnpr_support()
+ {
+   return GPU_shader_storage_buffer_objects_support();
+ }
+ 
+ 
+-static void strokegen_engine_init(void *vedata)
++static void bnpr_engine_init(void *vedata)
+ {
+-  if (!check_strokegen_support()) { return; }
++  if (!check_bnpr_support()) { return; }
+ 
+-  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
++  bnpr_Data *ved = reinterpret_cast<bnpr_Data *>(vedata);
+   if (ved->instance == nullptr) {
+-    ved->instance = new strokegen::Instance();
++    ved->instance = new bnpr::Instance();
+   }
+ 
+   draw::Manager *drw_mgr = DRW_manager_get();
+@@ -109,9 +109,9 @@ static void strokegen_engine_init(void *vedata)
+ 
+ 
+ 
+-static void strokegen_draw_scene_legacy(void *vedata)
++static void bnpr_draw_scene_legacy(void *vedata)
+ {
+-  STROKEGEN_PassList *psl = ((STROKEGEN_Data *)vedata)->psl;
++  bnpr_PassList *psl = ((bnpr_Data *)vedata)->psl;
+ 
+   DRW_draw_pass(psl->depth_pass[0]);
+   DRW_draw_pass(psl->depth_pass_pointcloud[0]);
+@@ -121,11 +121,11 @@ static void strokegen_draw_scene_legacy(void *vedata)
+   DRW_draw_pass(psl->depth_pass_cull[1]);
+ }
+ 
+-static void strokegen_draw_scene(void *vedata)
++static void bnpr_draw_scene(void *vedata)
+ {
+-  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+-  if (!check_strokegen_support()) {
+-    STRNCPY(ved->info, "Error: No shader storage buffer support, required by StrokeGen.");
++  bnpr_Data *ved = reinterpret_cast<bnpr_Data *>(vedata);
++  if (!check_bnpr_support()) {
++    STRNCPY(ved->info, "Error: No shader storage buffer support, required by bnpr.");
+     return;
+   }
+ 
+@@ -144,7 +144,7 @@ static void strokegen_draw_scene(void *vedata)
+ 
+ 
+ 
+-  strokegen_draw_scene_legacy(vedata);
++  bnpr_draw_scene_legacy(vedata);
+ 
+ 
+   /* Reset view for other following engines. */
+@@ -154,17 +154,17 @@ static void strokegen_draw_scene(void *vedata)
+ 
+ 
+ 
+-static void strokegen_cache_init_legacy(void *vedata)
++static void bnpr_cache_init_legacy(void *vedata)
+ {
+-  STROKEGEN_PassList *psl = static_cast<STROKEGEN_Data*>(vedata)->psl;
+-  STROKEGEN_StorageList *stl = static_cast<STROKEGEN_Data*>(vedata)->stl;
++  bnpr_PassList *psl = static_cast<bnpr_Data*>(vedata)->psl;
++  bnpr_StorageList *stl = static_cast<bnpr_Data*>(vedata)->stl;
+   DRWShadingGroup *grp;
+ 
+   const DRWContextState *draw_ctx = DRW_context_state_get();
+ 
+   if (!stl->g_data) {
+     /* Alloc transient pointers */
+-    stl->g_data = (STROKEGEN_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
++    stl->g_data = (bnpr_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
+   }
+ 
+   stl->g_data->use_material_slot_selection = DRW_state_is_material_select();
+@@ -179,50 +179,50 @@ static void strokegen_cache_init_legacy(void *vedata)
+     );
+     DRWState state = DRW_STATE_WRITE_DEPTH | DRW_STATE_DEPTH_LESS_EQUAL;
+ 
+-    blender::strokegen::ShaderModule* shaderModule =
+-      blender::strokegen::ShaderModule::module_get();
++    blender::bnpr::ShaderModule* shaderModule =
++      blender::bnpr::ShaderModule::module_get();
+ 
+     GPUShader *sh = DRW_state_is_select() ?
+-                        shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
+-                        shaderModule->static_shader_get(blender::strokegen::DEPTH);
++                        shaderModule->static_shader_get(blender::bnpr::DEPTH_CONSERVATIVE) :
++                        shaderModule->static_shader_get(blender::bnpr::DEPTH);
+ 
+     DRW_PASS_CREATE(psl->depth_pass[i], state | clip_state | infront_state);
+     stl->g_data->depth_shgrp[i] = grp = DRW_shgroup_create(sh, psl->depth_pass[i]);
+     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+ 
+     sh = DRW_state_is_select() ?
+-        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH_CONSERVATIVE) :
+-        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH);
++        shaderModule->static_shader_get(blender::bnpr::POINTCLOUD_DEPTH_CONSERVATIVE) :
++        shaderModule->static_shader_get(blender::bnpr::POINTCLOUD_DEPTH);
+     DRW_PASS_CREATE(psl->depth_pass_pointcloud[i], state | clip_state | infront_state);
+     stl->g_data->depth_pointcloud_shgrp[i] = grp = DRW_shgroup_create(
+         sh, psl->depth_pass_pointcloud[i]);
+     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+ 
+     stl->g_data->depth_hair_shgrp[i] = grp = DRW_shgroup_create(
+-        shaderModule->static_shader_get(blender::strokegen::DEPTH), psl->depth_pass[i]);
++        shaderModule->static_shader_get(blender::bnpr::DEPTH), psl->depth_pass[i]);
+     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+ 
+     stl->g_data->depth_curves_shgrp[i] = grp = DRW_shgroup_create(
+-        shaderModule->static_shader_get(blender::strokegen::CURVES_DEPTH), psl->depth_pass[i]);
++        shaderModule->static_shader_get(blender::bnpr::CURVES_DEPTH), psl->depth_pass[i]);
+     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+ 
+-    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
+-                                 shaderModule->static_shader_get(blender::strokegen::DEPTH);
++    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::bnpr::DEPTH_CONSERVATIVE) :
++                                 shaderModule->static_shader_get(blender::bnpr::DEPTH);
+     state |= DRW_STATE_CULL_BACK;
+     DRW_PASS_CREATE(psl->depth_pass_cull[i], state | clip_state | infront_state);
+     stl->g_data->depth_shgrp_cull[i] = grp = DRW_shgroup_create(sh, psl->depth_pass_cull[i]);
+     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+   }
+ }
+-static void strokegen_cache_init(void *vedata)
++static void bnpr_cache_init(void *vedata)
+ {
+-  if (!check_strokegen_support()) return;
++  if (!check_bnpr_support()) return;
+ 
+   draw::Manager* drwmgr = DRW_manager_get();
+-  reinterpret_cast<STROKEGEN_Data *>(vedata)->instance->begin_sync(*drwmgr);
++  reinterpret_cast<bnpr_Data *>(vedata)->instance->begin_sync(*drwmgr);
+ 
+ 
+-  strokegen_cache_init_legacy(vedata);
++  bnpr_cache_init_legacy(vedata);
+ }
+ 
+ 
+@@ -235,7 +235,7 @@ static void strokegen_cache_init(void *vedata)
+ 
+ /* TODO(fclem): DRW_cache_object_surface_material_get needs a refactor to allow passing NULL
+  * instead of gpumat_array. Avoiding all this boilerplate code. */
+-static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
++static struct GPUBatch **bnpr_object_surface_material_get(Object *ob)
+ {
+   const int materials_len = DRW_cache_object_material_count_get(ob);
+   struct GPUMaterial **gpumat_array =
+@@ -245,14 +245,14 @@ static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
+   return DRW_cache_object_surface_material_get(ob, gpumat_array, materials_len);
+ }
+ 
+-static void strokegen_cache_populate_particles(void *vedata, Object *ob)
++static void bnpr_cache_populate_particles(void *vedata, Object *ob)
+ {
+   // do nothing here.
+ }
+ 
+-static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
++static void bnpr_cache_populate_legacy(void *vedata, Object *ob)
+ {
+-  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
++  bnpr_StorageList *stl = ((bnpr_Data *)vedata)->stl;
+ 
+   /* TODO(fclem): fix selection of smoke domains. */
+ 
+@@ -262,7 +262,7 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+ 
+   const DRWContextState *draw_ctx = DRW_context_state_get();
+   if (ob != draw_ctx->object_edit) {
+-    strokegen_cache_populate_particles(vedata, ob);
++    bnpr_cache_populate_particles(vedata, ob);
+   }
+ 
+   const bool do_in_front = (ob->dtx & OB_DRAW_IN_FRONT) != 0;
+@@ -308,7 +308,7 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+   }
+   else {
+     if (stl->g_data->use_material_slot_selection && BKE_object_supports_material_slots(ob)) {
+-      struct GPUBatch **geoms = strokegen_object_surface_material_get(ob);
++      struct GPUBatch **geoms = bnpr_object_surface_material_get(ob);
+       if (geoms) {
+         const int materials_len = DRW_cache_object_material_count_get(ob);
+         for (int i = 0; i < materials_len; i++) {
+@@ -329,11 +329,11 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+     }
+   }
+ }
+-static void strokegen_cache_populate(void *vedata, Object *object)
++static void bnpr_cache_populate(void *vedata, Object *object)
+ {
+-  if (!check_strokegen_support()) return;
++  if (!check_bnpr_support()) return;
+ 
+-  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
++  bnpr_Data* ved = reinterpret_cast<bnpr_Data *>(vedata);
+ 
+   draw::Manager* drw_mgr = DRW_manager_get();
+   draw::ObjectRef ref {
+@@ -346,43 +346,43 @@ static void strokegen_cache_populate(void *vedata, Object *object)
+ 
+ 
+ 
+-  strokegen_cache_populate_legacy(vedata, object);
++  bnpr_cache_populate_legacy(vedata, object);
+ }
+ 
+ 
+-static void strokegen_cache_finish_legacy(void *vedata)
++static void bnpr_cache_finish_legacy(void *vedata)
+ {
+-  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
++  bnpr_StorageList *stl = ((bnpr_Data *)vedata)->stl;
+ 
+   UNUSED_VARS(stl);
+ }
+-static void strokegen_cache_finish(void *vedata)
++static void bnpr_cache_finish(void *vedata)
+ {
+-  if (!check_strokegen_support()) return;
++  if (!check_bnpr_support()) return;
+ 
+-  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data*>(vedata);
++  bnpr_Data* ved = reinterpret_cast<bnpr_Data*>(vedata);
+   draw::Manager* drw_mgr = DRW_manager_get();
+ 
+   ved->instance->end_sync(*drw_mgr);
+ 
+ 
+ 
+-  strokegen_cache_finish_legacy(vedata);
++  bnpr_cache_finish_legacy(vedata);
+ }
+ 
+-static void strokegen_instance_free(void *instance) {
++static void bnpr_instance_free(void *instance) {
+   if (!GPU_shader_storage_buffer_objects_support()) {
+     return;
+   }
+-  delete reinterpret_cast<strokegen::Instance *>(instance);
++  delete reinterpret_cast<bnpr::Instance *>(instance);
+ }
+ 
+-static void strokegen_engine_free(void)
++static void bnpr_engine_free(void)
+ {
+-  strokegen::ShaderModule::module_free();
++  bnpr::ShaderModule::module_free();
+ }
+ 
+-static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
++static void bnpr_render_to_image(void *vedata, struct RenderEngine *engine,
+                                     struct RenderLayer *layer,
+                                     const struct rcti *UNUSED(rect)) {
+   UNUSED_VARS(vedata, engine, layer);
+@@ -393,31 +393,31 @@ static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
+ 
+ 
+ 
+-static const DrawEngineDataSize strokegen_data_size = DRW_VIEWPORT_DATA_SIZE(STROKEGEN_Data);
++static const DrawEngineDataSize bnpr_data_size = DRW_VIEWPORT_DATA_SIZE(bnpr_Data);
+ 
+-DrawEngineType draw_engine_strokegen_type = {
++DrawEngineType draw_engine_bnpr_type = {
+     NULL,
+     NULL,
+-    N_("StrokeGen"),
+-    &strokegen_data_size,
+-    strokegen_engine_init,
+-    &strokegen_engine_free,
+-    &strokegen_instance_free,
+-    &strokegen_cache_init,
+-    &strokegen_cache_populate,
+-    &strokegen_cache_finish,
+-    &strokegen_draw_scene,
++    N_("bnpr"),
++    &bnpr_data_size,
++    bnpr_engine_init,
++    &bnpr_engine_free,
++    &bnpr_instance_free,
++    &bnpr_cache_init,
++    &bnpr_cache_populate,
++    &bnpr_cache_finish,
++    &bnpr_draw_scene,
+     NULL,
+     NULL,
+-    strokegen_render_to_image,
++    bnpr_render_to_image,
+     NULL,
+ };
+ 
+-RenderEngineType DRW_engine_viewport_strokegen_type = {
++RenderEngineType DRW_engine_viewport_bnpr_type = {
+   nullptr,
+   nullptr,
+-  "STROKEGEN_VIEW",
+-  N_("strokegen"),
++  "bnpr_VIEW",
++  N_("bnpr"),
+   RE_INTERNAL | RE_USE_PREVIEW | RE_USE_STEREO_VIEWPORT | RE_USE_GPU_CONTEXT,
+   nullptr,
+   &DRW_render_to_image,
+@@ -428,8 +428,8 @@ RenderEngineType DRW_engine_viewport_strokegen_type = {
+   nullptr,
+   nullptr,
+   nullptr, // TODO: impl this
+-  &draw_engine_strokegen_type,
++  &draw_engine_bnpr_type,
+   {nullptr, nullptr, nullptr},
+ };
+ 
+-#undef STROKEGEN_ENGINE
++#undef bnpr_ENGINE
+diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.h b/source/blender/draw/engines/bnpr/bnpr_engine.h
+similarity index 87%
+rename from source/blender/draw/engines/strokegen/strokegen_engine.h
+rename to source/blender/draw/engines/bnpr/bnpr_engine.h
+index 0df3623e738..842c7d664a5 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_engine.h
++++ b/source/blender/draw/engines/bnpr/bnpr_engine.h
+@@ -14,8 +14,8 @@
+ extern "C" { // to satisfy .cc files
+ #endif
+ 
+-extern DrawEngineType draw_engine_strokegen_type;
+-extern RenderEngineType DRW_engine_viewport_strokegen_type;
++extern DrawEngineType draw_engine_bnpr_type;
++extern RenderEngineType DRW_engine_viewport_bnpr_type;
+ 
+ // Also I spent some time reading the mesh extraction code,
+ // feel like I could add one or more new mesh buffers & extractors?
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+similarity index 97%
+rename from source/blender/draw/engines/strokegen/strokegen_instance.cc
+rename to source/blender/draw/engines/bnpr/bnpr_instance.cc
+index 74037bf3b76..5139b0c5f49 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_instance.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+@@ -3,7 +3,7 @@
+  */
+ 
+ /** \file
+- * \ingroup strokegen
++ * \ingroup bnpr
+  *
+  * An instance contains all structures needed to do a complete render.
+  */
+@@ -19,9 +19,9 @@
+ #include "DNA_modifier_types.h"
+ #include "RE_pipeline.h"
+ 
+-#include "strokegen_instance.hh"
++#include "bnpr_instance.hh"
+ 
+-namespace blender::strokegen
++namespace blender::bnpr
+ {
+   /* -------------------------------------------------------------------- */
+   /** \name Initialization
+diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+similarity index 94%
+rename from source/blender/draw/engines/strokegen/strokegen_instance.hh
+rename to source/blender/draw/engines/bnpr/bnpr_instance.hh
+index 6567f88cfaa..5f6a7374b89 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+@@ -3,7 +3,7 @@
+  */
+ 
+ /** \file
+- * \ingroup strokegen
++ * \ingroup bnpr
+  *
+  * An renderer instance that contains all data to render a full frame.
+ */
+@@ -21,11 +21,11 @@
+ 
+ #include "draw_manager.hh"
+ #include "draw_pass.hh"
+-#include "strokegen_shader.hh"
+-#include "strokegen_sync.hh"
++#include "bnpr_shader.hh"
++#include "bnpr_sync.hh"
+ 
+ 
+-namespace blender::strokegen
++namespace blender::bnpr
+ {
+   using namespace draw;
+ 
+diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+similarity index 87%
+rename from source/blender/draw/engines/strokegen/strokegen_shader.cc
+rename to source/blender/draw/engines/bnpr/bnpr_shader.cc
+index efe37087ef0..7bf72caf057 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_shader.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+@@ -13,9 +13,9 @@
+ 
+ #include "gpu_shader_create_info.hh"
+ 
+-#include "strokegen_shader.hh"
++#include "bnpr_shader.hh"
+ 
+-namespace blender::strokegen {
++namespace blender::bnpr {
+ 
+ /* -------------------------------------------------------------------- */
+ /** \name Module
+@@ -53,12 +53,12 @@ ShaderModule::ShaderModule()
+   for (auto i : IndexRange(MAX_SHADER_TYPE)) {
+     const char *name = static_shader_create_info_name_get(eShaderType(i));
+     if (name == nullptr) {
+-      std::cerr << "STROKEGEN: Missing case for eShaderType(" << i
++      std::cerr << "bnpr: Missing case for eShaderType(" << i
+                 << ") in static_shader_create_info_name_get().";
+       BLI_assert(0);
+     }
+     const GPUShaderCreateInfo *create_info = GPU_shader_create_info_get(name);
+-    BLI_assert_msg(create_info != nullptr, "STROKEGEN: Missing create info for static shader.");
++    BLI_assert_msg(create_info != nullptr, "bnpr: Missing create info for static shader.");
+   }
+ #endif
+ }
+@@ -106,7 +106,7 @@ GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
+     shaders_[shader_type] = GPU_shader_create_from_info_name(shader_name);
+ 
+     if (shaders_[shader_type] == nullptr) {
+-      fprintf(stderr, "STROKEGEN: error: Could not compile static shader \"%s\"\n", shader_name);
++      fprintf(stderr, "bnpr: error: Could not compile static shader \"%s\"\n", shader_name);
+     }
+     BLI_assert(shaders_[shader_type] != nullptr);
+   }
+@@ -116,4 +116,4 @@ GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
+ 
+ /** \} */
+ 
+-}  // namespace blender::strokegen
++}  // namespace blender::bnpr
+diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
+similarity index 92%
+rename from source/blender/draw/engines/strokegen/strokegen_shader.hh
+rename to source/blender/draw/engines/bnpr/bnpr_shader.hh
+index 92f8e90a4fe..9b756e213a4 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_shader.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
+@@ -3,7 +3,7 @@
+  */
+ 
+ /** \file
+- * \ingroup strokegen
++ * \ingroup bnpr
+  *
+  * Shader module that manage shader libraries, deferred compilation,
+  * and static shader usage.
+@@ -20,7 +20,7 @@
+ #include "GPU_shader.h"
+ 
+ 
+-namespace blender::strokegen {
++namespace blender::bnpr {
+ 
+ /* Keep alphabetical order and clean prefix. */
+ enum eShaderType {
+@@ -59,4 +59,4 @@ class ShaderModule {
+   const char *static_shader_create_info_name_get(eShaderType shader_type);
+ };
+ 
+-}  // namespace blender::strokegen
++}  // namespace blender::bnpr
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+new file mode 100644
+index 00000000000..5bff2b58f9e
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+@@ -0,0 +1,45 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup eevee
++ *
++ * Converts the different renderable object types to drawcalls.
++ */
++
++#include "bnpr_engine.h"
++
++#include "BKE_gpencil.h"
++#include "BKE_object.h"
++#include "DEG_depsgraph_query.h"
++#include "DNA_curves_types.h"
++#include "DNA_gpencil_types.h"
++#include "DNA_modifier_types.h"
++#include "DNA_particle_types.h"
++
++#include "bnpr_instance.hh"
++#include "bnpr_sync.hh"
++
++namespace blender::bnpr
++{
++
++  /* -------------------------------------------------------------------- */
++  /** \name Draw Data
++   *
++   * \{ */
++
++  static void draw_data_init_cb(struct DrawData *dd)
++  {
++    /* Object has just been created or was never evaluated by the engine. */
++    dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
++  }
++
++  // ObjectHandle& SyncModule::sync_object(Object* ob)
++  // {
++  //   DrawEngineType *owner = (DrawEngineType *)&DRW_engine_viewport_bnpr_type;
++  //   return ObjectHandle();
++  // }
++
++
++}
+diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+similarity index 89%
+rename from source/blender/draw/engines/strokegen/strokegen_sync.hh
+rename to source/blender/draw/engines/bnpr/bnpr_sync.hh
+index ff979e63d6e..fb7f649780b 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_sync.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+@@ -17,10 +17,10 @@
+ #include "DRW_render.h"
+ #include "GPU_material.h"
+ 
+-#include "strokegen_shader_shared.hh"
+-#include "strokegen_sync_handles.hh"
++// #include "bnpr_shader_shared.hh"
++#include "bnpr_sync_handles.hh"
+ 
+-namespace blender::strokegen
++namespace blender::bnpr
+ {
+ 
+   class Instance;
+diff --git a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+similarity index 99%
+rename from source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
+rename to source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+index 2e0354a856d..8fd0fc90070 100644
+--- a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+@@ -14,7 +14,7 @@
+ 
+ // Copied from eevee_sync.hh
+ 
+-namespace blender::strokegen
++namespace blender::bnpr
+ {
+   /* -------------------------------------------------------------------- */
+   /** \name ObjectKey
+diff --git a/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
+rename to source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_curves_vert.glsl
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
+rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_curves_vert.glsl
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_frag.glsl
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
+rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_frag.glsl
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_pointcloud_vert.glsl
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
+rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_pointcloud_vert.glsl
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_vert.glsl
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
+rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_vert.glsl
+diff --git a/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl b/source/blender/draw/engines/bnpr/shaders/strokgen_conservative_depth_geom.glsl
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
+rename to source/blender/draw/engines/bnpr/shaders/strokgen_conservative_depth_geom.glsl
+diff --git a/source/blender/draw/engines/strokegen/strokegen_defines.hh b/source/blender/draw/engines/bnpr/strokegen_defines.hh
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/strokegen_defines.hh
+rename to source/blender/draw/engines/bnpr/strokegen_defines.hh
+diff --git a/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh b/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
+similarity index 100%
+rename from source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
+rename to source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
+diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.cc b/source/blender/draw/engines/strokegen/strokegen_sync.cc
+deleted file mode 100644
+index 2eda953508b..00000000000
+--- a/source/blender/draw/engines/strokegen/strokegen_sync.cc
++++ /dev/null
+@@ -1,29 +0,0 @@
+-﻿/* SPDX-License-Identifier: GPL-2.0-or-later
+-* Copyright 2021 Blender Foundation.
+- */
+-
+-/** \file
+- * \ingroup eevee
+- *
+- * Converts the different renderable object types to drawcalls.
+- */
+-
+-#include "strokegen_engine.h"
+-
+-#include "BKE_gpencil.h"
+-#include "BKE_object.h"
+-#include "DEG_depsgraph_query.h"
+-#include "DNA_curves_types.h"
+-#include "DNA_gpencil_types.h"
+-#include "DNA_modifier_types.h"
+-#include "DNA_particle_types.h"
+-
+-#include "strokegen_instance.hh"
+-#include "strokegen_sync.hh"
+-
+-namespace blender::strokegen
+-{
+-
+-
+-
+-}
+diff --git a/source/blender/draw/intern/draw_manager.c b/source/blender/draw/intern/draw_manager.c
+index d10488abc22..00a08b38a55 100644
+--- a/source/blender/draw/intern/draw_manager.c
++++ b/source/blender/draw/intern/draw_manager.c
+@@ -96,7 +96,7 @@
+ #include "engines/overlay/overlay_engine.h"
+ #include "engines/select/select_engine.h"
+ #include "engines/workbench/workbench_engine.h"
+-#include "engines/strokegen/strokegen_engine.h"
++#include "engines/bnpr/bnpr_engine.h"
+ 
+ #include "GPU_context.h"
+ 
+@@ -3001,7 +3001,7 @@ void DRW_engines_register(void)
+ {
+   RE_engines_register(&DRW_engine_viewport_eevee_type);
+   RE_engines_register(&DRW_engine_viewport_workbench_type);
+-  RE_engines_register(&DRW_engine_viewport_strokegen_type);
++  RE_engines_register(&DRW_engine_viewport_bnpr_type);
+ 
+   DRW_engine_register(&draw_engine_gpencil_type);
+ 
+@@ -3016,7 +3016,7 @@ void DRW_engines_register(void)
+   DRW_engine_register(&draw_engine_image_type);
+   DRW_engine_register(DRW_engine_viewport_external_type.draw_engine);
+ 
+-  DRW_engine_register(&draw_engine_strokegen_type);
++  DRW_engine_register(&draw_engine_bnpr_type);
+ 
+   /* setup callbacks */
+   {
+-- 
+2.38.1.windows.1
+
+
+From 4210ae9778c63e64bc47ea195c2aed0731ef500a Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sun, 4 Dec 2022 21:20:09 +0800
+Subject: [PATCH 05/11] Added shared shader header files to project
+
+---
+ source/blender/draw/CMakeLists.txt                           | 3 +++
+ .../engines/bnpr/{strokegen_defines.hh => bnpr_defines.hh}   | 5 ++++-
+ .../{strokegen_shader_shared.hh => bnpr_shader_shared.hh}    | 2 ++
+ source/blender/draw/engines/bnpr/bnpr_sync.hh                | 2 +-
+ 4 files changed, 10 insertions(+), 2 deletions(-)
+ rename source/blender/draw/engines/bnpr/{strokegen_defines.hh => bnpr_defines.hh} (89%)
+ rename source/blender/draw/engines/bnpr/{strokegen_shader_shared.hh => bnpr_shader_shared.hh} (94%)
+
+diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
+index 90579052df5..3402caa5f23 100644
+--- a/source/blender/draw/CMakeLists.txt
++++ b/source/blender/draw/CMakeLists.txt
+@@ -705,6 +705,9 @@ set(GLSL_SRC
+ 
+ 
+ 
++  engines/bnpr/bnpr_defines.hh
++  engines/bnpr/bnpr_shader_shared.hh
++
+ 
+ )
+ 
+diff --git a/source/blender/draw/engines/bnpr/strokegen_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+similarity index 89%
+rename from source/blender/draw/engines/bnpr/strokegen_defines.hh
+rename to source/blender/draw/engines/bnpr/bnpr_defines.hh
+index a1900395cc8..dfd63e92d97 100644
+--- a/source/blender/draw/engines/bnpr/strokegen_defines.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+@@ -3,8 +3,11 @@
+  */
+ 
+ /** \file
+- * \ingroup eevee
++ * \ingroup bnpr
+  *
+  * List of defines that are shared with the GPUShaderCreateInfos. We do this to avoid
+  * dragging larger headers into the createInfo pipeline which would cause problems.
+  */
++
++
++#pragma once
+diff --git a/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+similarity index 94%
+rename from source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
+rename to source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+index ca4e6ad46d7..9cbb254e58c 100644
+--- a/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+@@ -5,3 +5,5 @@
+  * Can also include some math functions but they need to be simple enough to be valid in both
+  * language.
+  */
++
++#pragma once
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+index fb7f649780b..b16e3dda61f 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+@@ -17,7 +17,7 @@
+ #include "DRW_render.h"
+ #include "GPU_material.h"
+ 
+-// #include "bnpr_shader_shared.hh"
++#include "bnpr_shader_shared.hh"
+ #include "bnpr_sync_handles.hh"
+ 
+ namespace blender::bnpr
+-- 
+2.38.1.windows.1
+
+
+From 66d94f9de7500eb324655a82abea6bf5804c27f2 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Tue, 6 Dec 2022 23:22:44 +0800
+Subject: [PATCH 06/11] Finished empty compute shader compilation process
+
+shader create info:
+1) add directory to the cmakelist
+2) add create info .hh to the cmakelist
+3) I wrote some explanation in "bnpr_test_info.hh"
+---
+ source/blender/draw/CMakeLists.txt            | 15 ++--
+ .../blender/draw/engines/bnpr/bnpr_defines.hh |  4 +-
+ .../draw/engines/bnpr/bnpr_instance.hh        | 12 ++-
+ .../blender/draw/engines/bnpr/bnpr_shader.cc  |  2 +
+ .../blender/draw/engines/bnpr/bnpr_shader.hh  |  3 +-
+ .../draw/engines/bnpr/bnpr_shader_shared.hh   | 90 ++++++++++++++++++-
+ .../bnpr/bnpr_strokegen_buffer_pool.cc        | 25 ++++++
+ .../bnpr/bnpr_strokegen_buffer_pool.hh        | 37 ++++++++
+ .../draw/engines/bnpr/bnpr_strokegen_pass.cc  | 34 +++++++
+ .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 56 ++++++++++++
+ .../bnpr/bnpr_strokegen_texture_pool.cc       | 15 ++++
+ .../bnpr/bnpr_strokegen_texture_pool.hh       | 35 ++++++++
+ source/blender/draw/engines/bnpr/bnpr_sync.cc |  6 --
+ source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +
+ .../shaders/bnpr_strokegen_test_comp.glsl     | 57 ++++++++++++
+ .../bnpr/shaders/infos/bnpr_test_info.hh      | 68 ++++++++++++++
+ .../shaders/infos/strokegen_depth_info.hh     | 65 --------------
+ source/blender/gpu/CMakeLists.txt             |  3 +
+ 18 files changed, 445 insertions(+), 84 deletions(-)
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
+ create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+ create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+ create mode 100644 source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+ delete mode 100644 source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
+
+diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
+index 3402caa5f23..e6885e1958d 100644
+--- a/source/blender/draw/CMakeLists.txt
++++ b/source/blender/draw/CMakeLists.txt
+@@ -212,8 +212,9 @@ set(SRC
+   engines/bnpr/bnpr_shader.cc
+   engines/bnpr/bnpr_instance.cc
+   engines/bnpr/bnpr_sync.cc
+-
+-
++  engines/bnpr/bnpr_strokegen_buffer_pool.cc
++  engines/bnpr/bnpr_strokegen_texture_pool.cc
++  engines/bnpr/bnpr_strokegen_pass.cc
+ 
+ 
+ 
+@@ -310,6 +311,9 @@ set(SRC
+   engines/bnpr/bnpr_instance.hh
+   engines/bnpr/bnpr_sync_handles.hh
+   engines/bnpr/bnpr_sync.hh
++  engines/bnpr/bnpr_strokegen_buffer_pool.hh
++  engines/bnpr/bnpr_strokegen_texture_pool.hh
++  engines/bnpr/bnpr_strokegen_pass.hh
+ )
+ 
+ set(LIB
+@@ -700,15 +704,10 @@ set(GLSL_SRC
+   engines/image/shaders/image_engine_depth_frag.glsl
+   engines/image/shaders/image_engine_depth_vert.glsl
+ 
+-
+-
+-
+-
++  engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+ 
+   engines/bnpr/bnpr_defines.hh
+   engines/bnpr/bnpr_shader_shared.hh
+-
+-
+ )
+ 
+ set(GLSL_C)
+diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+index dfd63e92d97..1ffca605ca9 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+@@ -9,5 +9,7 @@
+  * dragging larger headers into the createInfo pipeline which would cause problems.
+  */
+ 
+-
+ #pragma once
++
++
++#define GROUP_SIZE_STROKEGEN_TEST 512
+diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+index 5f6a7374b89..54517634682 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+@@ -23,7 +23,9 @@
+ #include "draw_pass.hh"
+ #include "bnpr_shader.hh"
+ #include "bnpr_sync.hh"
+-
++#include "bnpr_strokegen_buffer_pool.hh"
++#include "bnpr_strokegen_texture_pool.hh"
++#include "bnpr_strokegen_pass.hh"
+ 
+ namespace blender::bnpr
+ {
+@@ -37,6 +39,9 @@ namespace blender::bnpr
+     /** Shading Modules */
+     ShaderModule shaders; // singleton class for handling GPUShader(s)
+     SyncModule sync;
++    GPUBufferPoolModule   strokegen_buffers;
++    GPUTexturePoolModule  strokegen_textures;
++    StrokeGenPassModule   strokegen_passes;
+ 
+     /** Input data. */
+     Depsgraph *depsgraph;
+@@ -65,7 +70,10 @@ namespace blender::bnpr
+   public:
+     Instance() :
+     shaders(*ShaderModule::module_get()),
+-    sync(*this)
++    sync(*this),
++    strokegen_buffers(*this),
++    strokegen_textures(*this),
++    strokegen_passes(shaders, strokegen_buffers, strokegen_textures)
+     {
+     };
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+index 7bf72caf057..75cc42e3c09 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+@@ -90,6 +90,8 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
+       return "basic_depth_mesh_conservative";
+     case POINTCLOUD_DEPTH_CONSERVATIVE:
+       return "basic_depth_pointcloud_conservative";
++    case COMPUTE_TEST:
++      return "bnpr_strokegen_test";
+ 
+     /* To avoid compiler warning about missing case. */
+     case MAX_SHADER_TYPE:
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
+index 9b756e213a4..ff758760c22 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
+@@ -24,7 +24,8 @@ namespace blender::bnpr {
+ 
+ /* Keep alphabetical order and clean prefix. */
+ enum eShaderType {
+-  DEPTH = 0,
++  COMPUTE_TEST = 0,
++  DEPTH,
+   POINTCLOUD_DEPTH,
+   CURVES_DEPTH,
+   DEPTH_CONSERVATIVE,
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+index 9cbb254e58c..4a33610836a 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+@@ -6,4 +6,92 @@
+  * language.
+  */
+ 
+-#pragma once
++#ifndef USE_GPU_SHADER_CREATE_INFO
++#  pragma once
++
++#  include "BLI_memory_utils.hh"
++#  include "DRW_gpu_wrapper.hh"
++
++#  include "draw_manager.hh"
++#  include "draw_pass.hh"
++
++#  include "bnpr_defines.hh"
++
++#  include "GPU_shader_shared.h"
++
++namespace blender::bnpr {
++
++using namespace draw;
++
++constexpr eGPUSamplerState no_filter = GPU_SAMPLER_DEFAULT;
++constexpr eGPUSamplerState with_filter = GPU_SAMPLER_FILTER;
++
++#endif
++
++
++
++#define UBO_MIN_MAX_SUPPORTED_SIZE 1 << 14
++
++/* -------------------------------------------------------------------- */
++/** \name Debug Mode
++ * \{ */
++
++/** These are just to make more sense of G.debug_value's values. Reserved range is 1-30. */
++enum eDebugMode : uint32_t {
++  DEBUG_NONE = 0u,
++  /**
++   * Gradient showing light evaluation hot-spots.
++   */
++  DEBUG_LIGHT_CULLING = 1u,
++  /**
++   * Show incorrectly downsample tiles in red.
++   */
++  DEBUG_HIZ_VALIDATION = 2u,
++  /**
++   * Tile-maps to screen. Is also present in other modes.
++   * - Black pixels, no pages allocated.
++   * - Green pixels, pages cached.
++   * - Red pixels, pages allocated.
++   */
++  DEBUG_SHADOW_TILEMAPS = 10u,
++  /**
++   * Random color per pages. Validates page density allocation and sampling.
++   */
++  DEBUG_SHADOW_PAGES = 11u,
++  /**
++   * Outputs random color per tile-map (or tile-map level). Validates tile-maps coverage.
++   * Black means not covered by any tile-maps LOD of the shadow.
++   */
++  DEBUG_SHADOW_LOD = 12u,
++  /**
++   * Outputs white pixels for pages allocated and black pixels for unused pages.
++   * This needs DEBUG_SHADOW_PAGE_ALLOCATION_ENABLED defined in order to work.
++   */
++  DEBUG_SHADOW_PAGE_ALLOCATION = 13u,
++  /**
++   * Outputs the tile-map atlas. Default tile-map is too big for the usual screen resolution.
++   * Try lowering SHADOW_TILEMAP_PER_ROW and SHADOW_MAX_TILEMAP before using this option.
++   */
++  DEBUG_SHADOW_TILE_ALLOCATION = 14u,
++  /**
++   * Visualize linear depth stored in the atlas regions of the active light.
++   * This way, one can check if the rendering, the copying and the shadow sampling functions works.
++   */
++  DEBUG_SHADOW_SHADOW_DEPTH = 15u
++};
++/** \} */
++
++
++
++
++#ifdef __cplusplus
++
++// Template to set buffer size in compile time
++using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
++
++
++}
++
++
++// namespace blender::bnpr
++#endif
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+new file mode 100644
+index 00000000000..39d96265894
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+@@ -0,0 +1,25 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup bnpr
++ */
++
++#include "bnpr_strokegen_buffer_pool.hh"
++#include "bnpr_instance.hh"
++
++namespace blender::bnpr
++{
++  void GPUBufferPoolModule::sync(Object* object)
++  {
++  }
++
++  void GPUBufferPoolModule::end_sync()
++  {
++    // arr_buf_test_.resize(4096); // maybe needed for a few special buffers
++  }
++
++
++
++}
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+new file mode 100644
+index 00000000000..7c2e58abe49
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+@@ -0,0 +1,37 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup bnpr
++ */
++
++#pragma once
++
++#include "bnpr_shader_shared.hh"
++
++namespace blender::bnpr
++{
++  class Instance;
++
++  class GPUBufferPoolModule
++  {
++    friend class StrokeGenPassModule;
++
++  private:
++    /** Compute Resources */
++    StrokeGenTestBuf arr_buf_test_;
++
++    /** Instance */
++    Instance &instance;
++
++
++  public:
++    GPUBufferPoolModule(Instance &inst) : instance(inst) {};
++    ~GPUBufferPoolModule() {};
++
++    void sync(Object* object);
++    void end_sync();
++
++  };
++}
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+new file mode 100644
+index 00000000000..44a2c7bc6db
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+@@ -0,0 +1,34 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup bnpr
++ *
++ */
++
++#include "bnpr_strokegen_pass.hh"
++
++namespace blender::bnpr
++{
++  using namespace blender;
++
++
++  void StrokeGenPassModule::sync_(
++    GPUBufferPoolModule& strokegen_buffers,
++    GPUTexturePoolModule& strokegen_texture_pool)
++  {
++    pass_comp_test.init();
++    {
++      auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
++      sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
++      sub.bind_ssbo("buf_test", strokegen_buffers.arr_buf_test_);
++      sub.dispatch(int3(32, 1, 1));
++      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
++    }
++  }
++
++  void StrokeGenPassModule::end_sync_()
++  {
++  }
++}
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+new file mode 100644
+index 00000000000..c6335e57dd9
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+@@ -0,0 +1,56 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup bnpr
++ */
++
++#pragma once
++
++#include "draw_pass.hh"
++#include "draw_manager.hh"
++
++#include "bnpr_shader.hh"
++#include "bnpr_shader_shared.hh"
++#include "bnpr_strokegen_buffer_pool.hh"
++#include "bnpr_strokegen_texture_pool.hh"
++#include "bnpr_strokegen_pass.hh"
++
++namespace blender::bnpr
++{
++  class Instance;
++
++  class StrokeGenPassModule // similar to "LineDrawingRenderPass"
++  {
++  private:
++    /** Compute Passes */
++    draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
++
++    /** Instance */
++    ShaderModule &shaders_;
++    GPUBufferPoolModule& buffers_;
++    GPUTexturePoolModule& textures_;
++
++    void sync_(GPUBufferPoolModule& strokegen_buffers, GPUTexturePoolModule& strokegen_texture_pool);
++    void end_sync_();
++
++
++  public:
++    StrokeGenPassModule(
++      ShaderModule          &strokegen_shaders,
++      GPUBufferPoolModule   &instance_buffers,
++      GPUTexturePoolModule  &strokegen_textures
++    ) :
++      shaders_(strokegen_shaders),
++      buffers_(instance_buffers),
++      textures_(strokegen_textures)
++    {};
++
++    ~StrokeGenPassModule() {};
++
++    void sync() { sync_(buffers_, textures_); }
++    void end_sync() { end_sync_(); }
++  };
++}
++
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
+new file mode 100644
+index 00000000000..002a9d2b4b0
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
+@@ -0,0 +1,15 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup bnpr
++ */
++
++#include "bnpr_strokegen_texture_pool.hh"
++#include "bnpr_instance.hh"
++
++namespace blender::bnpr
++{
++
++}
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+new file mode 100644
+index 00000000000..9250260ce83
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+@@ -0,0 +1,35 @@
++﻿/* SPDX-License-Identifier: GPL-2.0-or-later
++* Copyright 2021 Blender Foundation.
++ */
++
++/** \file
++ * \ingroup bnpr
++ */
++
++#pragma once
++
++#include "bnpr_shader_shared.hh"
++
++namespace blender::bnpr
++{
++  class Instance;
++
++  class GPUTexturePoolModule
++  {
++  private:
++    /** Compute Resources */
++    StrokeGenTestBuf arr_buf_test_;
++
++    /** Instance */
++    Instance &instance;
++
++
++  public:
++    GPUTexturePoolModule(Instance &inst) : instance(inst) {};
++    ~GPUTexturePoolModule() {};
++
++    void sync(Object* object) {};
++    void end_sync() {};
++
++  };
++}
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+index 5bff2b58f9e..0bf3e988214 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+@@ -35,11 +35,5 @@ namespace blender::bnpr
+     dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
+   }
+ 
+-  // ObjectHandle& SyncModule::sync_object(Object* ob)
+-  // {
+-  //   DrawEngineType *owner = (DrawEngineType *)&DRW_engine_viewport_bnpr_type;
+-  //   return ObjectHandle();
+-  // }
+-
+ 
+ }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+index b16e3dda61f..696559fcc48 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+@@ -44,6 +44,8 @@ namespace blender::bnpr
+                    const draw::ObjectRef &ob_ref) {};
+   };
+ 
++
++
+ }
+ 
+ 
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+new file mode 100644
+index 00000000000..4bec9ae766b
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+@@ -0,0 +1,57 @@
++
++/**
++ * Sort the lights by their Z distance to the camera.
++ * Outputs ordered light buffer.
++ * One thread processes one Light entity.
++ */
++
++// #pragma BLENDER_REQUIRE(common_math_lib.glsl)
++
++uint buf_test[/*gl_WorkGroupSize.x*/4096];
++
++void main()
++{
++  // uint src_index = gl_GlobalInvocationID.x;
++  // bool valid_thread = true;
++//
++  // if (src_index >= light_cull_buf.visible_count) {
++  //   /* Do not return because we use barriers later on (which need uniform control flow).
++  //    * Just process the same last item but avoid insertion. */
++  //   src_index = light_cull_buf.visible_count - 1;
++  //   valid_thread = false;
++  // }
++//
++  // float local_zdist = in_zdist_buf[src_index];
++//
++  // int prefix_sum = 0;
++  // /* Iterate over the whole key buffer. */
++  // uint iter = divide_ceil(light_cull_buf.visible_count, gl_WorkGroupSize.x);
++  // for (uint i = 0u; i < iter; i++) {
++  //   uint index = gl_WorkGroupSize.x * i + gl_LocalInvocationID.x;
++  //   /* NOTE: This will load duplicated values, but they will be discarded. */
++  //   index = min(index, light_cull_buf.visible_count - 1);
++  //   zdists_cache[gl_LocalInvocationID.x] = in_zdist_buf[index];
++//
++  //   barrier();
++//
++  //   /* Iterate over the cache line. */
++  //   uint line_end = min(gl_WorkGroupSize.x, light_cull_buf.visible_count - gl_WorkGroupSize.x * i);
++  //   for (uint j = 0u; j < line_end; j++) {
++  //     if (zdists_cache[j] < local_zdist) {
++  //       prefix_sum++;
++  //     }
++  //     else if (zdists_cache[j] == local_zdist) {
++  //       /* Same depth, use index to order and avoid same prefix for 2 different lights. */
++  //       if ((gl_WorkGroupSize.x * i + j) < src_index) {
++  //         prefix_sum++;
++  //       }
++  //     }
++  //   }
++  // }
++//
++  // if (valid_thread) {
++  //   /* Copy sorted light to render light buffer. */
++  //   uint input_index = in_key_buf[src_index];
++  //   out_light_buf[prefix_sum] = in_light_buf[input_index];
++  // }
++}
+diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+new file mode 100644
+index 00000000000..0d1f735983d
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+@@ -0,0 +1,68 @@
++/* SPDX-License-Identifier: GPL-2.0-or-later */
++
++#include "bnpr_defines.hh"
++#include "gpu_shader_create_info.hh"
++
++/* -------------------------------------------------------------------- */
++/** \name Tutorial
++ * \{ */
++
++/* For details, see "gpu_shader_create_info.hh" */
++// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_comp)
++  // .do_static_compilation(true)
++
++  /* -------------------------------------------------------------------- */
++  /* Name of other infos to recursively merge with this one.
++   * No data slot must overlap otherwise we throw an error. */
++  // .additional_info("eevee_shared", "draw_view", "draw_view_culling")
++  // .define("DOF_BOKEH_TEXTURE", "false")
++
++  /* -------------------------------------------------------------------- */
++  /** Resources bindings points
++  // .uniform_buf(6, "DepthOfFieldData", "dof_buf")
++  // .storage_buf(0, Qualifier::READ_WRITE, "LightCullingData", "light_cull_buf")
++  // .storage_buf(1, Qualifier::READ, "LightData", "in_light_buf[]")
++  // .storage_buf(2, Qualifier::WRITE, "LightData", "out_light_buf[]")
++  // .sampler(0, ImageType::FLOAT_2D, "downsample_tx")
++  // .image(0, GPU_RGBA16F, Qualifier::READ_WRITE, ImageType::FLOAT_2D, "inout_color_lod0_img")
++  /*          eGPUTextureFormat                     ImageType  */
++
++  /* -------------------------------------------------------------------- */
++  /** Comptue shader
++  // .local_group_size(CULLING_SELECT_GROUP_SIZE) /* <== from "bnpr_defines.hh" */
++  // .compute_source("eevee_light_culling_select_comp.glsl");
++
++  /* -------------------------------------------------------------------- */
++  // Vertex & Fragment shader
++  // .vertex_in(0, Type::VEC3, "pos")
++  // .vertex_in(1, Type::VEC3, "nor")
++  // .vertex_source("eevee_geom_mesh_vert.glsl")
++  //
++  // .fragment_out(0, Type::VEC4, "out_radiance", DualBlend::SRC_0)
++  // .fragment_out(1, Type::VEC4, "out_transmittance", DualBlend::SRC_1)
++  // .fragment_source("eevee_surf_forward_frag.glsl")
++  //
++  /* In order to use .vertex_out for vs output,
++   * we firstly need to define an interface:
++// GPU_SHADER_INTERFACE_INFO(interface_info_name, "interp")
++  // .smooth(Type::VEC3, "a") /* smooth: conventional interpolation for fragments */
++  // .flat(Type::VEC3, "b"); /* flat: no interpolation, instead, use attribute from a "provoking vertex" */
++  // .noperspective(Type::VEC3, "c") /* interpolation, without perspective correction */
++  /* Then use the interface to declare a .vertex_out: */
++  // .vertex_out(interface_info_name)
++
++/** \} */
++
++
++
++
++/* -------------------------------------------------------------------- */
++/** \test
++ * \{ */
++GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
++  .do_static_compilation(true)
++  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
++  .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_strokegen_test_comp.glsl");
++
++/** \} */
+diff --git a/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
+deleted file mode 100644
+index e275d208c7a..00000000000
+--- a/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
++++ /dev/null
+@@ -1,65 +0,0 @@
+-/* SPDX-License-Identifier: GPL-2.0-or-later */
+-
+-#include "gpu_shader_create_info.hh"
+-
+-/* -------------------------------------------------------------------- */
+-/** \name Conservative Rasterization
+- *
+- * Allow selection of sub-pixel objects.
+- * \{ */
+-
+-GPU_SHADER_CREATE_INFO(basic_conservative)
+-    .geometry_layout(PrimitiveIn::TRIANGLES, PrimitiveOut::TRIANGLE_STRIP, 3)
+-    .geometry_source("basic_conservative_depth_geom.glsl");
+-
+-/** \} */
+-
+-/* -------------------------------------------------------------------- */
+-/** \name Object types
+- * \{ */
+-
+-GPU_SHADER_CREATE_INFO(basic_mesh)
+-    .vertex_in(0, Type::VEC3, "pos")
+-    .vertex_source("basic_depth_vert.glsl")
+-    .additional_info("draw_mesh");
+-
+-GPU_SHADER_CREATE_INFO(basic_pointcloud)
+-    .vertex_source("basic_depth_pointcloud_vert.glsl")
+-    .additional_info("draw_pointcloud");
+-
+-GPU_SHADER_CREATE_INFO(basic_curves)
+-    .vertex_source("basic_depth_curves_vert.glsl")
+-    .additional_info("draw_hair");
+-/** \} */
+-
+-/* -------------------------------------------------------------------- */
+-/** \name Variations Declaration
+- * \{ */
+-
+-#define BASIC_FINAL_VARIATION(name, ...) \
+-  GPU_SHADER_CREATE_INFO(name).additional_info(__VA_ARGS__).do_static_compilation(true);
+-
+-#define BASIC_CLIPPING_VARIATIONS(prefix, ...) \
+-  BASIC_FINAL_VARIATION(prefix##_clipped, "drw_clipped", __VA_ARGS__) \
+-  BASIC_FINAL_VARIATION(prefix, __VA_ARGS__)
+-
+-#define BASIC_CONSERVATIVE_VARIATIONS(prefix, ...) \
+-  BASIC_CLIPPING_VARIATIONS(prefix##_conservative, "basic_conservative", __VA_ARGS__) \
+-  BASIC_CLIPPING_VARIATIONS(prefix, __VA_ARGS__)
+-
+-#define BASIC_OBTYPE_VARIATIONS(prefix, ...) \
+-  BASIC_CONSERVATIVE_VARIATIONS(prefix##_mesh, "basic_mesh", __VA_ARGS__) \
+-  BASIC_CONSERVATIVE_VARIATIONS(prefix##_pointcloud, "basic_pointcloud", __VA_ARGS__) \
+-  BASIC_CLIPPING_VARIATIONS(prefix##_curves, "basic_curves", __VA_ARGS__)
+-
+-/** \} */
+-
+-/* -------------------------------------------------------------------- */
+-/** \name Depth shader types.
+- * \{ */
+-
+-GPU_SHADER_CREATE_INFO(basic_depth).fragment_source("basic_depth_frag.glsl");
+-
+-BASIC_OBTYPE_VARIATIONS(basic_depth, "basic_depth", "draw_globals");
+-
+-/** \} */
+diff --git a/source/blender/gpu/CMakeLists.txt b/source/blender/gpu/CMakeLists.txt
+index 02793fa74be..326ff061138 100644
+--- a/source/blender/gpu/CMakeLists.txt
++++ b/source/blender/gpu/CMakeLists.txt
+@@ -29,6 +29,7 @@ set(INC
+   # For *_info.hh includes.
+   ../compositor/realtime_compositor
+   ../draw/engines/eevee_next
++  ../draw/engines/bnpr
+   ../draw/intern
+ 
+   # For node muting stuff.
+@@ -590,6 +591,8 @@ set(SRC_SHADER_CREATE_INFOS
+   ../draw/engines/eevee/shaders/infos/eevee_legacy_volume_info.hh
+ 
+   ../draw/engines/image/shaders/infos/engine_image_info.hh
++
++  ../draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+   ../draw/intern/shaders/draw_debug_info.hh
+   ../draw/intern/shaders/draw_fullscreen_info.hh
+   ../draw/intern/shaders/draw_hair_refine_info.hh
+-- 
+2.38.1.windows.1
+
+
+From 1a95c1f492f07cb50eb6a6ca1458e0966012c3c0 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sun, 11 Dec 2022 19:39:06 +0800
+Subject: [PATCH 07/11] Add sync_object
+
+to sync a mesh, I need a material module
+---
+ .../bnpr/bnpr_strokegen_buffer_pool.hh        |  6 ++---
+ .../draw/engines/bnpr/bnpr_strokegen_pass.hh  |  4 ++--
+ .../bnpr/bnpr_strokegen_texture_pool.hh       | 12 +++++-----
+ source/blender/draw/engines/bnpr/bnpr_sync.cc | 22 +++++++++++++++++--
+ source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +-
+ .../draw/engines/bnpr/bnpr_sync_handles.hh    |  3 +--
+ 6 files changed, 34 insertions(+), 15 deletions(-)
+
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+index 7c2e58abe49..c821086ae5d 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+@@ -19,12 +19,12 @@ namespace blender::bnpr
+     friend class StrokeGenPassModule;
+ 
+   private:
+-    /** Compute Resources */
+-    StrokeGenTestBuf arr_buf_test_;
+-
+     /** Instance */
+     Instance &instance;
+ 
++    /** Compute Resources */
++    StrokeGenTestBuf arr_buf_test_;
++
+ 
+   public:
+     GPUBufferPoolModule(Instance &inst) : instance(inst) {};
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+index c6335e57dd9..3848a035fc9 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+@@ -39,11 +39,11 @@ namespace blender::bnpr
+   public:
+     StrokeGenPassModule(
+       ShaderModule          &strokegen_shaders,
+-      GPUBufferPoolModule   &instance_buffers,
++      GPUBufferPoolModule   &strokegen_buffers,
+       GPUTexturePoolModule  &strokegen_textures
+     ) :
+       shaders_(strokegen_shaders),
+-      buffers_(instance_buffers),
++      buffers_(strokegen_buffers),
+       textures_(strokegen_textures)
+     {};
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+index 9250260ce83..25a1b6612f3 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+@@ -17,15 +17,17 @@ namespace blender::bnpr
+   class GPUTexturePoolModule
+   {
+   private:
+-    /** Compute Resources */
+-    StrokeGenTestBuf arr_buf_test_;
+-
+     /** Instance */
+-    Instance &instance;
++    Instance &instance_;
++
++    /** Compute Resources */
++    TextureFromPool strokegen_tex_test_;
+ 
+ 
+   public:
+-    GPUTexturePoolModule(Instance &inst) : instance(inst) {};
++    GPUTexturePoolModule(Instance &inst) :
++      instance_(inst),
++      strokegen_tex_test_("StrokegenTexture_Test"){};
+     ~GPUTexturePoolModule() {};
+ 
+     void sync(Object* object) {};
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+index 0bf3e988214..e8201ebad65 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+@@ -23,17 +23,35 @@
+ 
+ namespace blender::bnpr
+ {
+-
+   /* -------------------------------------------------------------------- */
+   /** \name Draw Data
+    *
+    * \{ */
+ 
+-  static void draw_data_init_cb(struct DrawData *dd)
++  static void draw_data_init_cb(struct DrawData* dd)
+   {
+     /* Object has just been created or was never evaluated by the engine. */
+     dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
+   }
+ 
+ 
++  ObjectHandle& SyncModule::sync_object(Object* ob)
++  {
++    DrawEngineType* owner = (DrawEngineType*)&DRW_engine_viewport_bnpr_type;
++    struct DrawData* dd = DRW_drawdata_ensure(
++      (ID*)ob, owner, sizeof(ObjectHandle), draw_data_init_cb, nullptr);
++
++    ObjectHandle &dd_bnpr = *reinterpret_cast<ObjectHandle*>(dd); // draw-engine specific draw data.
++
++    if (dd_bnpr.object_key.ob == nullptr)
++    {
++      dd_bnpr.object_key = ObjectKey(ob);
++    }
++
++
++    return dd_bnpr;
++  }
++
++
++
+ }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+index 696559fcc48..4b8ca2a1656 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+@@ -34,7 +34,7 @@ namespace blender::bnpr
+     SyncModule(Instance &inst) : inst_(inst) {};
+     ~SyncModule(){};
+ 
+-    ObjectHandle &sync_object(Object *ob) {};
++    ObjectHandle &sync_object(Object *ob);
+     WorldHandle &sync_world(::World *world) {};
+     SceneHandle &sync_scene(::Scene *scene) {};
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+index 8fd0fc90070..3560f7a3926 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+@@ -125,8 +125,7 @@ namespace blender::bnpr
+   /** \} */
+ 
+   /* -------------------------------------------------------------------- */
+-  /** \name Sync Module
+-   *
++  /** \name Engine-Specific Draw-Data
+    * \{ */
+ 
+   struct ObjectHandle : public DrawData
+-- 
+2.38.1.windows.1
+
+
+From aeb4fd04eeceaa63b77566011e1d876318760edb Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Mon, 12 Dec 2022 00:06:55 +0800
+Subject: [PATCH 08/11] Experiment with mesh_sync and actual shader dispatch.
+
+1) Compute dispatch does not run since we haven't implemented
+instance->draw_viewport yet.
+2) mesh_sync calls dispatch, but requires the draw manager to submit the passes including the compute shaders, and submission should happen in instance->draw_viewport
+---
+ .../draw/engines/bnpr/bnpr_instance.cc        | 34 +++++++++++++++++--
+ .../draw/engines/bnpr/bnpr_strokegen_pass.cc  | 12 +++----
+ .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 10 +++---
+ source/blender/draw/engines/bnpr/bnpr_sync.cc | 24 +++++++++++++
+ source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +-
+ .../shaders/bnpr_strokegen_test_comp.glsl     |  4 +--
+ 6 files changed, 67 insertions(+), 19 deletions(-)
+
+diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+index 5139b0c5f49..2bb9985950d 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+@@ -81,8 +81,38 @@ namespace blender::bnpr
+   }
+ 
+   void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
+-  {
+-    /* Add object draw calls to passes. (Populate render graph) */
++  { /* Add object draw calls to passes. (Populate render graph) */
++    Object *ob = object_ref.object;
++
++    const bool is_renderable_type = ELEM(ob->type, OB_CURVES, OB_GPENCIL, OB_MESH, OB_LAMP);
++    const int ob_visibility = DRW_object_visibility_in_active_context(ob);
++    const bool partsys_is_visible = (ob_visibility & OB_VISIBLE_PARTICLES) != 0 &&
++                                    (ob->type == OB_MESH);
++    const bool object_is_visible = DRW_object_is_renderable(ob) &&
++                                   (ob_visibility & OB_VISIBLE_SELF) != 0;
++
++    if (!is_renderable_type || (!partsys_is_visible && !object_is_visible)) {
++      return;
++    }
++
++    /* fclem: TODO cleanup. */
++    ObjectRef ob_ref = DRW_object_ref_get(ob);
++    ResourceHandle res_handle = manager.resource_handle(ob_ref);
++
++    ObjectHandle &ob_handle = sync.sync_object(ob);
++
++
++    if (object_is_visible) {
++      switch (ob->type) {
++      case OB_MESH:
++        sync.sync_mesh(ob, ob_handle, res_handle, ob_ref);
++        break;
++      default:
++        break;
++      }
++    }
++
++    ob_handle.reset_recalc_flag();
+   }
+ 
+   void Instance::end_sync(Manager&)
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+index 44a2c7bc6db..ec1d4f33f10 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+@@ -13,22 +13,18 @@ namespace blender::bnpr
+ {
+   using namespace blender;
+ 
+-
+-  void StrokeGenPassModule::sync_(
+-    GPUBufferPoolModule& strokegen_buffers,
+-    GPUTexturePoolModule& strokegen_texture_pool)
++  void StrokeGenPassModule::dispatch_extract_mesh_contour(Object* ob)
+   {
+     pass_comp_test.init();
+     {
+       auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
+       sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
+-      sub.bind_ssbo("buf_test", strokegen_buffers.arr_buf_test_);
++      sub.bind_ssbo("buf_test", buffers_.arr_buf_test_);
+       sub.dispatch(int3(32, 1, 1));
+       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+     }
+   }
+ 
+-  void StrokeGenPassModule::end_sync_()
+-  {
+-  }
++
++
+ }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+index 3848a035fc9..edd4d92edfb 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+@@ -32,9 +32,6 @@ namespace blender::bnpr
+     GPUBufferPoolModule& buffers_;
+     GPUTexturePoolModule& textures_;
+ 
+-    void sync_(GPUBufferPoolModule& strokegen_buffers, GPUTexturePoolModule& strokegen_texture_pool);
+-    void end_sync_();
+-
+ 
+   public:
+     StrokeGenPassModule(
+@@ -49,8 +46,11 @@ namespace blender::bnpr
+ 
+     ~StrokeGenPassModule() {};
+ 
+-    void sync() { sync_(buffers_, textures_); }
+-    void end_sync() { end_sync_(); }
++    /** Passes Batched by Usages */
++    void dispatch_extract_mesh_contour(Object* ob);
++
++
++
+   };
+ }
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+index e8201ebad65..8c94eed402b 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+@@ -21,6 +21,9 @@
+ #include "bnpr_instance.hh"
+ #include "bnpr_sync.hh"
+ 
++#include "draw_cache_extract.hh"
++#include "draw_cache_impl.h"
++
+ namespace blender::bnpr
+ {
+   /* -------------------------------------------------------------------- */
+@@ -52,6 +55,27 @@ namespace blender::bnpr
+     return dd_bnpr;
+   }
+ 
++  void SyncModule::sync_mesh(
++    Object* ob, ObjectHandle& ob_handle,
++    draw::ResourceHandle res_handle, const draw::ObjectRef& ob_ref
++  )
++  {
++    bool mesh_is_manifold;
++    GPUBatch *geobatch = DRW_cache_object_edge_detection_get(ob, &mesh_is_manifold);
++
++    if (geobatch == nullptr) return;
+ 
++    // Old way to do this:
++    // See "draw_subdiv_build_tris_buffer"
++    // const char *defines = "#define XXX\n";
++    // GPUShader *shader = get_strokegen_shader(...)
++    //
++    // eevvee_next way to do this:
++    //  strokegen_passes.dispatch_extract_mesh_contour(ob);
++    //  strokegen_passes.dispatch_XXX(...);
++    //  ... ... ...
++    inst_.strokegen_passes.dispatch_extract_mesh_contour(ob);
+ 
++
++  }
+ }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+index 4b8ca2a1656..974b162092d 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
+@@ -41,7 +41,7 @@ namespace blender::bnpr
+     void sync_mesh(Object *ob,
+                    ObjectHandle &ob_handle,
+                    draw::ResourceHandle res_handle,
+-                   const draw::ObjectRef &ob_ref) {};
++                   const draw::ObjectRef &ob_ref);
+   };
+ 
+ 
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+index 4bec9ae766b..5d0304865db 100644
+--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+@@ -5,9 +5,7 @@
+  * One thread processes one Light entity.
+  */
+ 
+-// #pragma BLENDER_REQUIRE(common_math_lib.glsl)
+-
+-uint buf_test[/*gl_WorkGroupSize.x*/4096];
++#pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
+ 
+ void main()
+ {
+-- 
+2.38.1.windows.1
+
+
+From a5e0a0429066c6d0fd22dda96dba68f97c80ea39 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Wed, 21 Dec 2022 22:21:56 +0800
+Subject: [PATCH 09/11] submit test compute pass
+
+---
+ .../draw/engines/bnpr/bnpr_instance.cc        | 10 ++--
+ .../draw/engines/bnpr/bnpr_instance.hh        |  2 +-
+ .../blender/draw/engines/bnpr/bnpr_shader.cc  |  2 +-
+ .../draw/engines/bnpr/bnpr_shader_shared.hh   | 58 -------------------
+ .../bnpr/bnpr_strokegen_buffer_pool.hh        |  2 +-
+ .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |  4 +-
+ .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 14 ++++-
+ source/blender/draw/engines/bnpr/bnpr_sync.cc |  2 +-
+ .../shaders/bnpr_strokegen_test_comp.glsl     | 48 +--------------
+ .../bnpr/shaders/infos/bnpr_test_info.hh      |  8 ++-
+ 10 files changed, 32 insertions(+), 118 deletions(-)
+
+diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+index 2bb9985950d..46be7fd8d31 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+@@ -80,6 +80,11 @@ namespace blender::bnpr
+     /* Init draw passes and manager related stuff. (Begin render graph) */
+   }
+ 
++  void Instance::end_sync(Manager&)
++  {
++    /* Post processing after all object. (End render graph) */
++  }
++
+   void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
+   { /* Add object draw calls to passes. (Populate render graph) */
+     Object *ob = object_ref.object;
+@@ -115,10 +120,6 @@ namespace blender::bnpr
+     ob_handle.reset_recalc_flag();
+   }
+ 
+-  void Instance::end_sync(Manager&)
+-  {
+-    /* Post processing after all object. (End render graph) */
+-  }
+ 
+   /** \} */
+ 
+@@ -135,6 +136,7 @@ namespace blender::bnpr
+     GPUTexture* color_tx)
+   {
+     /* Submit passes here. (Execute render graph) */
++    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::EXTRACT_MESH_CONTOUR), view);
+   }
+ 
+   /** \} */
+diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+index 54517634682..6d7532c8ea3 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+@@ -82,10 +82,10 @@ namespace blender::bnpr
+     void update_eval_members();
+ 
+     void begin_sync(Manager& manager);
++    void end_sync(Manager& manager);
+ 
+     void object_sync(Manager& manager, ObjectRef& object_ref);
+ 
+-    void end_sync(Manager& /* manager */);
+ 
+     void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+                        GPUTexture* color_tx);
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+index 75cc42e3c09..c77bc4675fa 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+@@ -91,7 +91,7 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
+     case POINTCLOUD_DEPTH_CONSERVATIVE:
+       return "basic_depth_pointcloud_conservative";
+     case COMPUTE_TEST:
+-      return "bnpr_strokegen_test";
++      return "bnpr_strokegen_test_xxx";
+ 
+     /* To avoid compiler warning about missing case. */
+     case MAX_SHADER_TYPE:
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+index 4a33610836a..7b98d823540 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+@@ -23,67 +23,10 @@ namespace blender::bnpr {
+ 
+ using namespace draw;
+ 
+-constexpr eGPUSamplerState no_filter = GPU_SAMPLER_DEFAULT;
+-constexpr eGPUSamplerState with_filter = GPU_SAMPLER_FILTER;
+-
+ #endif
+ 
+ 
+ 
+-#define UBO_MIN_MAX_SUPPORTED_SIZE 1 << 14
+-
+-/* -------------------------------------------------------------------- */
+-/** \name Debug Mode
+- * \{ */
+-
+-/** These are just to make more sense of G.debug_value's values. Reserved range is 1-30. */
+-enum eDebugMode : uint32_t {
+-  DEBUG_NONE = 0u,
+-  /**
+-   * Gradient showing light evaluation hot-spots.
+-   */
+-  DEBUG_LIGHT_CULLING = 1u,
+-  /**
+-   * Show incorrectly downsample tiles in red.
+-   */
+-  DEBUG_HIZ_VALIDATION = 2u,
+-  /**
+-   * Tile-maps to screen. Is also present in other modes.
+-   * - Black pixels, no pages allocated.
+-   * - Green pixels, pages cached.
+-   * - Red pixels, pages allocated.
+-   */
+-  DEBUG_SHADOW_TILEMAPS = 10u,
+-  /**
+-   * Random color per pages. Validates page density allocation and sampling.
+-   */
+-  DEBUG_SHADOW_PAGES = 11u,
+-  /**
+-   * Outputs random color per tile-map (or tile-map level). Validates tile-maps coverage.
+-   * Black means not covered by any tile-maps LOD of the shadow.
+-   */
+-  DEBUG_SHADOW_LOD = 12u,
+-  /**
+-   * Outputs white pixels for pages allocated and black pixels for unused pages.
+-   * This needs DEBUG_SHADOW_PAGE_ALLOCATION_ENABLED defined in order to work.
+-   */
+-  DEBUG_SHADOW_PAGE_ALLOCATION = 13u,
+-  /**
+-   * Outputs the tile-map atlas. Default tile-map is too big for the usual screen resolution.
+-   * Try lowering SHADOW_TILEMAP_PER_ROW and SHADOW_MAX_TILEMAP before using this option.
+-   */
+-  DEBUG_SHADOW_TILE_ALLOCATION = 14u,
+-  /**
+-   * Visualize linear depth stored in the atlas regions of the active light.
+-   * This way, one can check if the rendering, the copying and the shadow sampling functions works.
+-   */
+-  DEBUG_SHADOW_SHADOW_DEPTH = 15u
+-};
+-/** \} */
+-
+-
+-
+-
+ #ifdef __cplusplus
+ 
+ // Template to set buffer size in compile time
+@@ -92,6 +35,5 @@ using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
+ 
+ }
+ 
+-
+ // namespace blender::bnpr
+ #endif
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+index c821086ae5d..cf017d0823f 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+@@ -23,7 +23,7 @@ namespace blender::bnpr
+     Instance &instance;
+ 
+     /** Compute Resources */
+-    StrokeGenTestBuf arr_buf_test_;
++    StrokeGenTestBuf strokegen_test_buf_;
+ 
+ 
+   public:
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+index ec1d4f33f10..058198dac13 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+@@ -13,13 +13,13 @@ namespace blender::bnpr
+ {
+   using namespace blender;
+ 
+-  void StrokeGenPassModule::dispatch_extract_mesh_contour(Object* ob)
++  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob)
+   {
+     pass_comp_test.init();
+     {
+       auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
+       sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
+-      sub.bind_ssbo("buf_test", buffers_.arr_buf_test_);
++      sub.bind_ssbo("buf_test", buffers_.strokegen_test_buf_);
+       sub.dispatch(int3(32, 1, 1));
+       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+     }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+index edd4d92edfb..6663f38eec7 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+@@ -47,9 +47,21 @@ namespace blender::bnpr
+     ~StrokeGenPassModule() {};
+ 
+     /** Passes Batched by Usages */
+-    void dispatch_extract_mesh_contour(Object* ob);
++    enum eType
++    {
++      EXTRACT_MESH_CONTOUR = 0
++    };
+ 
++    PassSimple& get_compute_pass(eType passType)
++    {
++      switch (passType) {
++        case EXTRACT_MESH_CONTOUR:
++          return pass_comp_test;
++      }
++      return pass_comp_test;
++    }
+ 
++    void rebuild_pass_extract_mesh_contour(Object* ob);
+ 
+   };
+ }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+index 8c94eed402b..f350911e958 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+@@ -74,7 +74,7 @@ namespace blender::bnpr
+     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
+     //  strokegen_passes.dispatch_XXX(...);
+     //  ... ... ...
+-    inst_.strokegen_passes.dispatch_extract_mesh_contour(ob);
++    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob);
+ 
+ 
+   }
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+index 5d0304865db..964ee4114e3 100644
+--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+@@ -1,55 +1,11 @@
+ 
+ /**
+- * Sort the lights by their Z distance to the camera.
+- * Outputs ordered light buffer.
+- * One thread processes one Light entity.
++* Testing compute shader for bnpr engine.
+  */
+ 
+ #pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
+ 
+ void main()
+ {
+-  // uint src_index = gl_GlobalInvocationID.x;
+-  // bool valid_thread = true;
+-//
+-  // if (src_index >= light_cull_buf.visible_count) {
+-  //   /* Do not return because we use barriers later on (which need uniform control flow).
+-  //    * Just process the same last item but avoid insertion. */
+-  //   src_index = light_cull_buf.visible_count - 1;
+-  //   valid_thread = false;
+-  // }
+-//
+-  // float local_zdist = in_zdist_buf[src_index];
+-//
+-  // int prefix_sum = 0;
+-  // /* Iterate over the whole key buffer. */
+-  // uint iter = divide_ceil(light_cull_buf.visible_count, gl_WorkGroupSize.x);
+-  // for (uint i = 0u; i < iter; i++) {
+-  //   uint index = gl_WorkGroupSize.x * i + gl_LocalInvocationID.x;
+-  //   /* NOTE: This will load duplicated values, but they will be discarded. */
+-  //   index = min(index, light_cull_buf.visible_count - 1);
+-  //   zdists_cache[gl_LocalInvocationID.x] = in_zdist_buf[index];
+-//
+-  //   barrier();
+-//
+-  //   /* Iterate over the cache line. */
+-  //   uint line_end = min(gl_WorkGroupSize.x, light_cull_buf.visible_count - gl_WorkGroupSize.x * i);
+-  //   for (uint j = 0u; j < line_end; j++) {
+-  //     if (zdists_cache[j] < local_zdist) {
+-  //       prefix_sum++;
+-  //     }
+-  //     else if (zdists_cache[j] == local_zdist) {
+-  //       /* Same depth, use index to order and avoid same prefix for 2 different lights. */
+-  //       if ((gl_WorkGroupSize.x * i + j) < src_index) {
+-  //         prefix_sum++;
+-  //       }
+-  //     }
+-  //   }
+-  // }
+-//
+-  // if (valid_thread) {
+-  //   /* Copy sorted light to render light buffer. */
+-  //   uint input_index = in_key_buf[src_index];
+-  //   out_light_buf[prefix_sum] = in_light_buf[input_index];
+-  // }
++
+ }
+diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+index 0d1f735983d..bea2190c8d3 100644
+--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
++++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+@@ -8,13 +8,16 @@
+  * \{ */
+ 
+ /* For details, see "gpu_shader_create_info.hh" */
+-// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_comp)
++// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
+   // .do_static_compilation(true)
+ 
+   /* -------------------------------------------------------------------- */
+   /* Name of other infos to recursively merge with this one.
+    * No data slot must overlap otherwise we throw an error. */
+   // .additional_info("eevee_shared", "draw_view", "draw_view_culling")
++
++  /* -------------------------------------------------------------------- */
++  /* Macros */
+   // .define("DOF_BOKEH_TEXTURE", "false")
+ 
+   /* -------------------------------------------------------------------- */
+@@ -55,11 +58,10 @@
+ 
+ 
+ 
+-
+ /* -------------------------------------------------------------------- */
+ /** \test
+  * \{ */
+-GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
++GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
+   .do_static_compilation(true)
+   .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
+   .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
+-- 
+2.38.1.windows.1
+
+
+From 43d5a077e025f45380709d56e6802c5de72ad384 Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Sun, 8 Jan 2023 15:26:45 +0800
+Subject: [PATCH 10/11] Testing scan & segscan
+
+scan should be alright, however need to load with stride of vec4 when read scanned buffer with vec3 elements.
+
+segscan not tested yet, there are some issue with shader_builder, which fucks up with the incremental build. I'll commit for now and rebase to master.
+---
+ source/blender/draw/CMakeLists.txt            |   4 +
+ .../blender/draw/engines/bnpr/bnpr_defines.hh |  21 +-
+ .../blender/draw/engines/bnpr/bnpr_engine.cc  |  15 +-
+ .../draw/engines/bnpr/bnpr_instance.cc        |  19 +-
+ .../draw/engines/bnpr/bnpr_instance.hh        |   5 +-
+ .../blender/draw/engines/bnpr/bnpr_shader.cc  |  12 +
+ .../blender/draw/engines/bnpr/bnpr_shader.hh  |   8 +
+ .../draw/engines/bnpr/bnpr_shader_shared.hh   | 114 +++-
+ .../bnpr/bnpr_strokegen_buffer_pool.cc        |  25 +-
+ .../bnpr/bnpr_strokegen_buffer_pool.hh        |  14 +-
+ .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |  90 ++-
+ .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 121 +++-
+ source/blender/draw/engines/bnpr/bnpr_sync.cc |   4 +-
+ .../bnpr/shaders/bnpr_hlsl_support_lib.glsl   |   8 +
+ .../bnpr_scan_no_subgroup_codegen_lib.glsl    |  69 +++
+ .../shaders/bnpr_scan_no_subgroup_lib.glsl    | 576 ++++++++++++++++++
+ .../bnpr/shaders/bnpr_scan_test_comp.glsl     | 279 +++++++++
+ .../shaders/bnpr_strokegen_test_comp.glsl     |   2 +-
+ .../bnpr/shaders/infos/bnpr_test_info.hh      | 127 +++-
+ 19 files changed, 1476 insertions(+), 37 deletions(-)
+ create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
+ create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
+ create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
+ create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+
+diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
+index e6885e1958d..a9d28e25192 100644
+--- a/source/blender/draw/CMakeLists.txt
++++ b/source/blender/draw/CMakeLists.txt
+@@ -704,7 +704,11 @@ set(GLSL_SRC
+   engines/image/shaders/image_engine_depth_frag.glsl
+   engines/image/shaders/image_engine_depth_vert.glsl
+ 
++  engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
++  engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
++  engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
+   engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
++  engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+ 
+   engines/bnpr/bnpr_defines.hh
+   engines/bnpr/bnpr_shader_shared.hh
+diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+index 1ffca605ca9..4cc48d0ddd0 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+@@ -11,5 +11,24 @@
+ 
+ #pragma once
+ 
++#define GROUP_SIZE_STROKEGEN_TEST 512u
++#define GROUP_SIZE_BNPR_SCAN_TEST_SWEEP 1024u
++#define GROUP_SIZE_BNPR_SCAN_TEST_AGGRG 1024u
++
++#define NUM_ITEMS_BNPR_SCAN_TEST 1973581u
++
++
++#ifndef GPU_SHADER
++# define BNPR_SCAN_TEST_DATA_TYPE uint4
++# define BNPR_SCAN_TEST_DATA_TYPE_STR "uvec3"
++
++// remember to update SSBOData_SegScanTest if this changes
++# define BNPR_SEG_SCAN_TEST_STRUCT_TYPE SSBOData_SegScanTest
++# define BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR "SSBOData_SegScanTest"
++#endif
++
++
++
++
++
+ 
+-#define GROUP_SIZE_STROKEGEN_TEST 512
+diff --git a/source/blender/draw/engines/bnpr/bnpr_engine.cc b/source/blender/draw/engines/bnpr/bnpr_engine.cc
+index 0e123f6e50c..aa4c039f772 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_engine.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_engine.cc
+@@ -21,6 +21,7 @@
+ 
+ #include "bnpr_instance.hh"
+ #include "bnpr_shader.hh"
++#include "intern/mallocn_intern.h"
+ 
+ 
+ using namespace blender;
+@@ -131,22 +132,20 @@ static void bnpr_draw_scene(void *vedata)
+ 
+ 
+   // TODO: not sure which is better, frame-buffer or texture list?
+-  // DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
+-  DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
++  DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
++  // DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
+ 
+   const DRWView *default_view = DRW_view_default_get();
++  const DRWView *active_view = DRW_view_get_active();
+   draw::Manager *manager = DRW_manager_get();
+   draw::View view("DefaultView", default_view);
++
+   // draw passes
+-  ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
++  ved->instance->draw_viewport(*manager, view);
+   // display error msg at the top of the render viewport
+   STRNCPY(ved->info, ved->instance->info.c_str());
+ 
+ 
+-
+-  bnpr_draw_scene_legacy(vedata);
+-
+-
+   /* Reset view for other following engines. */
+   DRW_view_set_active(nullptr);
+ }
+@@ -384,7 +383,7 @@ static void bnpr_engine_free(void)
+ 
+ static void bnpr_render_to_image(void *vedata, struct RenderEngine *engine,
+                                     struct RenderLayer *layer,
+-                                    const struct rcti *UNUSED(rect)) {
++                                    const struct rcti *rect) {
+   UNUSED_VARS(vedata, engine, layer);
+ }
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+index 46be7fd8d31..ecc7d8b9cf5 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
+@@ -20,6 +20,7 @@
+ #include "RE_pipeline.h"
+ 
+ #include "bnpr_instance.hh"
++#include "bnpr_defines.hh"
+ 
+ namespace blender::bnpr
+ {
+@@ -51,6 +52,7 @@ namespace blender::bnpr
+     camera_orig_object = camera_object_;
+ 
+     info = "";
++    frame_counter = 0;
+   }
+ 
+   void Instance::update_eval_members()
+@@ -78,6 +80,8 @@ namespace blender::bnpr
+   void Instance::begin_sync(Manager& manager)
+   {
+     /* Init draw passes and manager related stuff. (Begin render graph) */
++    strokegen_buffers.sync();
++    strokegen_passes.sync();
+   }
+ 
+   void Instance::end_sync(Manager&)
+@@ -132,11 +136,20 @@ namespace blender::bnpr
+   /** \name Rendering
+    * \{ */
+ 
+-  void Instance::draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+-    GPUTexture* color_tx)
++  void Instance::draw_viewport(Manager& manager, View& view)
+   {
+     /* Submit passes here. (Execute render graph) */
+-    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::EXTRACT_MESH_CONTOUR), view);
++    // manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::SCAN_TEST), view);
++    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::SEGSCAN_TEST), view);
++
++    if (frame_counter % 32 == 0)
++    {
++      // strokegen_passes.validate_pass_scan_test<BNPR_SCAN_TEST_DATA_TYPE>(
++      //   [](const BNPR_SCAN_TEST_DATA_TYPE& a, const BNPR_SCAN_TEST_DATA_TYPE& b) {return a == b;}
++      // );
++    }
++    frame_counter = (frame_counter + 1) % 100000000;
++
+   }
+ 
+   /** \} */
+diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+index 6d7532c8ea3..af5be3f88a8 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
+@@ -60,10 +60,12 @@ namespace blender::bnpr
+ 
+ 
+ 
++
+     /** Info string displayed at the top of the render / viewport. */
+     std::string info = "";
+     /** Debug mode from debug value. */
+     // eDebugMode debug_mode = eDebugMode::DEBUG_NONE;
++    uint frame_counter; // for debugging
+ 
+ 
+ 
+@@ -87,8 +89,7 @@ namespace blender::bnpr
+     void object_sync(Manager& manager, ObjectRef& object_ref);
+ 
+ 
+-    void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+-                       GPUTexture* color_tx);
++    void draw_viewport(Manager& manager, View& view);
+ 
+ 
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+index c77bc4675fa..ff636462f65 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
+@@ -92,6 +92,18 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
+       return "basic_depth_pointcloud_conservative";
+     case COMPUTE_TEST:
+       return "bnpr_strokegen_test_xxx";
++    case SCAN_TEST_UPSWEEP:
++      return "bnpr_scan_test_upsweep";
++    case SCAN_TEST_AGGREGATE:
++      return "bnpr_scan_test_aggregate";
++    case SCAN_TEST_DWSWEEP:
++      return "bnpr_scan_test_dwsweep";
++    case SEGSCAN_TEST_UPSWEEP:
++      return "bnpr_segscan_test_upsweep";
++    case SEGSCAN_TEST_AGGREGATE:
++      return "bnpr_segscan_test_aggregate";
++    case SEGSCAN_TEST_DWSWEEP:
++      return "bnpr_segscan_test_dwsweep";
+ 
+     /* To avoid compiler warning about missing case. */
+     case MAX_SHADER_TYPE:
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
+index ff758760c22..00e3e09625d 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
+@@ -31,6 +31,14 @@ enum eShaderType {
+   DEPTH_CONSERVATIVE,
+   POINTCLOUD_DEPTH_CONSERVATIVE,
+ 
++  SCAN_TEST_UPSWEEP,
++  SCAN_TEST_AGGREGATE,
++  SCAN_TEST_DWSWEEP,
++
++  SEGSCAN_TEST_UPSWEEP,
++  SEGSCAN_TEST_AGGREGATE,
++  SEGSCAN_TEST_DWSWEEP,
++
+   MAX_SHADER_TYPE,
+ };
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+index 7b98d823540..b7e0c17e628 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+@@ -26,12 +26,122 @@ using namespace draw;
+ #endif
+ 
+ 
++  static inline uint wang_hash(uint seed)
++  {
++    seed = (seed ^ 61) ^ (seed >> 16);
++    seed *= 9;
++    seed = seed ^ (seed >> 4);
++    seed *= 0x27d4eb2d;
++    seed = seed ^ (seed >> 15);
++    return seed;
++  }
++
++
++  static inline uint compute_num_threads(
++    uint numWorkItems,
++    uint numItemsPerThread = 1u, uint numThreadsPerItem = 1u
++  )
++  {
++    uint numThreads = numWorkItems;
++
++    if (numItemsPerThread != 1u)
++      numThreads = ((numWorkItems + numItemsPerThread - 1u) / numItemsPerThread);
++    else if (numThreadsPerItem != 1u)
++      numThreads = numThreadsPerItem * numWorkItems;
++
++    return numThreads;
++  }
++
++  static inline uint compute_num_groups(
++    uint numWorkItems, uint groupSize,
++    uint numItemsPerThread = 1u, uint numThreadsPerItem = 1u
++  )
++  {
++    const uint numThreads = compute_num_threads(
++      numWorkItems, numItemsPerThread,
++      numThreadsPerItem
++    );
++
++#if !defined(GPU_SHADER)
++    return math::max(1u, ((numThreads + groupSize - 1) / groupSize));
++#else
++      return max(1u, ((numThreads + groupSize - 1) / groupSize));
++#endif
++  }
++
++  static inline uint tree_seg_scan_encode_upsweep_hfs(uint hf_partialSum, uint hf_orig)
++  {
++    return ((hf_orig << 1) | hf_partialSum);
++  }
++
++  static inline void tree_seg_scan_decode_upsweep_hfs(
++#if !defined(GPU_SHADER)
++    uint hfs_encoded, uint& out_hf_orig, uint& out_hf_partialSum
++#else
++    uint hfs_encoded, out uint out_hf_orig, out uint out_hf_partialSum
++#endif
++  )
++  {
++    out_hf_partialSum = (hfs_encoded & 1);
++    hfs_encoded >>= 1;
++    out_hf_orig = (hfs_encoded & 1);
++  }
++
++  static inline uint tree_seg_scan_decode_upsweep_hfs_get_origHF(
++#if !defined(GPU_SHADER)
++    uint hfs_encoded
++#else
++    uint hfs_encoded
++#endif
++  )
++  {
++    hfs_encoded >>= 1;
++    return (hfs_encoded & 1);
++  }
++
++  static inline uint tree_seg_scan_decode_upsweep_hfs_get_sumHF(
++#if !defined(GPU_SHADER)
++    uint hfs_encoded
++#else
++    uint hfs_encoded
++#endif
++  )
++  {
++    return (hfs_encoded & 1);
++  }
++
++
++
++
++  struct UBData_TreeScan
++  {
++    uint num_scan_items;
++    uint num_valid_scan_threads;
++    uint num_thread_groups;
++    uint dummy;
++  };
++  BLI_STATIC_ASSERT_ALIGN(UBData_TreeScan, 16)
++
++  struct SSBOData_SegScanTest
++  {
++    uint hf;
++#ifndef GPU_SHADER
++    uint3 val;
++#else
++    uvec3 val;
++#endif
++  };
++  // BLI_STATIC_ASSERT_ALIGN(SSBOData_SegScanTest, 16)
++
++
+ 
+ #ifdef __cplusplus
+ 
+ // Template to set buffer size in compile time
+-using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
+-
++using SSBO_StrokeGenTest = draw::StorageArrayBuffer<uint, 4096 * 4, true>;
++using SSBO_BnprScanData = draw::StorageArrayBuffer<uint, 2048 * 2048 * 2, true>;
++using SSBO_BnprScanAggregates = draw::StorageArrayBuffer<uint, 512 * 16, true>;
++using UBO_BnprTreeScan = draw::UniformBuffer<UBData_TreeScan>;
+ 
+ }
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+index 39d96265894..76736b9be11 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+@@ -8,11 +8,34 @@
+ 
+ #include "bnpr_strokegen_buffer_pool.hh"
+ #include "bnpr_instance.hh"
++#include "bnpr_defines.hh"
+ 
+ namespace blender::bnpr
+ {
+-  void GPUBufferPoolModule::sync(Object* object)
++  void GPUBufferPoolModule::sync()
+   {
++    UBO_BnprTreeScan& ubo_tree_scan = ubo_bnpr_tree_scan_infos_;
++    {
++      ubo_tree_scan.num_scan_items = NUM_ITEMS_BNPR_SCAN_TEST;
++      ubo_tree_scan.num_valid_scan_threads = compute_num_threads(
++        NUM_ITEMS_BNPR_SCAN_TEST,
++        2u
++      );
++      ubo_tree_scan.num_thread_groups = compute_num_groups(
++        NUM_ITEMS_BNPR_SCAN_TEST,
++        GROUP_SIZE_BNPR_SCAN_TEST_SWEEP,
++        2u
++      );
++      ubo_tree_scan.dummy = 0u;
++    }
++    ubo_bnpr_tree_scan_infos_.push_update();
++
++
++  }
++
++  void GPUBufferPoolModule::sync_object(Object* ob)
++  {
++
+   }
+ 
+   void GPUBufferPoolModule::end_sync()
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+index cf017d0823f..c4f145aa3e1 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+@@ -23,14 +23,20 @@ namespace blender::bnpr
+     Instance &instance;
+ 
+     /** Compute Resources */
+-    StrokeGenTestBuf strokegen_test_buf_;
++    SSBO_StrokeGenTest ssbo_bnpr_test_;
+ 
++    SSBO_BnprScanData ssbo_bnpr_in_scan_data_;
++    SSBO_BnprScanData ssbo_bnpr_out_scan_data_;
++    SSBO_BnprScanAggregates ssbo_bnpr_scan_block_sum_;
++
++    UBO_BnprTreeScan ubo_bnpr_tree_scan_infos_;
+ 
+   public:
+-    GPUBufferPoolModule(Instance &inst) : instance(inst) {};
+-    ~GPUBufferPoolModule() {};
++    GPUBufferPoolModule(Instance &inst) : instance(inst) {}
++    ~GPUBufferPoolModule() {}
+ 
+-    void sync(Object* object);
++    void sync();
++    void sync_object(Object* ob);
+     void end_sync();
+ 
+   };
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+index 058198dac13..e302d2672dc 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+@@ -13,18 +13,94 @@ namespace blender::bnpr
+ {
+   using namespace blender;
+ 
+-  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob)
++  void StrokeGenPassModule::sync()
+   {
+-    pass_comp_test.init();
+-    {
+-      auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
+-      sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
+-      sub.bind_ssbo("buf_test", buffers_.strokegen_test_buf_);
+-      sub.dispatch(int3(32, 1, 1));
++    rebuild_pass_scan_test();
++    rebuild_pass_segscan_test();
++  }
++
++  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch)
++  {
++
++  }
++
++  void StrokeGenPassModule::rebuild_pass_scan_test()
++  {
++    pass_scan_test.init();
++    { // upsweep for tree-scan
++      auto& sub = pass_scan_test.sub("strokegen_scan_test_upsweep");
++      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_UPSWEEP));
++
++      // Note: keep the same slot binding as in shader_create_info
++      sub.bind_ssbo(0, buffers_.ssbo_bnpr_in_scan_data_);
++      sub.bind_ssbo(1, buffers_.ssbo_bnpr_out_scan_data_);
++      sub.bind_ssbo(2, buffers_.ssbo_bnpr_scan_block_sum_);
++      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
++
++      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
++      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
++    }
++    { // reduction for tree-scan
++      auto& sub = pass_scan_test.sub("strokegen_scan_test_aggregate");
++      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_AGGREGATE));
++
++      // Note: keep the same slot binding as in shader_create_info
++      sub.bind_ssbo(0, buffers_.ssbo_bnpr_scan_block_sum_);
++
++      sub.dispatch(int3(1, 1, 1));
++      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
++    }
++    { // down sweep for tree-scan
++      auto& sub = pass_scan_test.sub("strokegen_scan_test_dwsweep");
++      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_DWSWEEP));
++
++      // Note: keep the same slot binding as in shader_create_info
++      sub.bind_ssbo(0, buffers_.ssbo_bnpr_out_scan_data_);
++      sub.bind_ssbo(1, buffers_.ssbo_bnpr_scan_block_sum_);
++      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
++
++      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+     }
+   }
+ 
++  void StrokeGenPassModule::rebuild_pass_segscan_test()
++  {
++    pass_segscan_test.init();
++    { // upsweep for tree-scan
++      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_upsweep");
++      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_UPSWEEP));
++
++      // Note: keep the same slot binding as in shader_create_info
++      sub.bind_ssbo(0, buffers_.ssbo_bnpr_in_scan_data_);
++      sub.bind_ssbo(1, buffers_.ssbo_bnpr_out_scan_data_);
++      sub.bind_ssbo(2, buffers_.ssbo_bnpr_scan_block_sum_);
++      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
++
++      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
++      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
++    }
++    { // reduction for tree-scan
++      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_aggregate");
++      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_AGGREGATE));
++
++      // Note: keep the same slot binding as in shader_create_info
++      sub.bind_ssbo(0, buffers_.ssbo_bnpr_scan_block_sum_);
++
++      sub.dispatch(int3(1, 1, 1));
++      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
++    }
++    { // down sweep for tree-scan
++      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_dwsweep");
++      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_DWSWEEP));
+ 
++      // Note: keep the same slot binding as in shader_create_info
++      sub.bind_ssbo(0, buffers_.ssbo_bnpr_out_scan_data_);
++      sub.bind_ssbo(1, buffers_.ssbo_bnpr_scan_block_sum_);
++      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+ 
++      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
++      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
++    }
++  }
+ }
+diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+index 6663f38eec7..b2904d012df 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+@@ -26,6 +26,8 @@ namespace blender::bnpr
+   private:
+     /** Compute Passes */
+     draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
++    draw::PassSimple pass_scan_test = {"Bnpr GPU Blelloch Scan Test"};
++    draw::PassSimple pass_segscan_test = {"Bnpr GPU Blelloch SegScan Test"};
+ 
+     /** Instance */
+     ShaderModule &shaders_;
+@@ -49,20 +51,131 @@ namespace blender::bnpr
+     /** Passes Batched by Usages */
+     enum eType
+     {
+-      EXTRACT_MESH_CONTOUR = 0
++      SCAN_TEST = 0,
++      SEGSCAN_TEST
+     };
+ 
+     PassSimple& get_compute_pass(eType passType)
+     {
+       switch (passType) {
+-        case EXTRACT_MESH_CONTOUR:
+-          return pass_comp_test;
++        case SCAN_TEST:
++          return pass_scan_test;
++        case SEGSCAN_TEST:
++          return pass_segscan_test;
+       }
+       return pass_comp_test;
+     }
+ 
+-    void rebuild_pass_extract_mesh_contour(Object* ob);
++    void sync();
++    void rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch);
++    void rebuild_pass_scan_test();
++    void rebuild_pass_segscan_test();
++
++
++    template<typename T>
++    void validate_pass_scan_test(bool (*equals)(const T&, const T&));
++
++    template<typename T>
++    bool validate_inter_block_exclusive_scan(
++      const T* bufferInputVals, const T* bufferPrefixSum,
++      bool (*equals)(const T&, const T&),
++      uint num_scan_items, uint blk_size, uint numBlocks
++    );
++    template<typename T>
++    bool validate_exclusive_scan(
++      const T* bufferInputVals, const T* bufferPrefixSum,
++      bool (*equals)(const T&, const T&),
++      uint num_scan_items
++    );
++
+ 
+   };
++
++
++
++  template <typename T>
++  void StrokeGenPassModule::validate_pass_scan_test(bool (*equals)(const T&, const T&))
++  {
++    SSBO_BnprScanData& buf_scan_inputs = buffers_.ssbo_bnpr_in_scan_data_;
++    buf_scan_inputs.read();
++    T* data_scan_inputs = reinterpret_cast<T*>(buf_scan_inputs.data());
++
++    SSBO_BnprScanData& buf_scan_output = buffers_.ssbo_bnpr_out_scan_data_;
++    buf_scan_output.read();
++    T* data_scan_output = reinterpret_cast<T*>(buf_scan_output.data());
++
++    bool valid_inter_block_scan = StrokeGenPassModule::validate_inter_block_exclusive_scan<T>(
++      data_scan_inputs, data_scan_output,
++      equals,
++      buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items,
++      GROUP_SIZE_BNPR_SCAN_TEST_SWEEP * 2u,
++      buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups
++    );
++    if (!valid_inter_block_scan)
++      fprintf(stderr, "bnpr: error: INTER-BLOCK scan test failed");
++
++    bool valid_global_scan = StrokeGenPassModule::validate_exclusive_scan<T>(
++      data_scan_inputs, data_scan_output,
++      equals,
++      buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items
++    );
++    if (!valid_global_scan)
++      fprintf(stderr, "bnpr: error: GLOBAL scan test failed");
++  }
++
++
++  template <typename T>
++  bool StrokeGenPassModule::validate_inter_block_exclusive_scan(
++    const T* const bufferInputVals, const T* const bufferPrefixSum,
++    bool (*equals)(const T&, const T&),
++    uint num_scan_items, uint blk_size, uint numBlocks
++  )
++  {
++    Vector<int> failedElems(0);
++
++    for (uint blk_id = 0u; blk_id < numBlocks; blk_id++)
++    {
++      for (uint blk_offset = 0u; blk_offset < blk_size - 1u; blk_offset++)
++      {
++        // index might go out of bound
++        uint index = blk_id * blk_size + blk_offset;
++        if (index >= num_scan_items - 2u)
++          break;
++
++        if (false == equals(
++          bufferPrefixSum[index] + bufferInputVals[index],
++          bufferPrefixSum[index + 1]
++        ))
++        {
++          failedElems.append(index);
++        }
++      }
++    }
++
++    if (!failedElems.is_empty())
++    {
++      return false;
++    }
++
++    return true;
++  }
++
++
++  template <typename T>
++  bool StrokeGenPassModule::validate_exclusive_scan(const T* bufferInputVals,
++                                                    const T* bufferPrefixSum,
++                                                    bool (* equals)(const T&, const T&),
++                                                    uint num_scan_items)
++  {
++    return validate_inter_block_exclusive_scan(
++      bufferInputVals, bufferPrefixSum,
++      equals,
++      num_scan_items,
++      num_scan_items,
++      1
++    );
++  }
++
++
+ }
+ 
+diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+index f350911e958..cd708ab9fb2 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
++++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
+@@ -64,6 +64,7 @@ namespace blender::bnpr
+     GPUBatch *geobatch = DRW_cache_object_edge_detection_get(ob, &mesh_is_manifold);
+ 
+     if (geobatch == nullptr) return;
++    if (geobatch->elem == nullptr) return;
+ 
+     // Old way to do this:
+     // See "draw_subdiv_build_tris_buffer"
+@@ -74,7 +75,8 @@ namespace blender::bnpr
+     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
+     //  strokegen_passes.dispatch_XXX(...);
+     //  ... ... ...
+-    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob);
++    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob, geobatch);
++
+ 
+ 
+   }
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
+new file mode 100644
+index 00000000000..6a8328140c5
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
+@@ -0,0 +1,8 @@
++#ifndef BNPR_HLSL_SUPPORT_INCLUDED
++#define BNPR_HLSL_SUPPORT_INCLUDED
++
++// translate bit stream(s)
++#define asuint(x) floatBitsToUint(x)
++#define asfloat(x) uintBitsToFloat(x)
++
++#endif
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
+new file mode 100644
+index 00000000000..d1d65d6364e
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
+@@ -0,0 +1,69 @@
++#ifndef BNPR_SCAN_NO_SUBGROUP_CODEGEN_LIB
++#define BNPR_SCAN_NO_SUBGROUP_CODEGEN_LIB
++
++#pragma BLENDER_REQUIRE(bnpr_scan_no_subgroup_lib.glsl)
++
++/* -------------------------------------------------------------------- */
++/** \name Tree Scan LDS Cache
++ * \{ */
++DECLARE_TREE_SCAN_CACHE
++
++#ifdef IS_TREE_SEG_SCAN
++
++	DECLARE_TREE_SCAN_CACHE_HF
++
++#endif
++/** \} */
++
++
++
++/* -------------------------------------------------------------------- */
++/** \name Utility Functions
++ * \{ */
++DECLARE_TREE_SCAN_INDEXING_FUNCTION
++
++DECLARE_TREE_SCAN_FUNC_CLEAN_SCAN_DATA
++
++DECLARE_TREE_SCAN_FUNC_CLEAN_SEG_SCAN_DATA
++
++/** \} */
++
++
++
++
++#ifndef IS_TREE_SEG_SCAN
++/* -------------------------------------------------------------------- */
++/** \name Scan Functions
++ * \{ */
++DECLARE_TREE_SCAN_FUNC_BLOCK
++
++DECLARE_TREE_SCAN_FUNC_AGGREGATE
++
++/** \} */
++#endif
++
++
++
++
++
++#ifdef IS_TREE_SEG_SCAN
++/* -------------------------------------------------------------------- */
++/** \name Segmented Tree Scan Functions
++ * \{ */
++
++DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP_FILL_CACHE
++
++DECLARE_TREE_SEGSCAN_FUNC_AGGREGATE_FILL_CACHE
++
++DECLARE_TREE_SEGSCAN_FUNC_UPSWEEP
++
++DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP
++
++/** \} */
++#endif
++
++
++
++
++
++#endif
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
+new file mode 100644
+index 00000000000..aaaecd11e34
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
+@@ -0,0 +1,576 @@
++#pragma BLENDER_REQUIRE(bnpr_hlsl_support_lib.glsl)
++
++#ifndef BNPR_SCAN_NO_SUBGROUP_INCLUDED
++#define BNPR_SCAN_NO_SUBGROUP_INCLUDED
++
++/* Scan Operators */
++uint u32_add(uint a, uint b)
++{
++	return a + b;
++}
++uvec2 uvec2_add(uvec2 a, uvec2 b)
++{
++	return a + b;
++}
++uvec3 uvec3_add(uvec3 a, uvec3 b)
++{
++	return a + b;
++}
++uvec4 uvec4_add(uvec4 a, uvec4 b)
++{
++	return a + b;
++}
++float f32_add(float a, float b)
++{
++	return a + b;
++}
++
++
++
++
++
++/* Inputs ---------------------                                                       */
++/* Example:                                                                           */
++/* (- basic -)                                                                        */
++/* #define SCAN_DATA_TYPE uvec2			    // Input data type for scan operation        */
++/* #define SCAN_OP(a, b) (a + b)				  // Scan operation                            */
++/* #define SCAN_ZERO_VAL                // Zero value for scan operator               */
++/* #define SCAN_BLOCK_SIZE 256			      // Typically thread_group_size               */
++/* #define SCAN_FUNCTION_TAG ScanTest   // Alias name for this set of scan ops        */
++/* ---------------------------------------                                            */
++
++
++/* Macro expansion, for details, see
++/* ---------------------------------------
++/* https://stackoverflow.com/questions/1489932/how-to-concatenate-twice-with-the-c-preprocessor-and-expand-a-macro-as-in-arg */
++#define CAT(x, y) CAT_(x, y)
++#define CAT_(x, y) x ## y
++
++
++/* Type & Type conversion & Scan OP
++/* --------------------------------------- */
++#define T SCAN_DATA_TYPE
++#define tag SCAN_FUNCTION_TAG
++#define OP SCAN_OP
++
++
++/* thread group size provided in glsl
++/* --------------------------------------- */
++#ifdef SCAN_BLOCK_SIZE
++# undef SCAN_BLOCK_SIZE
++#endif
++#define SCAN_BLOCK_SIZE ((gl_WorkGroupSize.x))
++
++#define DATA_SIZE       ((2u * SCAN_BLOCK_SIZE))
++
++
++/* Padding Macros for Eliminating Bank Conflicts
++/* --------------------------------------------------------- */
++#define NUM_BANKS       32
++#define LOG_NUM_BANKS   5
++#define OFFSET_BANK_CONFLICT_FREE(x) (((x) >> LOG_NUM_BANKS))
++
++
++// Tree Scan LDS Caches
++// ------------------------------------------------------------
++#define TREE_SCAN_CACHE CAT(TreeScanCache, tag)
++#define TREE_SCAN_CACHE_SIZE (DATA_SIZE + DATA_SIZE / NUM_BANKS)
++#define TREE_SCAN_CACHE_HF CAT(TreeScanCacheHF, tag)
++
++
++#define DECLARE_TREE_SCAN_CACHE \
++	shared T TREE_SCAN_CACHE[TREE_SCAN_CACHE_SIZE]; \
++
++#define DECLARE_TREE_SCAN_CACHE_HF \
++	shared uint TREE_SCAN_CACHE_HF[TREE_SCAN_CACHE_SIZE]; \
++
++
++
++// Tree Scan
++// ------------------------------------------------------------
++struct TreeScanIndices
++{
++  uvec2 global_x2; /* index of element in global compute buffer */
++  uvec2 lds_x2;    /* index of element 0/1 in shared memory */
++};
++
++/**
++ * \brief Returns (Global_scanAddr0, Global_scanAddr1, LDS_scanAddr0, LDS_scanAddr1)
++ *			LDS_scanAddr0/1 : index of element 0/1 in shared memory
++ *			Global_scanAddr0/1 : index of element in global compute buffer
++ */
++#define DECLARE_TREE_SCAN_INDEXING_FUNCTION                                                             \
++TreeScanIndices GetTreeScanIndices(					                                                        \
++	uint groupIdx, uint gIdx					                                                              \
++){  																				                                         \
++	const uint groupOffset = (DATA_SIZE) * gIdx.x;									                             \
++                                                                                                        \
++	uint ai = groupIdx;                /*   0   1   2   3 ... 255  => ai	*/	                          \
++	/* ------ + 1 * 512 ------- (Suppose gIdx.x == 1)						*/		                          \
++	uint scanAddrA = groupOffset + ai; /* 512 513 514 515 ... 767  => scanAddrA	*/	                    \
++                                                                                                        \
++	uint bi = ai + DATA_SIZE / 2; /* 256 257 258 259 ... 511   => bi			*/	                          \
++	uint scanAddrB = groupOffset + bi; /* 768 641 642 643 ... 1151  => scanAddrB*/	                    \
++                                                                                                        \
++	return TreeScanIndices(uvec2(scanAddrA, scanAddrB), uvec2(ai, bi));						                 \
++}                                                                                                       \
++
++
++#define _FUNC_CLEAN_SCAN_DATA CAT(TreeScanCleanData, tag)
++/**
++ * \brief Clear item that not mapped to actual scanned data
++ */
++#define DECLARE_TREE_SCAN_FUNC_CLEAN_SCAN_DATA \
++void _FUNC_CLEAN_SCAN_DATA( \
++    TreeScanIndices scan_ids,       \
++    uint num_scanned_items,         \
++    inout T scan_data_A,            \
++    inout T scan_data_B             \
++){ \
++  if (scan_ids.global_x2.x >= num_scanned_items)        \
++    scan_data_A = SCAN_ZERO_VAL;                        \
++  if (scan_ids.global_x2.y >= num_scanned_items)        \
++    scan_data_B = SCAN_ZERO_VAL;                        \
++} \
++
++
++#define _FUNC_CLEAN_SEG_SCAN_DATA CAT(TreeScanCleanData, tag)
++/**
++ * \brief Clear item that not mapped to actual scanned data
++ */
++#define DECLARE_TREE_SCAN_FUNC_CLEAN_SEG_SCAN_DATA \
++void _FUNC_CLEAN_SEG_SCAN_DATA( \
++	TreeScanIndices scan_ids,       \
++	uint num_scanned_items,         \
++	inout uint hf_A,                \
++	inout T scan_data_A,            \
++	inout uint hf_B,                \
++	inout T scan_data_B             \
++){ \
++	if (scan_ids.global_x2.x >= num_scanned_items)        \
++	{ \
++		scan_data_A = SCAN_ZERO_VAL;                       \
++		hf_A = 1u;                                         \
++	} \
++	if (scan_ids.global_x2.y >= num_scanned_items)        \
++	{ \
++		scan_data_B = SCAN_ZERO_VAL;                       \
++		hf_B = 1u;                                         \
++	} \
++} \
++
++
++#define _FUNC_TREE_SCAN_BLOCK CAT(TreeScanBlockExc, tag)
++/**
++ * \brief Declares a block-wise exclusive tree scan function.
++ */
++#define DECLARE_TREE_SCAN_FUNC_BLOCK \
++void _FUNC_TREE_SCAN_BLOCK( \
++    uint groupIdx,                    \
++    uint gIdx,                        \
++    T initialData_A,                  \
++    T initialData_B,                  \
++    out T scanRes_A,                  \
++    out T scanRes_B                   \
++){ \
++  TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);						           \
++  uint ai = scanAddrs.lds_x2.x;                                                        \
++  uint bi = scanAddrs.lds_x2.y;                                                        \
++  /* Bank Offset == index >> bits_banks(5 in Nvidia card) */                         \
++  uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);                                       \
++  uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);                                       \
++                                                                                       \
++  /*  Store data into LDS with memory bank offset                                      \
++  ---------------------------------------------------------------------                \
++  about 'tailvalue':                                                                   \
++  in prefix sum, last elem is going to be erased                                       \
++  but we will need it later, so cache it here */                                       \
++  TREE_SCAN_CACHE[ai + aiOffset] = initialData_A;                                      \
++  TREE_SCAN_CACHE[bi + biOffset] = initialData_B;                                      \
++  /* about LDS memory layout:                                                          \
++  Interleaved storage,                                                                 \
++  that is, ith(i % 32 == 0) is not used;                                               \
++  e.g:                                                                                 \
++  [0, 31]  X [32, 63] X  [64, 95]  X [96, 127]  -- Input CBuffer                       \
++      + 0________+1___________+2___________+3 ... -- + OFFSET_BANK...(x)               \
++  [0, 31] 32 [33, 64] 65 [66, 97] 98 [99, 130]  -- TREE_SCAN_CACHE                   */\
++  \
++  \
++  \
++  /* //////////////////////////////////////////////////////////////////////// */       \
++  /* Scan --- Phase II        Up-Sweeping                                     */       \
++  /* Work Indices:                                                            */       \
++  /* offset = 2^k                                                             */       \
++  /* a(i, k) = (2^k) * (2i + 1) - 1 = (2*gidx)*offset + offset - 1            */       \
++  /* b(i, k) = a(i, k) + 2^k = a(i, k) + offset                               */       \
++  /* i ~ groupIdx, k ~ iteration, all start from 0.                           */       \
++  uint offset = 1;     /* Step Length == 2^k */                                        \
++  uint d = DATA_SIZE / 2u; /* [0, ... , d]th threads are dispatched */           \
++  for (; d > 0; d >>= 1){                                                       \
++      barrier();                                                                \
++      if (groupIdx < d){                                                        \
++          ai = offset * (2 * groupIdx + 1) - 1;                                 \
++          bi = offset * (2 * groupIdx + 2) - 1;                                 \
++          ai += OFFSET_BANK_CONFLICT_FREE(ai);                                  \
++          bi += OFFSET_BANK_CONFLICT_FREE(bi);                                  \
++                                                                                \
++          TREE_SCAN_CACHE[bi] = OP(TREE_SCAN_CACHE[ai], TREE_SCAN_CACHE[bi]);		\
++      }                                                                         \
++      offset *= 2;                                                              \
++  }                                                                             \
++  \
++  \
++  \
++  /* ////////////////////////////////////////////////////////////////////////*/ \
++  /* Phase III */                                                               \
++  if (groupIdx == 0)                                                            \
++  {                                                                             \
++      /* Zero out last elem, prepare for up-sweeping */                         \
++      uint lastIndex = DATA_SIZE - 1 + OFFSET_BANK_CONFLICT_FREE(DATA_SIZE - 1);\
++      TREE_SCAN_CACHE[lastIndex] = SCAN_ZERO_VAL;                               \
++  }                                                                             \
++  \
++  \
++  \
++  /* ///////////////////////////////////////////////////////////////////////// */ \
++  /* Phase IV                 Down-Sweeping                                    */ \
++  /* Util this point,                                                          */ \
++  /* d == 0,                                                                   */ \
++  /* offset == GROUP_SIZE * 2 == DATA_SIZE                                     */ \
++  /* This is actually "rolling back + mirror" version of Phase I,              */ \
++  /* So this execution code is a mirrored loop                                 */ \
++  for (d = 1; d < DATA_SIZE; d *= 2){                                              \
++      offset >>= 1;                                                                \
++      barrier();                                           \
++      if (groupIdx < d){                                                           \
++          /* So the indexing function is the same, (rolling back)                  \
++          just the roles of ai & bi are switched                              */   \
++          ai = offset * (2 * groupIdx + 1) - 1;                                    \
++          bi = offset * (2 * groupIdx + 2) - 1;                                    \
++          ai += OFFSET_BANK_CONFLICT_FREE(ai);                                     \
++          bi += OFFSET_BANK_CONFLICT_FREE(bi);                                     \
++          /* swap */                                                               \
++          T aiValOld = TREE_SCAN_CACHE[ai];                                        \
++          TREE_SCAN_CACHE[ai] = TREE_SCAN_CACHE[bi];                               \
++          TREE_SCAN_CACHE[bi] = OP(aiValOld, TREE_SCAN_CACHE[bi]);                 \
++      }                                                                            \
++  }                                                                                \
++  barrier();                                               \
++  \
++  \
++  \
++  T pSumAtAi = TREE_SCAN_CACHE[groupIdx + aiOffset];                               \
++  T pSumAtBi = TREE_SCAN_CACHE[groupIdx + SCAN_BLOCK_SIZE + biOffset];             \
++  \
++  \
++  scanRes_A = pSumAtAi;                                     \
++  scanRes_B = pSumAtBi;                                     \
++} \
++
++
++#define _FUNC_TREE_SCAN_AGGREGATE CAT(TreeScanBlockAggregate, tag)
++/**
++ \brief Second step for tree scan.
++ *  Apply exclusive scan on
++ *  inclusive sums from each scanned data-block.
++*/
++#define DECLARE_TREE_SCAN_FUNC_AGGREGATE \
++void _FUNC_TREE_SCAN_AGGREGATE( \
++  uint groupIdx,        \
++  uint gIdx,            \
++  T aggregateA,         \
++  T aggregateB,         \
++  out T aggSumA,        \
++  out T aggSumB         \
++) \
++{				                    \
++  _FUNC_TREE_SCAN_BLOCK	        \
++  (			                    \
++    groupIdx,                   \
++    gIdx,                       \
++    aggregateA,                 \
++    aggregateB,                 \
++    aggSumA, /*out*/            \
++    aggSumB  /*out*/            \
++  );			                    \
++} \
++
++
++
++
++
++
++/* -------------------------------------------------------------------- */
++/** \name Segmented Tree Scan
++ *
++ * \{ */
++#define _FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE CAT(TreeSegScanExc_DwSweep_FillLDS_, tag)
++
++#define DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP_FILL_CACHE	\
++void _FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(	\
++	uint groupId, 					\
++	TreeScanIndices scanAddrs, 	  \
++	/* --- LDS inputs --- */ 	     \
++	uint encodedHFs_A,	           \
++	T partialSum_A,	              \
++	uint encodedHFs_B,	           \
++	T partialSum_B,	              \
++	T aggregateScanRes 				  \
++) {																																\
++	uint ai = scanAddrs.lds_x2.x;																			            \
++	uint bi = scanAddrs.lds_x2.y;																			            \
++	\
++	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
++	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
++	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
++	\
++	/*  Store data into LDS with memory bank offset								 	\
++	--------------------------------------------------------------------- 	\
++	about 'tailvalue':																		   \
++	in prefix sum, last elem is going to be erased								   \
++	but we will need it later, so cache it here                          */	\
++	uint cacheAddrAi = ai + aiOffset;																              \
++	uint cacheAddrBi = bi + biOffset;																              \
++	TREE_SCAN_CACHE[cacheAddrAi] = partialSum_A;													              \
++	TREE_SCAN_CACHE_HF[cacheAddrAi] = encodedHFs_A;													           \
++	/* Different from normal down-sweep that zeros out last elem, */								     \
++	/* We use output from prev inter-block scan kernel instead */									     \
++	TREE_SCAN_CACHE[cacheAddrBi] =                                                                 \
++		(groupId == SCAN_BLOCK_SIZE - 1)                                                            \
++			? aggregateScanRes : partialSum_B;	                                                     \
++	TREE_SCAN_CACHE_HF[cacheAddrBi] = encodedHFs_B;													           \
++} \
++
++
++#define _FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE CAT(TreeSegScanExc_Aggregate_FillLDS_, tag)
++
++#define DECLARE_TREE_SEGSCAN_FUNC_AGGREGATE_FILL_CACHE \
++void _FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE( \
++	uint groupId, 					\
++	TreeScanIndices scanAddrs, \
++	/* --- LDS inputs --- */ 	\
++	uint firstInitialHFAi,	   \
++	uint firstInitialHFBi	   \
++){ \
++	uint ai = scanAddrs.lds_x2.x;																			            \
++	uint bi = scanAddrs.lds_x2.y;																			            \
++	\
++	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
++	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
++	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
++	uint cacheAddrAi = ai + aiOffset;																               \
++	uint cacheAddrBi = bi + biOffset;																               \
++	if (groupId == 0u)                                                                              \
++	{                                                                                               \
++		/* Zero out last elem, prepare for up-sweeping */                                          \
++		uint lastIndex = DATA_SIZE - 1 + OFFSET_BANK_CONFLICT_FREE(DATA_SIZE - 1);                   \
++		TREE_SCAN_CACHE[lastIndex] = SCAN_ZERO_VAL;                                                  \
++	}                                                                                               \
++	barrier();                                                                                      \
++	                                                                                                \
++	/* Compared to normal seg-scan,						  */                                            \
++	/* need to encode original hfs differently here */                                            \
++	TREE_SCAN_CACHE_HF[cacheAddrAi] = tree_seg_scan_encode_upsweep_hfs(                             \
++		TREE_SCAN_CACHE_HF[cacheAddrAi], firstInitialHFAi                                            \
++	);                                                                                              \
++	TREE_SCAN_CACHE_HF[cacheAddrBi] = tree_seg_scan_encode_upsweep_hfs(                             \
++		TREE_SCAN_CACHE_HF[cacheAddrBi], firstInitialHFBi                                            \
++	);                                                                                              \
++}
++
++
++#define _FUNC_TREE_SEG_SCAN_UPSWEEP CAT(TreeSegScanExc_UpSweep_, tag)
++
++#define DECLARE_TREE_SEGSCAN_FUNC_UPSWEEP	\
++void _FUNC_TREE_SEG_SCAN_UPSWEEP(	\
++	uint groupIdx,				        \
++	uint gIdx,                      \
++	/* --- scan inputs --- */ 	  \
++	uint headFlagAi,	              \
++	T initialDataAi,	              \
++	uint headFlagBi,	              \
++	T initialDataBi,	              \
++	/* --- block partial sums --- */ \
++ 	out uint headFlagPartialSum_A,  \
++	out T partialSum_A,		        \
++	out uint headFlagPartialSum_B,  \
++	out T partialSum_B		        \
++) \
++{ \
++	/* -------------------------------------------------------	*/									      \
++	/* nAddr:													*/									                     \
++	/* .x: Global_scanAddr0, .y: Global_scanAddr1, 				*/									         \
++	/* .z: LDS_scanAddr0, .w: LDS_scanAddr1						*/									            \
++	TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);									      \
++	uint ai = scanAddrs.lds_x2.x;																			            \
++	uint bi = scanAddrs.lds_x2.y;																			            \
++																																	\
++	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
++	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
++	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
++																																	\
++	/*  Store data into LDS with memory bank offset								 \
++	--------------------------------------------------------------------- \
++	about 'tailvalue':																		\
++	in prefix sum, last elem is going to be erased								\
++	but we will need it later, so cache it here                          */	\
++	uint cacheAddrAi = ai + aiOffset;																               \
++	uint cacheAddrBi = bi + biOffset;																               \
++	TREE_SCAN_CACHE[cacheAddrAi] = initialDataAi;													            \
++	TREE_SCAN_CACHE_HF[cacheAddrAi] = headFlagAi;													            \
++	TREE_SCAN_CACHE[cacheAddrBi] = initialDataBi;													            \
++	TREE_SCAN_CACHE_HF[cacheAddrBi] = headFlagBi;													            \
++	/* about LDS memory layout:																		               \
++	Interleaved storage,																			                  \
++	that is, ith(i % 32 == 0) is not used;															            \
++	e.g:																							                        \
++	[0, 31]  X [32, 63] X  [64, 95]  X [96, 127]  -- Input CBuffer									      \
++		+ 0________+1___________+2___________+3 ... -- + OFFSET_BANK...(x)							   \
++	[0, 31] 32 [33, 64] 65 [66, 97] 98 [99, 130]  -- TREE_SCAN_CACHE			*/					      \
++                                                                                                	\
++                                                                                                	\
++	/* //////////////////////////////////////////////////////////////////////// */					\
++	/* Scan --- Phase II        Up-Sweeping                                     */					\
++	/* Work Indices:                                                            */					\
++	/* offset = 2^k                                                             */					\
++	/* a(i, k) = (2^k) * (2i + 1) - 1 = (2*gidx)*offset + offset - 1            */					\
++	/* b(i, k) = a(i, k) + 2^k = a(i, k) + offset                               */					\
++	/* i ~ groupIdx, k ~ iteration, all start from 0.                           */					\
++	uint offset = 1u; /* Step Length == 2^k */														            \
++	uint d = DATA_SIZE / 2u; /* [0, ... , d]th threads are dispatched */								   \
++                                                                                                   \
++	bool activeThread;																				                  \
++	for (; d > 0; d >>= 1)																			                  \
++	{																								                        \
++		activeThread = groupIdx < d;																                  \
++																																	\
++		ai = offset * (2u * groupIdx + 1u) - 1u;														            \
++		bi = offset * (2u * groupIdx + 2u) - 1u;														            \
++		ai += OFFSET_BANK_CONFLICT_FREE(ai);														               \
++		bi += OFFSET_BANK_CONFLICT_FREE(bi);														               \
++																																	\
++		barrier();															                                       \
++		bool isSegHeadAtBi = (0u != (1u & TREE_SCAN_CACHE_HF[bi]));												\
++		if (activeThread && (!isSegHeadAtBi))														               \
++		{																							                        \
++			TREE_SCAN_CACHE[bi] = OP(TREE_SCAN_CACHE[ai], TREE_SCAN_CACHE[bi]);						      \
++		}																							                        \
++		barrier();															                                       \
++	                                                                                                \
++		TREE_SCAN_CACHE_HF[bi] = activeThread																		   \
++			? uint(isSegHeadAtBi || bool(TREE_SCAN_CACHE_HF[ai]))												   \
++			: uint(isSegHeadAtBi);																		               \
++                                                                                                   \
++		offset *= 2u;																				                     \
++	}																								                        \
++                                                                                                   \
++	barrier();																                                       \
++                                                                                                   \
++																																	\
++	partialSum_A = TREE_SCAN_CACHE[cacheAddrAi];													               \
++	partialSum_B = TREE_SCAN_CACHE[cacheAddrBi];													               \
++	headFlagPartialSum_A = TREE_SCAN_CACHE_HF[cacheAddrAi];											         \
++	headFlagPartialSum_B = TREE_SCAN_CACHE_HF[cacheAddrBi];											         \
++} \
++
++
++#define _FUNC_TREE_SEG_SCAN_DWSWEEP CAT(TreeSegScanExc_DwSweep_, tag)
++
++#define DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP	\
++void _FUNC_TREE_SEG_SCAN_DWSWEEP( \
++	uint groupIdx,	                  \
++	uint gIdx,		                  \
++	/* --- scan results --- */ \
++	out T scanResult_A,	            \
++	out T scanResult_B	            \
++) \
++{																									            \
++	/* Addressing & Data Loading											*/					         \
++	/* scanAddrs:																*/					         \
++	/* -- .x: Global_scanAddr0, .y: Global_scanAddr1, 			*/				            \
++	/* -- .z: LDS_scanAddr0,    .w: LDS_scanAddr1					*/					         \
++	TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);                     \
++	\
++	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */                        \
++	uint ai = scanAddrs.lds_x2.x;																			\
++	uint bi = scanAddrs.lds_x2.y;																			\
++	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													\
++	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													\
++	\
++	/*  Store data into LDS with memory bank offset												\
++	/* instead should call "_FUNC_TREE_SEG_SCAN_FILL_CACHE"                            \
++	* ---------------------------------------------------------------------				\
++	* about 'tailvalue':																				   \
++	* in prefix sum, last elem is going to be erased												\
++	* but we will need it later, so cache it here */					                     \
++	uint cacheAddrAi = ai + aiOffset;																   \
++	uint cacheAddrBi = bi + biOffset;																   \
++	/**TREE_SCAN_CACHE[cacheAddrAi] = partialSum_A;		*/										\
++	/**TREE_SCAN_CACHE_HF[cacheAddrAi] = encodedHFs_A;	*/										\
++	/**TREE_SCAN_CACHE[cacheAddrBi] = partialSum_B;		*/										\
++	/**TREE_SCAN_CACHE_HF[cacheAddrBi] = encodedHFs_B;	*/										\
++	\
++	\
++	/* ///////////////////////////////////////////////////////////////////////// */	\
++	/* Phase IV                 Down-Sweeping                                    */	\
++	/* Util this point,                                                          */	\
++	/* d == 0,                                                                   */	\
++	/* offset == GROUP_SIZE * 2 == DATA_SIZE                                     */	\
++	/* This is actually "rolling back + mirror" version of Phase I,              */	\
++	/* So this execution code is a mirrored loop                                 */	\
++	uint offset = DATA_SIZE;																		      \
++	uint d = 0u;																						      \
++	bool activeThread;																				      \
++	for (d = 1u; d < DATA_SIZE; d *= 2u)																\
++	{																								            \
++		offset >>= 1;																				         \
++		/* So the indexing function is the same, (rolling back)	                    \
++		 * just the roles of ai & bi are switched */                                   \
++		ai = offset * (2u * groupIdx + 1u) - 1u;														\
++		bi = offset * (2u * groupIdx + 2u) - 1u;														\
++		uint aiNext = ai + 1u + OFFSET_BANK_CONFLICT_FREE(ai + 1u);						      \
++		ai += OFFSET_BANK_CONFLICT_FREE(ai);														   \
++		bi += OFFSET_BANK_CONFLICT_FREE(bi);														   \
++	                                                                                    \
++		activeThread = groupIdx < d;																      \
++		                                                                                 \
++		barrier();															                           \
++		T valAi = TREE_SCAN_CACHE[ai];																   \
++		T valBi = TREE_SCAN_CACHE[bi];																   \
++		                                                                                 \
++		barrier();															                           \
++		if (activeThread) /* swap */																      \
++			TREE_SCAN_CACHE[ai] = valBi;															      \
++		                                                                                 \
++		barrier();															                           \
++		uint origHFAiNext = /*DECODE_ORIG_HF(TREE_SCAN_CACHE_HF[aiNext]);*/            \
++			tree_seg_scan_decode_upsweep_hfs_get_origHF(TREE_SCAN_CACHE_HF[aiNext]);	   \
++		uint currHFAi = /**DECODE_CURR_HF(TREE_SCAN_CACHE_HF[ai]);*/							\
++			tree_seg_scan_decode_upsweep_hfs_get_sumHF(TREE_SCAN_CACHE_HF[ai]);           \
++		                                                                                 \
++		if (activeThread)																			         \
++		{																							            \
++			TREE_SCAN_CACHE[bi] = (origHFAiNext == 1u)                                    \
++ 				? SCAN_ZERO_VAL : ((currHFAi == 1u) ? valAi : OP(valAi, valBi));           \
++		}																							            \
++		                                                                                 \
++		barrier();															                           \
++		/* Clear partial sum hf, keep original flag */										   \
++		TREE_SCAN_CACHE_HF[ai] &= 0x00000002u;														   \
++	}																								            \
++	                                                                                    \
++	barrier();																                           \
++	                                                                                    \
++	scanResult_A = TREE_SCAN_CACHE[cacheAddrAi];                                        \
++	scanResult_B = TREE_SCAN_CACHE[cacheAddrBi];                                        \
++} \
++
++
++
++/** \} */
++
++
++
++
++#endif
++
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+new file mode 100644
+index 00000000000..30b1fc097a8
+--- /dev/null
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+@@ -0,0 +1,279 @@
++#pragma BLENDER_REQUIRE(bnpr_scan_no_subgroup_codegen_lib.glsl)
++
++
++/* input buffers:
++ * -----------------------------------------------
++ * BnprScanDataBuf        bnpr_in_scan_data_buf_
++ * BnprScanDataBuf        bnpr_out_scan_data_buf_
++ * BnprScanBlockSumBuf    bnpr_scan_block_sum_buf_
++*/
++
++#define T_To_Uint(x) x
++#define Uint_To_T(x) x
++
++#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP)
++void main()
++{
++  const uint groupId =  gl_LocalInvocationID.x;
++
++  TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
++
++  T scanval_A, scanval_B;
++  { /* init & store random scan input vals */
++    scanval_A = T(
++      wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
++    );
++    scanval_B = T(
++      wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
++    );
++    /* avoid invalid loads */
++    _FUNC_CLEAN_SCAN_DATA(
++      scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
++      scanval_A, scanval_B /* <- inout */
++    );
++    bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanval_A);
++    bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanval_B);
++  }
++
++
++
++  /* execute block-wise exlusive scan */
++  T scanRes_ai, scanRes_bi;
++  _FUNC_TREE_SCAN_BLOCK(
++        groupId,
++        gl_WorkGroupID.x,
++        scanval_A,
++        scanval_B,
++        /* -out- */
++        scanRes_ai,
++        scanRes_bi
++  );
++
++  /* store scan results */
++  bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanRes_ai);
++  bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanRes_bi);
++
++  /* store block aggregate */
++  if (groupId == gl_WorkGroupSize.x - 1)
++  {
++    bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = /**floatBitsToUint*/(SCAN_OP(scanRes_bi, scanval_B));
++  }
++}
++#endif
++
++
++
++
++
++
++#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE)
++void main()
++{
++  const uint groupId =  gl_LocalInvocationID.x;
++  const uint gIdx =     gl_WorkGroupID.x;
++
++  TreeScanIndices scanAddrs = GetTreeScanIndices(groupId, 0);
++  T aggregate_A = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x]);
++  T aggregate_B = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y]);
++
++  T aggregateSum_A, aggregateSum_B;
++  _FUNC_TREE_SCAN_AGGREGATE(
++	  groupId,
++	  gIdx,
++	  aggregate_A,
++	  aggregate_B,
++	  aggregateSum_A,
++	  aggregateSum_B
++  );
++
++  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x] = /**floatBitsToUint*/(aggregateSum_A);
++  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y] = /**floatBitsToUint*/(aggregateSum_B);
++
++
++}
++#endif
++
++
++
++
++
++
++#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP)
++void main()
++{
++	const uint groupId = gl_LocalInvocationID.x;
++	const uint gIdx = gl_WorkGroupID.x;
++
++	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
++
++	T block_scan_res_A, block_scan_res_B;
++	block_scan_res_A = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2[0]]);
++	block_scan_res_B = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2[1]]);
++
++	T aggregate_sum = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
++
++	bnpr_out_scan_data_buf_[scan_ids.global_x2[0]] = /**floatBitsToUint*/(SCAN_OP(aggregate_sum, block_scan_res_A));
++	bnpr_out_scan_data_buf_[scan_ids.global_x2[1]] = /**floatBitsToUint*/(SCAN_OP(aggregate_sum, block_scan_res_B));
++}
++#endif
++
++
++
++#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_UPSWEEP)
++void main()
++{
++	const uint groupId =  gl_LocalInvocationID.x;
++
++	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
++
++	T scanval_A, scanval_B;
++	uint hf_A, hf_B;
++	{ /* init & store random scan input vals */
++		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
++		scanval_A = T(
++			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
++		);
++		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
++		scanval_B = T(
++			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
++		);
++		/* avoid invalid loads */
++		_FUNC_CLEAN_SEG_SCAN_DATA(
++			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
++			hf_A, scanval_A, hf_B, scanval_B /* <- inout */
++		);
++		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(hf_A, scanval_A);
++		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(hf_B, scanval_B);
++	}
++
++
++
++	/* execute block-wise exlusive scan */
++	uint headFlagPartialSum_A, headFlagPartialSum_B;
++	T scanRes_ai, scanRes_bi;
++	_FUNC_TREE_SEG_SCAN_UPSWEEP(
++		groupId,
++		gl_WorkGroupID.x,
++		hf_A, 						scanval_A,
++		hf_B, 						scanval_B,
++		/* -out- */
++		headFlagPartialSum_A, 	scanRes_ai,
++		headFlagPartialSum_B, 	scanRes_bi
++	);
++
++	/* store scan results */
++	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(
++		tree_seg_scan_encode_upsweep_hfs(hf_A, headFlagPartialSum_A),
++		scanRes_ai
++	);
++	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(
++		tree_seg_scan_encode_upsweep_hfs(hf_B, headFlagPartialSum_B),
++		scanRes_bi
++	);
++
++	/* store block aggregate */
++	if (groupId == gl_WorkGroupSize.x - 1)
++	{
++		bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = SEGSCAN_STRUCT_TYPE(
++			tree_seg_scan_encode_upsweep_hfs(
++				headFlagPartialSum_B,  /* or sum of block hfs */
++				TREE_SCAN_CACHE_HF[0]  /* original hf of block */
++			),
++			/* different from ordinary scan, we store exclusive sum here */
++			scanval_B
++		);
++	}
++}
++#endif
++
++
++#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_AGGREGATE)
++void main()
++{
++	const uint groupId = gl_LocalInvocationID.x;
++	const uint gIdx = gl_WorkGroupID.x;
++
++	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, 0);
++
++	SEGSCAN_STRUCT_TYPE aggregate_A = bnpr_scan_block_sum_buf_[scan_ids.global_x2.x];
++	T partialSumTreeAi = aggregate_A.val;
++	uint partialOrTreeAi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_A.hf);
++	uint firstInitialHFAi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_A.hf);
++
++	SEGSCAN_STRUCT_TYPE aggregate_B = bnpr_scan_block_sum_buf_[scan_ids.global_x2.y];
++	T partialSumTreeBi = aggregate_B.val;
++	uint partialOrTreeBi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_B.hf);
++	uint firstInitialHFBi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_B.hf);
++
++	T upsweep_res_sum_A, upsweep_res_sum_B;
++	uint upsweep_res_hf_A, upsweep_res_hf_B;
++	_FUNC_TREE_SEG_SCAN_UPSWEEP(
++		groupId,
++		gl_WorkGroupID.x,
++		partialOrTreeAi, partialSumTreeAi,
++		partialOrTreeBi, partialSumTreeBi,
++		/* -out- */
++		upsweep_res_hf_A, upsweep_res_sum_A,
++		upsweep_res_hf_B, upsweep_res_sum_B
++	);
++
++
++
++	_FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE(
++		groupId, scan_ids,
++		/* --- LDS inputs --- */
++		firstInitialHFAi, firstInitialHFBi
++	);
++
++
++
++	T scan_res_A, scan_res_B;
++	_FUNC_TREE_SEG_SCAN_DWSWEEP
++	(
++		groupId, gIdx,
++		/* --- out --- */
++		scan_res_A, scan_res_B
++	);
++
++
++	/* store scan results */
++	bnpr_scan_block_sum_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(0, scan_res_A); /* no hf needed */
++	bnpr_scan_block_sum_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(0, scan_res_B); /* no hf needed */
++}
++#endif
++
++
++#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_DWSWEEP)
++void main()
++{
++	const uint groupId = gl_LocalInvocationID.x;
++	const uint gIdx = gl_WorkGroupID.x;
++
++	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
++
++	SEGSCAN_STRUCT_TYPE block_scan_res_A, block_scan_res_B, aggregate_scan_res;
++	block_scan_res_A = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2.x]);
++	block_scan_res_B = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2.y]);
++	aggregate_scan_res = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
++
++	_FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(
++		groupId, scan_ids,
++		/* --- block partial sums --- */
++		block_scan_res_A.hf, block_scan_res_A.val,
++		block_scan_res_B.hf, block_scan_res_B.val,
++		/* --- scanned block aggregate --- */
++		aggregate_scan_res.val
++	);
++
++	T scan_res_A, scan_res_B;
++	_FUNC_TREE_SEG_SCAN_DWSWEEP
++	(
++		groupId, gIdx,
++		/* --- out --- */
++		scan_res_A, scan_res_B
++	);
++
++	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(block_scan_res_A.hf, scan_res_A);
++	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(block_scan_res_B.hf, scan_res_B);
++}
++#endif
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+index 964ee4114e3..b34970b05d3 100644
+--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+@@ -7,5 +7,5 @@
+ 
+ void main()
+ {
+-
++  buf_test[0] = buf_ibo[0];
+ }
+diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+index bea2190c8d3..410ed1085ac 100644
+--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
++++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+@@ -57,14 +57,135 @@
+ /** \} */
+ 
+ 
++/* -------------------------------------------------------------------- */
++/** \shared shader infos
++ * \{ */
++GPU_SHADER_CREATE_INFO(bnpr_scan_uint_add)
++  .typedef_source("bnpr_shader_shared.hh")
++  .define("SCAN_DATA_TYPE", "uint")
++  .define("SCAN_OP", "u32_add")
++  .define("SCAN_ZERO_VAL", "0u")
++  .define("SCAN_FUNCTION_TAG", "_u32_add")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_uvec2_add)
++  .typedef_source("bnpr_shader_shared.hh")
++  .define("SCAN_DATA_TYPE", "uvec2")
++  .define("SCAN_OP", "uvec2_add")
++  .define("SCAN_ZERO_VAL", "uvec2(0u, 0u)")
++  .define("SCAN_FUNCTION_TAG", "uvec2_add")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_uvec3_add)
++  .typedef_source("bnpr_shader_shared.hh")
++  .define("SCAN_DATA_TYPE", "uvec3")
++  .define("SCAN_OP", "uvec3_add")
++  .define("SCAN_ZERO_VAL", "uvec3(0u, 0u, 0u)")
++  .define("SCAN_FUNCTION_TAG", "uvec3_add")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_uvec4_add)
++  .typedef_source("bnpr_shader_shared.hh")
++  .define("SCAN_DATA_TYPE", "uvec4")
++  .define("SCAN_OP", "uvec4_add")
++  .define("SCAN_ZERO_VAL", "uvec4(0u, 0u, 0u, 0u)")
++  .define("SCAN_FUNCTION_TAG", "uvec4_add")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_float_add)
++  .typedef_source("bnpr_shader_shared.hh")
++  .define("SCAN_DATA_TYPE", "float")
++  .define("SCAN_OP", "f32_add")
++  .define("SCAN_ZERO_VAL", ".0f")
++  .define("SCAN_FUNCTION_TAG", "_f32_add")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_test_inputs)
++  .additional_info("bnpr_scan_uvec3_add")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_segscan_test_inputs)
++  .additional_info("bnpr_scan_uvec3_add")
++  .define("SEGSCAN_STRUCT_TYPE", "SSBOData_SegScanTest")
++;
++
+ 
+ /* -------------------------------------------------------------------- */
+-/** \test
++/** \test shaders
+  * \{ */
+ GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
+   .do_static_compilation(true)
+-  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
++  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test[]")
++  .storage_buf(1, Qualifier::READ, "uint", "buf_ibo[]")
+   .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
+-  .compute_source("bnpr_strokegen_test_comp.glsl");
++  .compute_source("bnpr_strokegen_test_comp.glsl")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_test_upsweep)
++  .do_static_compilation(true)
++  .additional_info("bnpr_scan_test_inputs")
++  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP", "1")
++  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_in_scan_data_buf_[]")
++  .storage_buf(1, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
++  .storage_buf(2, Qualifier::WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
++  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
++  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_scan_test_comp.glsl")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_test_aggregate)
++  .do_static_compilation(true)
++  .additional_info("bnpr_scan_test_inputs")
++  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE", "1")
++  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
++  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_scan_test_comp.glsl")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_scan_test_dwsweep)
++  .do_static_compilation(true)
++  .additional_info("bnpr_scan_test_inputs")
++  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP", "1")
++  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
++  .storage_buf(1, Qualifier::READ, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
++  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_scan_test_comp.glsl")
++;
++
++
++GPU_SHADER_CREATE_INFO(bnpr_segscan_test_upsweep)
++  .do_static_compilation(true)
++  .additional_info("bnpr_segscan_test_inputs")
++  .define("IS_TREE_SEG_SCAN", "1")
++  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_UPSWEEP", "1")
++  .storage_buf(0, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_in_scan_data_buf_[]")
++  .storage_buf(1, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_out_scan_data_buf_[]")
++  .storage_buf(2, Qualifier::WRITE,       BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
++  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
++  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_scan_test_comp.glsl")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_segscan_test_aggregate)
++  .do_static_compilation(true)
++  .additional_info("bnpr_segscan_test_inputs")
++  .define("IS_TREE_SEG_SCAN", "1")
++  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_AGGREGATE", "1")
++  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
++  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_scan_test_comp.glsl")
++;
++
++GPU_SHADER_CREATE_INFO(bnpr_segscan_test_dwsweep)
++  .do_static_compilation(true)
++  .additional_info("bnpr_segscan_test_inputs")
++  .define("IS_TREE_SEG_SCAN",                             "1")
++  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_DWSWEEP", "1")
++  .storage_buf(0, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_out_scan_data_buf_[]")
++  .storage_buf(1, Qualifier::READ,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
++  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
++  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
++  .compute_source("bnpr_scan_test_comp.glsl")
++;
+ 
+ /** \} */
+-- 
+2.38.1.windows.1
+
+
+From ce1b4301d24dc432ac5016f6b596c4870515db0c Mon Sep 17 00:00:00 2001
+From: Jiang <jwtstone@gmail.com>
+Date: Thu, 12 Jan 2023 00:07:25 +0800
+Subject: [PATCH 11/11] Learning ssbo alignment
+
+---
+ source/blender/draw/engines/bnpr/bnpr_defines.hh     |  2 +-
+ .../engines/bnpr/shaders/bnpr_scan_test_comp.glsl    | 12 ++++++------
+ 2 files changed, 7 insertions(+), 7 deletions(-)
+
+diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+index 4cc48d0ddd0..f56a53922e9 100644
+--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
++++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
+@@ -19,7 +19,7 @@
+ 
+ 
+ #ifndef GPU_SHADER
+-# define BNPR_SCAN_TEST_DATA_TYPE uint4
++# define BNPR_SCAN_TEST_DATA_TYPE uint3
+ # define BNPR_SCAN_TEST_DATA_TYPE_STR "uvec3"
+ 
+ // remember to update SSBOData_SegScanTest if this changes
+diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+index 30b1fc097a8..62d535037b5 100644
+--- a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
++++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+@@ -129,14 +129,14 @@ void main()
+ 	T scanval_A, scanval_B;
+ 	uint hf_A, hf_B;
+ 	{ /* init & store random scan input vals */
+-		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
+-		scanval_A = T(
++		hf_A = 0xffffffff; /**uint(scan_ids.global_x2.x % 3u == 0u);*/ /**1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);*/
++		scanval_A = T(scan_ids.global_x2.x); /**T(
+ 			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
+-		);
+-		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
+-		scanval_B = T(
++		);*/
++		hf_B = 0xffffffff;/**uint(scan_ids.global_x2.y % 3u == 0u);*//**1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u)*/;
++		scanval_B = T(scan_ids.global_x2.y); /**T(
+ 			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
+-		);
++		);*/
+ 		/* avoid invalid loads */
+ 		_FUNC_CLEAN_SEG_SCAN_DATA(
+ 			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
+-- 
+2.38.1.windows.1
+
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index b7e0c17e628..d345433f2d2 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -124,12 +124,12 @@ using namespace draw;
 
   struct SSBOData_SegScanTest
   {
-    uint hf;
 #ifndef GPU_SHADER
     uint3 val;
 #else
     uvec3 val;
 #endif
+    uint hf;
   };
   // BLI_STATIC_ASSERT_ALIGN(SSBOData_SegScanTest, 16)
 
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
index 62d535037b5..5fe326adef6 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
@@ -123,27 +123,29 @@ void main()
 void main()
 {
 	const uint groupId =  gl_LocalInvocationID.x;
+	const uint idx = gl_GlobalInvocationID.x;
 
 	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
 
 	T scanval_A, scanval_B;
 	uint hf_A, hf_B;
 	{ /* init & store random scan input vals */
-		hf_A = 0xffffffff; /**uint(scan_ids.global_x2.x % 3u == 0u);*/ /**1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);*/
-		scanval_A = T(scan_ids.global_x2.x); /**T(
+		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
+		if (idx == 0) hf_A = 0u;
+		scanval_A = T(
 			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
-		);*/
-		hf_B = 0xffffffff;/**uint(scan_ids.global_x2.y % 3u == 0u);*//**1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u)*/;
-		scanval_B = T(scan_ids.global_x2.y); /**T(
+		);
+		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
+		scanval_B = T(
 			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
-		);*/
+		);
 		/* avoid invalid loads */
 		_FUNC_CLEAN_SEG_SCAN_DATA(
 			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
 			hf_A, scanval_A, hf_B, scanval_B /* <- inout */
 		);
-		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(hf_A, scanval_A);
-		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(hf_B, scanval_B);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(scanval_A, hf_A);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(scanval_B, hf_B);
 	}
 
 
@@ -163,24 +165,24 @@ void main()
 
 	/* store scan results */
 	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(
-		tree_seg_scan_encode_upsweep_hfs(hf_A, headFlagPartialSum_A),
-		scanRes_ai
+		scanRes_ai,
+		tree_seg_scan_encode_upsweep_hfs(hf_A, headFlagPartialSum_A)
 	);
 	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(
-		tree_seg_scan_encode_upsweep_hfs(hf_B, headFlagPartialSum_B),
-		scanRes_bi
+		scanRes_bi,
+		tree_seg_scan_encode_upsweep_hfs(hf_B, headFlagPartialSum_B)
 	);
 
 	/* store block aggregate */
 	if (groupId == gl_WorkGroupSize.x - 1)
 	{
 		bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = SEGSCAN_STRUCT_TYPE(
+			/* different from ordinary scan, we store exclusive sum here */
+			scanval_B,
 			tree_seg_scan_encode_upsweep_hfs(
 				headFlagPartialSum_B,  /* or sum of block hfs */
 				TREE_SCAN_CACHE_HF[0]  /* original hf of block */
-			),
-			/* different from ordinary scan, we store exclusive sum here */
-			scanval_B
+			)
 		);
 	}
 }
@@ -237,8 +239,8 @@ void main()
 
 
 	/* store scan results */
-	bnpr_scan_block_sum_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(0, scan_res_A); /* no hf needed */
-	bnpr_scan_block_sum_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(0, scan_res_B); /* no hf needed */
+	bnpr_scan_block_sum_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(scan_res_A, 0); /* no hf needed */
+	bnpr_scan_block_sum_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(scan_res_B, 0); /* no hf needed */
 }
 #endif
 
@@ -273,7 +275,7 @@ void main()
 		scan_res_A, scan_res_B
 	);
 
-	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(block_scan_res_A.hf, scan_res_A);
-	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(block_scan_res_B.hf, scan_res_B);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(scan_res_A, block_scan_res_A.hf);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(scan_res_B, block_scan_res_B.hf);
 }
 #endif
-- 
2.38.1.windows.1


From 3c01cb1e3f88c07811aa9fce14fae1298db8661b Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 14 Jan 2023 17:00:16 +0800
Subject: [PATCH 13/13] Segmented Scan uvec3 test

Finally ported parallel segmented scan into Blender.
Passed the test for uvec3.

Without subgroup this became much harder since I need to use Blelloch style scan, which is ridiculously complicated, and the paper omits several important details...

I used some silly macros in glsl to make the scan generic for data type(uint, vec3u, float, ...) & scan operators(+, -, min, ...) ,
not sure if this is safe in Blender?
---
 .../draw/engines/bnpr/bnpr_instance.cc        |  12 +
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |   3 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 365 +++++++++++-------
 source/blender/draw/engines/bnpr/bnpr_sync.cc |   2 +-
 .../bnpr/shaders/bnpr_scan_test_comp.glsl     | 174 +++++----
 .../bnpr/shaders/infos/bnpr_test_info.hh      |   8 +-
 6 files changed, 351 insertions(+), 213 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index ecc7d8b9cf5..3ef4f4903b5 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -147,6 +147,18 @@ namespace blender::bnpr
       // strokegen_passes.validate_pass_scan_test<BNPR_SCAN_TEST_DATA_TYPE>(
       //   [](const BNPR_SCAN_TEST_DATA_TYPE& a, const BNPR_SCAN_TEST_DATA_TYPE& b) {return a == b;}
       // );
+      strokegen_passes.validate_segscan<SSBOData_SegScanTest>(
+        [](const SSBOData_SegScanTest& a, const SSBOData_SegScanTest& b) { return a.val == b.val; },
+        [](const SSBOData_SegScanTest& a) { return a.hf; },
+        [](const SSBOData_SegScanTest& a, const SSBOData_SegScanTest& b)
+        {
+          return SSBOData_SegScanTest{a.val + b.val, 0};
+        },
+        SSBOData_SegScanTest{
+          uint3(0u, 0u, 0u), 1u
+        },
+        false
+      );
     }
     frame_counter = (frame_counter + 1) % 100000000;
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index e302d2672dc..c43f61de74f 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -19,9 +19,8 @@ namespace blender::bnpr
     rebuild_pass_segscan_test();
   }
 
-  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch)
+  void StrokeGenPassModule::rebuild_pass_extract_mesh_geom(Object* ob, GPUBatch* gpu_batch)
   {
-
   }
 
   void StrokeGenPassModule::rebuild_pass_scan_test()
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index b2904d012df..3a219405334 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -17,165 +17,272 @@
 #include "bnpr_strokegen_texture_pool.hh"
 #include "bnpr_strokegen_pass.hh"
 
-namespace blender::bnpr
-{
-  class Instance;
+namespace blender::bnpr {
+class Instance;
 
-  class StrokeGenPassModule // similar to "LineDrawingRenderPass"
-  {
-  private:
-    /** Compute Passes */
-    draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
-    draw::PassSimple pass_scan_test = {"Bnpr GPU Blelloch Scan Test"};
-    draw::PassSimple pass_segscan_test = {"Bnpr GPU Blelloch SegScan Test"};
-
-    /** Instance */
-    ShaderModule &shaders_;
-    GPUBufferPoolModule& buffers_;
-    GPUTexturePoolModule& textures_;
-
-
-  public:
-    StrokeGenPassModule(
-      ShaderModule          &strokegen_shaders,
-      GPUBufferPoolModule   &strokegen_buffers,
-      GPUTexturePoolModule  &strokegen_textures
-    ) :
-      shaders_(strokegen_shaders),
+class StrokeGenPassModule // similar to "LineDrawingRenderPass"
+{
+private:
+  /** Compute Passes */
+  draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
+  draw::PassSimple pass_scan_test = {"Bnpr GPU Blelloch Scan Test"};
+  draw::PassSimple pass_segscan_test = {"Bnpr GPU Blelloch SegScan Test"};
+  
+  /** Instance */
+  ShaderModule &shaders_;
+  GPUBufferPoolModule &buffers_;
+  GPUTexturePoolModule &textures_;
+
+
+public:
+  StrokeGenPassModule(
+      ShaderModule &strokegen_shaders,
+      GPUBufferPoolModule &strokegen_buffers,
+      GPUTexturePoolModule &strokegen_textures
+      )
+    : shaders_(strokegen_shaders),
       buffers_(strokegen_buffers),
       textures_(strokegen_textures)
-    {};
-
-    ~StrokeGenPassModule() {};
-
-    /** Passes Batched by Usages */
-    enum eType
-    {
-      SCAN_TEST = 0,
-      SEGSCAN_TEST
-    };
-
-    PassSimple& get_compute_pass(eType passType)
-    {
-      switch (passType) {
-        case SCAN_TEST:
-          return pass_scan_test;
-        case SEGSCAN_TEST:
-          return pass_segscan_test;
-      }
-      return pass_comp_test;
-    }
-
-    void sync();
-    void rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch);
-    void rebuild_pass_scan_test();
-    void rebuild_pass_segscan_test();
-
-
-    template<typename T>
-    void validate_pass_scan_test(bool (*equals)(const T&, const T&));
-
-    template<typename T>
-    bool validate_inter_block_exclusive_scan(
-      const T* bufferInputVals, const T* bufferPrefixSum,
-      bool (*equals)(const T&, const T&),
-      uint num_scan_items, uint blk_size, uint numBlocks
-    );
-    template<typename T>
-    bool validate_exclusive_scan(
-      const T* bufferInputVals, const T* bufferPrefixSum,
-      bool (*equals)(const T&, const T&),
-      uint num_scan_items
-    );
-
-
+  {
   };
 
+  ~StrokeGenPassModule()
+  {
+  };
 
+  /** Passes Batched by Usages */
+  enum eType {
+    SCAN_TEST = 0,
+    SEGSCAN_TEST
+  };
 
-  template <typename T>
-  void StrokeGenPassModule::validate_pass_scan_test(bool (*equals)(const T&, const T&))
+  PassSimple &get_compute_pass(eType passType)
   {
-    SSBO_BnprScanData& buf_scan_inputs = buffers_.ssbo_bnpr_in_scan_data_;
-    buf_scan_inputs.read();
-    T* data_scan_inputs = reinterpret_cast<T*>(buf_scan_inputs.data());
+    switch (passType) {
+      case SCAN_TEST:
+        return pass_scan_test;
+      case SEGSCAN_TEST:
+        return pass_segscan_test;
+    }
+    return pass_comp_test;
+  }
+
+  void sync();
+  
+  /**
+   * \brief Extract geometry info from given GPUBatch of a mesh object.
+   * \param ob Mesh Object
+   * \param gpu_batch Mesh geometry stored in GPUBatch, ib stored with line adjacency info.
+   */
+  void rebuild_pass_extract_mesh_geom(Object *ob, GPUBatch *gpu_batch);
+
+  void rebuild_pass_scan_test();
+
+  void rebuild_pass_segscan_test();
+
+
+  /* -------------------------------------------------------------------- */
+  /** \name Scan Tester
+   * \{ */
+  template<typename T>
+  void validate_pass_scan_test(bool (*equals)(const T &, const T &));
+  template<typename T>
+  bool validate_inter_block_exclusive_scan(
+      const T *bufferInputVals,
+      const T *bufferPrefixSum,
+      bool (*equals)(const T &, const T &),
+      uint num_scan_items,
+      uint blk_size,
+      uint numBlocks
+      );
+  template<typename T>
+  bool validate_exclusive_scan(
+      const T *bufferInputVals,
+      const T *bufferPrefixSum,
+      bool (*equals)(const T &, const T &),
+      uint num_scan_items
+      );
+  /** \} */
+
+
+  /* -------------------------------------------------------------------- */
+  /** \name Segment Scan Tester
+   * \{ */
+  template<typename T>
+  void validate_segscan(
+    bool (*func_equals)(const T&, const T&),
+    uint (*func_get_hf)(const T&),
+    T (*func_scan_op)(const T&, const T&),
+    T zero_val,
+    bool inclusive = false
+  );
+  template<typename T>
+  bool validate_segscan_internal(
+    const T *input,
+    const T *output,
+    int blk_size,
+    uint (*func_get_hf)(const T&),
+    bool (*func_equals)(const T &, const T &),
+    T (*func_scan_op)(const T&, const T&),
+    T zero_value,
+    bool inclusive = false
+  );
+
+  /** \} */
+
+
+};
+
+
+template<typename T>
+void StrokeGenPassModule::validate_pass_scan_test(bool (*equals)(const T &, const T &))
+{
+  SSBO_BnprScanData &buf_scan_inputs = buffers_.ssbo_bnpr_in_scan_data_;
+  buf_scan_inputs.read();
+  T *data_scan_inputs = reinterpret_cast<T *>(buf_scan_inputs.data());
 
-    SSBO_BnprScanData& buf_scan_output = buffers_.ssbo_bnpr_out_scan_data_;
-    buf_scan_output.read();
-    T* data_scan_output = reinterpret_cast<T*>(buf_scan_output.data());
+  SSBO_BnprScanData &buf_scan_output = buffers_.ssbo_bnpr_out_scan_data_;
+  buf_scan_output.read();
+  T *data_scan_output = reinterpret_cast<T *>(buf_scan_output.data());
 
-    bool valid_inter_block_scan = StrokeGenPassModule::validate_inter_block_exclusive_scan<T>(
-      data_scan_inputs, data_scan_output,
+  bool valid_inter_block_scan = StrokeGenPassModule::validate_inter_block_exclusive_scan<T>(
+      data_scan_inputs,
+      data_scan_output,
       equals,
       buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items,
       GROUP_SIZE_BNPR_SCAN_TEST_SWEEP * 2u,
       buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups
-    );
-    if (!valid_inter_block_scan)
-      fprintf(stderr, "bnpr: error: INTER-BLOCK scan test failed");
+      );
+  if (!valid_inter_block_scan)
+    fprintf(stderr, "bnpr: error: INTER-BLOCK scan test failed");
 
-    bool valid_global_scan = StrokeGenPassModule::validate_exclusive_scan<T>(
-      data_scan_inputs, data_scan_output,
+  bool valid_global_scan = StrokeGenPassModule::validate_exclusive_scan<T>(
+      data_scan_inputs,
+      data_scan_output,
       equals,
       buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items
-    );
-    if (!valid_global_scan)
-      fprintf(stderr, "bnpr: error: GLOBAL scan test failed");
-  }
+      );
+  if (!valid_global_scan)
+    fprintf(stderr, "bnpr: error: GLOBAL scan test failed");
+}
 
 
-  template <typename T>
-  bool StrokeGenPassModule::validate_inter_block_exclusive_scan(
-    const T* const bufferInputVals, const T* const bufferPrefixSum,
-    bool (*equals)(const T&, const T&),
-    uint num_scan_items, uint blk_size, uint numBlocks
-  )
-  {
-    Vector<int> failedElems(0);
-
-    for (uint blk_id = 0u; blk_id < numBlocks; blk_id++)
-    {
-      for (uint blk_offset = 0u; blk_offset < blk_size - 1u; blk_offset++)
-      {
-        // index might go out of bound
-        uint index = blk_id * blk_size + blk_offset;
-        if (index >= num_scan_items - 2u)
-          break;
-
-        if (false == equals(
-          bufferPrefixSum[index] + bufferInputVals[index],
-          bufferPrefixSum[index + 1]
-        ))
-        {
-          failedElems.append(index);
-        }
+template<typename T>
+bool StrokeGenPassModule::validate_inter_block_exclusive_scan(
+    const T *const bufferInputVals,
+    const T *const bufferPrefixSum,
+    bool (*equals)(const T &, const T &),
+    uint num_scan_items,
+    uint blk_size,
+    uint numBlocks
+)
+{
+  Vector<int> failedElems(0);
+
+  for (uint blk_id = 0u; blk_id < numBlocks; blk_id++) {
+    for (uint blk_offset = 0u; blk_offset < blk_size - 1u; blk_offset++) {
+      // index might go out of bound
+      uint index = blk_id * blk_size + blk_offset;
+      if (index >= num_scan_items - 2u)
+        break;
+
+      if (false == equals(
+              bufferPrefixSum[index] + bufferInputVals[index],
+              bufferPrefixSum[index + 1]
+              )) {
+        failedElems.append(index);
       }
     }
+  }
 
-    if (!failedElems.is_empty())
-    {
-      return false;
-    }
-
-    return true;
+  if (!failedElems.is_empty()) {
+    return false;
   }
 
+  return true;
+}
+
 
-  template <typename T>
-  bool StrokeGenPassModule::validate_exclusive_scan(const T* bufferInputVals,
-                                                    const T* bufferPrefixSum,
-                                                    bool (* equals)(const T&, const T&),
-                                                    uint num_scan_items)
-  {
-    return validate_inter_block_exclusive_scan(
-      bufferInputVals, bufferPrefixSum,
+template<typename T>
+bool StrokeGenPassModule::validate_exclusive_scan(const T *bufferInputVals,
+                                                  const T *bufferPrefixSum,
+                                                  bool (* equals)(const T &, const T &),
+                                                  uint num_scan_items)
+{
+  return validate_inter_block_exclusive_scan(
+      bufferInputVals,
+      bufferPrefixSum,
       equals,
       num_scan_items,
       num_scan_items,
       1
-    );
-  }
+      );
+}
+
+template<typename T>
+void StrokeGenPassModule::validate_segscan(
+  bool (*func_equals)(const T&, const T&),
+  uint (*func_get_hf)(const T&),
+  T (*func_scan_op)(const T&, const T&),
+  T zero_val,
+  bool inclusive)
+{
+  SSBO_BnprScanData &buf_segscan_inputs = buffers_.ssbo_bnpr_in_scan_data_;
+  buf_segscan_inputs.read();
+  T *data_segscan_inputs = reinterpret_cast<T *>(buf_segscan_inputs.data());
+
+  SSBO_BnprScanData &buf_segscan_output = buffers_.ssbo_bnpr_out_scan_data_;
+  buf_segscan_output.read();
+  T *data_segscan_output = reinterpret_cast<T *>(buf_segscan_output.data());
+
+  bool succ = validate_segscan_internal(
+    data_segscan_inputs,
+    data_segscan_output,
+    GROUP_SIZE_BNPR_SCAN_TEST_SWEEP * 2u,
+    func_get_hf, func_equals, func_scan_op, zero_val,
+    inclusive
+  );
+
+  if (!succ)
+    fprintf(stderr, "bnpr: error: segment scan test failed");
+}
+
+template<typename T>
+bool StrokeGenPassModule::validate_segscan_internal(
+  const T *input,
+  const T *output,
+  const int blk_size,
+  uint (*func_get_hf)(const T &),
+  bool (*func_equals)(const T &, const T &),
+  T (*func_scan_op)(const T&, const T&),
+  T zero_value,
+  const bool inclusive)
+{
+  T maxErrorFound = zero_value;
+  T currScanValue = zero_value;
+
+  for (int i = 0; i < blk_size; i++) {
+    if (func_get_hf(input[i])) {
+      currScanValue = zero_value;
+    }
+
+    if (inclusive) {
+      // Inclusive scan
+      currScanValue = func_scan_op(currScanValue, input[i]);
+    }
+
+    if (false == func_equals(currScanValue, output[i])) {
+      return false;
+    }
 
+    if (!inclusive) {
+      // Exclusive scan
+      currScanValue = func_scan_op(currScanValue, input[i]);
+    }
+  }
 
+  return true;
 }
 
+
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index cd708ab9fb2..09cbc6eb8af 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -75,7 +75,7 @@ namespace blender::bnpr
     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
     //  strokegen_passes.dispatch_XXX(...);
     //  ... ... ...
-    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob, geobatch);
+    inst_.strokegen_passes.rebuild_pass_extract_mesh_geom(ob, geobatch);
 
 
 
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
index 5fe326adef6..1216a7e340e 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
@@ -14,50 +14,53 @@
 #if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP)
 void main()
 {
-  const uint groupId =  gl_LocalInvocationID.x;
-
-  TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
-
-  T scanval_A, scanval_B;
-  { /* init & store random scan input vals */
-    scanval_A = T(
-      wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
-    );
-    scanval_B = T(
-      wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
-    );
-    /* avoid invalid loads */
-    _FUNC_CLEAN_SCAN_DATA(
-      scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
-      scanval_A, scanval_B /* <- inout */
-    );
-    bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanval_A);
-    bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanval_B);
-  }
-
-
-
-  /* execute block-wise exlusive scan */
-  T scanRes_ai, scanRes_bi;
-  _FUNC_TREE_SCAN_BLOCK(
-        groupId,
-        gl_WorkGroupID.x,
-        scanval_A,
-        scanval_B,
-        /* -out- */
-        scanRes_ai,
-        scanRes_bi
-  );
-
-  /* store scan results */
-  bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanRes_ai);
-  bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanRes_bi);
-
-  /* store block aggregate */
-  if (groupId == gl_WorkGroupSize.x - 1)
-  {
-    bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = /**floatBitsToUint*/(SCAN_OP(scanRes_bi, scanval_B));
-  }
+	const uint groupId = gl_LocalInvocationID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	T scanval_A, scanval_B;
+	{ /* init & store random scan input vals */
+		scanval_A = T(
+		wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
+		);
+		scanval_B = T(
+		wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
+		);
+		/* ------------------------------------------------------------------------ */
+		/* avoid invalid loads */
+		_FUNC_CLEAN_SCAN_DATA(
+		scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
+		scanval_A, scanval_B /* <- inout */
+		);
+		/* ------------------------------------------------------------------------ */
+
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanval_A);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanval_B);
+	}
+
+
+
+	/* execute block-wise exlusive scan */
+	T scanRes_ai, scanRes_bi;
+	_FUNC_TREE_SCAN_BLOCK(
+	groupId,
+	gl_WorkGroupID.x,
+	scanval_A,
+	scanval_B,
+	/* -out- */
+	scanRes_ai,
+	scanRes_bi
+	);
+
+	/* store scan results */
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanRes_ai);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanRes_bi);
+
+	/* store block aggregate */
+	if (groupId == gl_WorkGroupSize.x - 1)
+	{
+		bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = /**floatBitsToUint*/(SCAN_OP(scanRes_bi, scanval_B));
+	}
 }
 #endif
 
@@ -69,25 +72,25 @@ void main()
 #if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE)
 void main()
 {
-  const uint groupId =  gl_LocalInvocationID.x;
-  const uint gIdx =     gl_WorkGroupID.x;
-
-  TreeScanIndices scanAddrs = GetTreeScanIndices(groupId, 0);
-  T aggregate_A = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x]);
-  T aggregate_B = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y]);
-
-  T aggregateSum_A, aggregateSum_B;
-  _FUNC_TREE_SCAN_AGGREGATE(
-	  groupId,
-	  gIdx,
-	  aggregate_A,
-	  aggregate_B,
-	  aggregateSum_A,
-	  aggregateSum_B
-  );
+	const uint groupId =  gl_LocalInvocationID.x;
+	const uint gIdx =     gl_WorkGroupID.x;
+
+	TreeScanIndices scanAddrs = GetTreeScanIndices(groupId, 0);
+	T aggregate_A = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x]);
+	T aggregate_B = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y]);
+
+	T aggregateSum_A, aggregateSum_B;
+	_FUNC_TREE_SCAN_AGGREGATE(
+	groupId,
+	gIdx,
+	aggregate_A,
+	aggregate_B,
+	aggregateSum_A,
+	aggregateSum_B
+	);
 
-  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x] = /**floatBitsToUint*/(aggregateSum_A);
-  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y] = /**floatBitsToUint*/(aggregateSum_B);
+	bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x] = /**floatBitsToUint*/(aggregateSum_A);
+	bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y] = /**floatBitsToUint*/(aggregateSum_B);
 
 
 }
@@ -130,20 +133,24 @@ void main()
 	T scanval_A, scanval_B;
 	uint hf_A, hf_B;
 	{ /* init & store random scan input vals */
-		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
+		hf_A = 1u & uint(wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 128u == 0u);
 		if (idx == 0) hf_A = 0u;
-		scanval_A = T(
+			scanval_A = T(
 			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
 		);
-		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
-		scanval_B = T(
+		hf_B = 1u & uint(wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 128u == 0u);
+			scanval_B = T(
 			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
 		);
+
 		/* avoid invalid loads */
+		/* ----------------------------------------------------------- */
 		_FUNC_CLEAN_SEG_SCAN_DATA(
 			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
 			hf_A, scanval_A, hf_B, scanval_B /* <- inout */
 		);
+		/* ----------------------------------------------------------- */
+
 		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(scanval_A, hf_A);
 		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(scanval_B, hf_B);
 	}
@@ -151,6 +158,7 @@ void main()
 
 
 	/* execute block-wise exlusive scan */
+	/* ----------------------------------------------------------- */
 	uint headFlagPartialSum_A, headFlagPartialSum_B;
 	T scanRes_ai, scanRes_bi;
 	_FUNC_TREE_SEG_SCAN_UPSWEEP(
@@ -162,29 +170,39 @@ void main()
 		headFlagPartialSum_A, 	scanRes_ai,
 		headFlagPartialSum_B, 	scanRes_bi
 	);
+	/* ----------------------------------------------------------- */
 
+	
 	/* store scan results */
+	/* ----------------------------------------------------------- */
 	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(
-		scanRes_ai,
-		tree_seg_scan_encode_upsweep_hfs(hf_A, headFlagPartialSum_A)
+	scanRes_ai,
+		tree_seg_scan_encode_upsweep_hfs(headFlagPartialSum_A, hf_A)
 	);
 	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(
 		scanRes_bi,
-		tree_seg_scan_encode_upsweep_hfs(hf_B, headFlagPartialSum_B)
+		tree_seg_scan_encode_upsweep_hfs(headFlagPartialSum_B, hf_B)
 	);
+	/* ----------------------------------------------------------- */
+
 
 	/* store block aggregate */
+	/* ----------------------------------------------------------- */
 	if (groupId == gl_WorkGroupSize.x - 1)
 	{
+		uint debug_hf = uint((wang_hash(gl_WorkGroupID.x * 17u) % 12u) == 0u); /* debug only */
+
 		bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = SEGSCAN_STRUCT_TYPE(
 			/* different from ordinary scan, we store exclusive sum here */
 			scanval_B,
 			tree_seg_scan_encode_upsweep_hfs(
-				headFlagPartialSum_B,  /* or sum of block hfs */
+				headFlagPartialSum_B, /* or sum of block hfs */
 				TREE_SCAN_CACHE_HF[0]  /* original hf of block */
 			)
 		);
 	}
+	/* ----------------------------------------------------------- */
+
 }
 #endif
 
@@ -207,6 +225,8 @@ void main()
 	uint partialOrTreeBi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_B.hf);
 	uint firstInitialHFBi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_B.hf);
 
+
+
 	T upsweep_res_sum_A, upsweep_res_sum_B;
 	uint upsweep_res_hf_A, upsweep_res_hf_B;
 	_FUNC_TREE_SEG_SCAN_UPSWEEP(
@@ -222,7 +242,7 @@ void main()
 
 
 	_FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE(
-		groupId, scan_ids,
+	groupId, scan_ids,
 		/* --- LDS inputs --- */
 		firstInitialHFAi, firstInitialHFBi
 	);
@@ -259,12 +279,12 @@ void main()
 	aggregate_scan_res = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
 
 	_FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(
-		groupId, scan_ids,
-		/* --- block partial sums --- */
-		block_scan_res_A.hf, block_scan_res_A.val,
-		block_scan_res_B.hf, block_scan_res_B.val,
-		/* --- scanned block aggregate --- */
-		aggregate_scan_res.val
+	    groupId, scan_ids,
+	    /* --- block partial sums --- */
+	    block_scan_res_A.hf, block_scan_res_A.val,
+	    block_scan_res_B.hf, block_scan_res_B.val,
+	    /* --- scanned block aggregate --- */
+	    aggregate_scan_res.val
 	);
 
 	T scan_res_A, scan_res_B;
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
index 410ed1085ac..18180ffe2a0 100644
--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -100,7 +100,7 @@ GPU_SHADER_CREATE_INFO(bnpr_scan_float_add)
   .define("SCAN_FUNCTION_TAG", "_f32_add")
 ;
 
-GPU_SHADER_CREATE_INFO(bnpr_scan_test_inputs)
+GPU_SHADER_CREATE_INFO(bnpr_scan_inputs_test)
   .additional_info("bnpr_scan_uvec3_add")
 ;
 
@@ -123,7 +123,7 @@ GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
 
 GPU_SHADER_CREATE_INFO(bnpr_scan_test_upsweep)
   .do_static_compilation(true)
-  .additional_info("bnpr_scan_test_inputs")
+  .additional_info("bnpr_scan_inputs_test")
   .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP", "1")
   .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_in_scan_data_buf_[]")
   .storage_buf(1, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
@@ -135,7 +135,7 @@ GPU_SHADER_CREATE_INFO(bnpr_scan_test_upsweep)
 
 GPU_SHADER_CREATE_INFO(bnpr_scan_test_aggregate)
   .do_static_compilation(true)
-  .additional_info("bnpr_scan_test_inputs")
+  .additional_info("bnpr_scan_inputs_test")
   .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE", "1")
   .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
   .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
@@ -144,7 +144,7 @@ GPU_SHADER_CREATE_INFO(bnpr_scan_test_aggregate)
 
 GPU_SHADER_CREATE_INFO(bnpr_scan_test_dwsweep)
   .do_static_compilation(true)
-  .additional_info("bnpr_scan_test_inputs")
+  .additional_info("bnpr_scan_inputs_test")
   .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP", "1")
   .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
   .storage_buf(1, Qualifier::READ, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
-- 
2.38.1.windows.1

